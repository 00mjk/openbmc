From 19459c799ac0a521082d6d79e68ffc3decb18ea2 Mon Sep 17 00:00:00 2001
From: Ori Bernstein <orib@fb.com>
Date: Thu, 3 Sep 2015 11:28:27 -0700
Subject: [PATCH] Create snapshot of OpenBMC

---
 .../arch/arm/configs/wedge_defconfig               |    1 +
 .../arch/arm/configs/yosemite_defconfig            | 1480 ++++++++++++++++++++
 .../arch/arm/include/asm/ioctls.h                  |    1 +
 .../arch/arm/mach-aspeed/Kconfig                   |   12 +
 .../arch/arm/mach-aspeed/gpio.c                    |    2 +-
 .../arm/mach-aspeed/include/mach/debug-macro.S     |    4 +-
 .../arch/arm/mach-aspeed/include/mach/platform.h   |   17 +-
 .../arch/arm/mach-aspeed/include/mach/uncompress.h |    6 +-
 .../arch/arm/mach-aspeed/include/mach/vmalloc.h    |    4 +-
 .../arch/arm/plat-aspeed/ast-scu.c                 |  372 ++---
 .../arch/arm/plat-aspeed/dev-eth.c                 |   35 +-
 .../arch/arm/plat-aspeed/dev-i2c.c                 |  385 +++--
 .../arch/arm/plat-aspeed/dev-spi.c                 |   27 +-
 .../arch/arm/plat-aspeed/dev-uart.c                |   50 +-
 .../arch/arm/plat-aspeed/irq.c                     |   28 +-
 .../linux-aspeed-2.6.28.9/drivers/hwmon/ast_adc.c  |  233 +--
 .../drivers/i2c/busses/i2c-ast.c                   |  689 +++++----
 .../linux-aspeed-2.6.28.9/drivers/i2c/i2c-core.c   |   15 +-
 .../linux-aspeed-2.6.28.9/drivers/i2c/i2c-dev.c    |  113 +-
 .../drivers/net/ftgmac100_26.c                     | 1211 ++++++++++++++--
 .../drivers/net/ftgmac100_26.h                     |   67 +-
 .../linux-aspeed-2.6.28.9/drivers/rtc/rtc-aspeed.c |   42 +-
 .../linux-aspeed-2.6.28.9/drivers/serial/8250.c    |   39 +-
 .../linux-aspeed-2.6.28.9/drivers/watchdog/Kconfig |    9 +-
 .../drivers/watchdog/ast_wdt.c                     |   27 +
 .../files/linux-aspeed-2.6.28.9/fs/compat_ioctl.c  |   51 +-
 .../linux-aspeed-2.6.28.9/include/linux/i2c-dev.h  |    1 +
 .../linux-aspeed-2.6.28.9/include/linux/i2c.h      |    6 +
 ...m25p80-Add-support-for-the-Winbond-W25Q64.patch |   29 +
 ...t-leak-packets-when-a-netns-is-going-down.patch |   56 +
 ...int-error-value-when-skb-allocation-fails.patch |   43 +
 .../recipes-kernel/linux/linux-aspeed_2.6.28.9.bb  |   17 +-
 34 files changed, 7064 insertions(+), 950 deletions(-)
 create mode 100644 arch/arm/configs/fbplatform1_defconfig
 create mode 100644 arch/arm/configs/yosemite_defconfig
 create mode 100644 meta-aspeed/recipes-kernel/linux/files/patch-2.6.28.9/0029-mtd-m25p80-Add-support-for-the-Winbond-W25Q64.patch
 create mode 100644 meta-aspeed/recipes-kernel/linux/files/patch-2.6.28.9/0030-net-Don-t-leak-packets-when-a-netns-is-going-down.patch
 create mode 100644 meta-aspeed/recipes-kernel/linux/files/patch-2.6.28.9/0031-IPv6-Print-error-value-when-skb-allocation-fails.patch

diff --git a/arch/arm/configs/wedge_defconfig b/arch/arm/configs/wedge_defconfig
index 23a9fe3..41fe288 100644
--- a/arch/arm/configs/wedge_defconfig
+++ b/arch/arm/configs/wedge_defconfig
@@ -174,6 +174,7 @@ CONFIG_IRMP=y
 # CONFIG_ARCH_AST2200 is not set
 # CONFIG_ARCH_AST2300 is not set
 CONFIG_ARCH_AST2400=y
+CONFIG_WEDGE=y
 # CONFIG_ARCH_AST2500 is not set
 
 #
diff --git a/arch/arm/configs/yosemite_defconfig b/arch/arm/configs/yosemite_defconfig
new file mode 100644
index 0000000..d32f18e
--- /dev/null
+++ b/arch/arm/configs/yosemite_defconfig
@@ -0,0 +1,1480 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.28.9
+# Tue Feb  3 16:41:40 2015
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_MMU=y
+# CONFIG_NO_IOPORT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_ARCH_HAS_ILOG2_U32 is not set
+# CONFIG_ARCH_HAS_ILOG2_U64 is not set
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=m
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=16
+# CONFIG_CGROUPS is not set
+# CONFIG_GROUP_SCHED is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_SLUB_DEBUG=y
+CONFIG_COMPAT_BRK=y
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+# CONFIG_MARKERS is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_LSF is not set
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_CLASSIC_RCU=y
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_ARCH_ASPEED=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_ARCH_MSM is not set
+CONFIG_IRMP=y
+# CONFIG_PCEXT is not set
+# CONFIG_REMOTEFX is not set
+# CONFIG_ARCH_AST1100 is not set
+# CONFIG_ARCH_AST2100 is not set
+# CONFIG_ARCH_AST2200 is not set
+# CONFIG_ARCH_AST2300 is not set
+CONFIG_ARCH_AST2400=y
+CONFIG_YOSEMITE=y
+# CONFIG_ARCH_AST2500 is not set
+
+#
+# FLASH Chip Select
+#
+# CONFIG_AST_CS0_NOR is not set
+# CONFIG_AST_CS0_NAND is not set
+CONFIG_AST_CS0_SPI=y
+# CONFIG_AST_CS0_NONE is not set
+# CONFIG_AST_CS1_NOR is not set
+# CONFIG_AST_CS1_NAND is not set
+# CONFIG_AST_CS1_SPI is not set
+CONFIG_AST_CS1_NONE=y
+# CONFIG_AST_CS2_NOR is not set
+# CONFIG_AST_CS2_NAND is not set
+# CONFIG_AST_CS2_SPI is not set
+CONFIG_AST_CS2_NONE=y
+# CONFIG_AST_CS3_NOR is not set
+# CONFIG_AST_CS3_NAND is not set
+# CONFIG_AST_CS3_SPI is not set
+CONFIG_AST_CS3_NONE=y
+# CONFIG_AST_CS4_NOR is not set
+# CONFIG_AST_CS4_NAND is not set
+# CONFIG_AST_CS4_SPI is not set
+CONFIG_AST_CS4_NONE=y
+# CONFIG_ARCH_AST1070 is not set
+# CONFIG_AST_SCU_LOCK is not set
+
+#
+# Boot options
+#
+
+#
+# Power management
+#
+CONFIG_PLAT_ASPEED=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_NOIFAR=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+# CONFIG_OUTER_CACHE is not set
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+CONFIG_ARCH_FLATMEM_HAS_HOLES=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0
+CONFIG_ZBOOT_ROM_BSS=0
+CONFIG_CMDLINE=""
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+CONFIG_FPE_NWFPE_XP=y
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=m
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=m
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=m
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+CONFIG_VLAN_8021Q=m
+# CONFIG_VLAN_8021Q_GVRP is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+CONFIG_WAN_ROUTER=y
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+CONFIG_MTD_DATAFLASH=m
+CONFIG_MTD_DATAFLASH_WRITE_VERIFY=y
+# CONFIG_MTD_DATAFLASH_OTP is not set
+CONFIG_MTD_M25P80=y
+CONFIG_M25PXX_USE_FAST_READ=y
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_RD_BZIP2 is not set
+CONFIG_RD_LZMA=y
+CONFIG_RD_GZIP=y
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_C2PORT is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+CONFIG_SCSI_TGT=y
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=m
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+CONFIG_BONDING=m
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=m
+# CONFIG_VETH is not set
+# CONFIG_NET_ETHERNET is not set
+CONFIG_NETDEV_1000=y
+CONFIG_ASPEEDMAC=y
+# CONFIG_NETDEV_10000 is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+# CONFIG_WLAN_80211 is not set
+# CONFIG_IWLWIFI_LEDS is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_GPIO is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+# CONFIG_MOUSE_PS2_ELANTECH is not set
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+CONFIG_MOUSE_SERIAL=y
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_GPIO is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=5
+CONFIG_SERIAL_8250_RUNTIME_UARTS=5
+# CONFIG_SERIAL_AST_DMA_UART is not set
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_AST is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_AST_MISC=y
+# CONFIG_AST_VIDEO is not set
+# CONFIG_ADC_CAT9883 is not set
+# CONFIG_AST_SPI_BIOS is not set
+CONFIG_AST_PECI=y
+# CONFIG_AST_KCS is not set
+# CONFIG_AST_GPIO is not set
+# CONFIG_HW_RANDOM is not set
+CONFIG_NVRAM=y
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_AST=y
+CONFIG_AST_I2C_SLAVE_MODE=y
+# CONFIG_AST_I2C_SLAVE_EEPROM is not set
+CONFIG_AST_I2C_SLAVE_RDWR=y
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+CONFIG_AT24=m
+# CONFIG_SENSORS_EEPROM is not set
+CONFIG_SENSORS_PCF8574=m
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_AST=y
+CONFIG_SPI_FMC=y
+CONFIG_SPI_BITBANG=y
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_AT25=m
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO expanders:
+#
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADCXX is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7473 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM70 is not set
+CONFIG_SENSORS_LM75=m
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+CONFIG_SENSORS_MAX127=m
+# CONFIG_SENSORS_MAX1111 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+CONFIG_SENSORS_ADS7828=m
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+CONFIG_SENSORS_AST_ADC=y
+CONFIG_SENSORS_AST_PWM_FAN=y
+# CONFIG_SENSORS_FB_PANTHER_PLUS is not set
+CONFIG_PMBUS=m
+CONFIG_SENSORS_PMBUS=m
+CONFIG_SENSORS_ADM1275=m
+# CONFIG_SENSORS_LM25066 is not set
+# CONFIG_SENSORS_LTC2978 is not set
+# CONFIG_SENSORS_MAX16064 is not set
+# CONFIG_SENSORS_MAX34440 is not set
+# CONFIG_SENSORS_MAX8688 is not set
+CONFIG_SENSORS_PFE1100=m
+CONFIG_SENSORS_PFE3000=m
+# CONFIG_SENSORS_UCD9000 is not set
+# CONFIG_SENSORS_UCD9200 is not set
+# CONFIG_SENSORS_ZL6100 is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_AST_WATCHDOG=y
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+# CONFIG_DAB is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+# CONFIG_FB is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_SOUND is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_EHCI_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# AST USB Drivers
+#
+CONFIG_AST_USB_UHCI_HCD=y
+# CONFIG_AST_USB_UHCI_MULTIPORT_1 is not set
+# CONFIG_AST_USB_UHCI_MULTIPORT_2 is not set
+CONFIG_AST_USB_UHCI_MULTIPORT_4=y
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_ATMEL_USBA is not set
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+CONFIG_USB_GADGET_ASPEED_AST=y
+CONFIG_USB_ASPEED_AST=y
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_ZERO=m
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+CONFIG_USB_G_SERIAL=m
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+CONFIG_USB_CDC_COMPOSITE=m
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_NEW_LEDS is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+CONFIG_RTC_DRV_ASPEED=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_UIO is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_CONFIGFS_FS=m
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_9BYTE_TAGS is not set
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_TAGS_ECC is not set
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+# CONFIG_YAFFS_EMPTY_LOST_AND_FOUND is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_SUNRPC_REGISTER_V4 is not set
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+CONFIG_NLS_CODEPAGE_936=y
+CONFIG_NLS_CODEPAGE_950=y
+CONFIG_NLS_CODEPAGE_932=y
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+
+#
+# Tracers
+#
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_DEBUG_USER is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_SECURITY_FILE_CAPABILITIES is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=m
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=m
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=m
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_HW is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+CONFIG_CRC_ITU_T=m
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+
+
+# GUC USB Drivers
+#
+CONFIG_GUC_USB_UHCI_HCD=m
+# CONFIG_GUC_USB_UHCI_MULTIPORT_1 is not set
+# CONFIG_GUC_USB_UHCI_MULTIPORT_2 is not set
+CONFIG_GUC_USB_UHCI_MULTIPORT_4=y
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
diff --git a/arch/arm/include/asm/ioctls.h b/arch/arm/include/asm/ioctls.h
index a91d8a1..fd50ffe 100644
--- a/arch/arm/include/asm/ioctls.h
+++ b/arch/arm/include/asm/ioctls.h
@@ -65,6 +65,7 @@
 #define TIOCSERGETLSR   0x5459 /* Get line status register */
 #define TIOCSERGETMULTI 0x545A /* Get multiport config  */
 #define TIOCSERSETMULTI 0x545B /* Set multiport config */
+#define TIOCSERWAITTEMT 0x5499 /* Wait for empty */
 
 #define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
 #define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
diff --git a/arch/arm/mach-aspeed/Kconfig b/arch/arm/mach-aspeed/Kconfig
index a948ab8..6d548f8 100644
--- a/arch/arm/mach-aspeed/Kconfig
+++ b/arch/arm/mach-aspeed/Kconfig
@@ -203,6 +203,18 @@ endchoice
 config AST_SCU_LOCK
 	bool "AST SCU Protection Key"
 
+config WEDGE
+	bool "Facebook Wedge/6-Pack"
+
+config WEDGE100
+	bool "Facebook Wedge100"
+
+config YOSEMITE
+	bool "Facebook Yosemite"
+
+config FBPLATFORM1
+	bool "Facebook Platform1"
+
 # Support PCIE
 config PCIE
         bool "ASPEED PCIE support"
diff --git a/arch/arm/mach-aspeed/gpio.c b/arch/arm/mach-aspeed/gpio.c
index 3a633e9..e56ca35 100644
--- a/arch/arm/mach-aspeed/gpio.c
+++ b/arch/arm/mach-aspeed/gpio.c
@@ -232,7 +232,7 @@ static struct ast_gpio_bank ast_gpio_gp[] = {
 	AST_GPIO_BANK("GPIOR", IO_ADDRESS(AST_GPIO_BASE), 1, 0x080, 0x084, 0x118, 0x11c, 0x128, 0x12c, 0x130, 0x110),	
 	AST_GPIO_BANK("GPIOS", IO_ADDRESS(AST_GPIO_BASE), 2, 0x080, 0x084, 0x118, 0x11c, 0x128, 0x12c, 0x130, 0x110),
 #if defined(CONFIG_ARCH_AST2400)		
-	AST_GPIO_BANK("GPIOT", IO_ADDRESS(AST_GPIO_BASE), 4, 0x080, 0x084, 0x118, 0x11c, 0x128, 0x12c, 0x130, 0x110),	
+	AST_GPIO_BANK("GPIOT", IO_ADDRESS(AST_GPIO_BASE), 3, 0x080, 0x084, 0x118, 0x11c, 0x128, 0x12c, 0x130, 0x110),	
 	AST_GPIO_BANK("GPIOU", IO_ADDRESS(AST_GPIO_BASE), 0, 0x088, 0x08c, 0x148, 0x14c, 0x158, 0x15c, 0x160, 0x140),
 	AST_GPIO_BANK("GPIOV", IO_ADDRESS(AST_GPIO_BASE), 1, 0x088, 0x08c, 0x148, 0x14c, 0x158, 0x15c, 0x160, 0x140),
 	AST_GPIO_BANK("GPIOW", IO_ADDRESS(AST_GPIO_BASE), 2, 0x088, 0x08c, 0x148, 0x14c, 0x158, 0x15c, 0x160, 0x140),
diff --git a/arch/arm/mach-aspeed/include/mach/debug-macro.S b/arch/arm/mach-aspeed/include/mach/debug-macro.S
index ff3195a..33fc879 100644
--- a/arch/arm/mach-aspeed/include/mach/debug-macro.S
+++ b/arch/arm/mach-aspeed/include/mach/debug-macro.S
@@ -13,8 +13,8 @@
 	.macro	addruart, rx, tmp
 	mrc 	p15, 0, \rx, c1, c0
 	tst 	\rx, #1 								@ MMU enabled?
-	ldreq   \rx, =AST_UART3_BASE
-	ldrne	\rx, =IO_ADDRESS(AST_UART3_BASE)
+	ldreq   \rx, =AST_UART_BASE
+	ldrne	\rx, =IO_ADDRESS(AST_UART_BASE)
 	.endm
 	
 #define UART_SHIFT      2
diff --git a/arch/arm/mach-aspeed/include/mach/platform.h b/arch/arm/mach-aspeed/include/mach/platform.h
index 8951ffc..4d6c50c 100644
--- a/arch/arm/mach-aspeed/include/mach/platform.h
+++ b/arch/arm/mach-aspeed/include/mach/platform.h
@@ -62,5 +62,20 @@
  * Watchdog
  */
 #define AST_WDT_VA_BASE		(IO_ADDRESS(AST_WDT_BASE))
- 
+
+/*
+ * Console UART
+ */
+#ifdef CONFIG_WEDGE
+#define AST_UART_BASE AST_UART3_BASE
+#elif defined(CONFIG_WEDGE100)
+#define AST_UART_BASE AST_UART3_BASE
+#elif defined(CONFIG_YOSEMITE)
+#define AST_UART_BASE AST_UART0_BASE
+#elif defined(CONFIG_FBPLATFORM1)
+#define AST_UART_BASE AST_UART0_BASE
+#else
+#define AST_UART_BASE AST_UART0_BASE
+#endif
+
 #endif
diff --git a/arch/arm/mach-aspeed/include/mach/uncompress.h b/arch/arm/mach-aspeed/include/mach/uncompress.h
index 80e560d..3be04b0 100644
--- a/arch/arm/mach-aspeed/include/mach/uncompress.h
+++ b/arch/arm/mach-aspeed/include/mach/uncompress.h
@@ -12,8 +12,8 @@
 #include <mach/platform.h>
 #include <mach/aspeed_serial.h>
 
-#define UART_PUT_CHAR   (*(volatile unsigned char *)(AST_UART3_BASE + UART_THR))
-#define UART_GET_LSR   (*(volatile unsigned char *)(AST_UART3_BASE + UART_LSR))
+#define UART_PUT_CHAR   (*(volatile unsigned char *)(AST_UART_BASE + UART_THR))
+#define UART_GET_LSR   (*(volatile unsigned char *)(AST_UART_BASE + UART_LSR))
 
 static void putc(int c)
 {
@@ -21,7 +21,7 @@ static void putc(int c)
 	/* wait for space in the UART's transmitter */
 	while (!(UART_GET_LSR & UART_LSR_THRE))
 		barrier();
-	
+
 	/* send the character out. */
 	UART_PUT_CHAR = c;
 }
diff --git a/arch/arm/mach-aspeed/include/mach/vmalloc.h b/arch/arm/mach-aspeed/include/mach/vmalloc.h
index 51912ae..bc1b471 100644
--- a/arch/arm/mach-aspeed/include/mach/vmalloc.h
+++ b/arch/arm/mach-aspeed/include/mach/vmalloc.h
@@ -25,5 +25,5 @@
 #define VMALLOC_VMADDR(x) ((unsigned long)(x))
 #define VMALLOC_END       (PAGE_OFFSET + 0x20000000)
 #else
-#define VMALLOC_END                     0xf8000000UL
-#endif
\ No newline at end of file
+#define VMALLOC_END       0xf8000000UL
+#endif
diff --git a/arch/arm/plat-aspeed/ast-scu.c b/arch/arm/plat-aspeed/ast-scu.c
index 76722f4..101b141 100644
--- a/arch/arm/plat-aspeed/ast-scu.c
+++ b/arch/arm/plat-aspeed/ast-scu.c
@@ -1,20 +1,20 @@
 /********************************************************************************
-* File Name     : arch/arm/plat-aspeed/ast-scu.c 
+* File Name     : arch/arm/plat-aspeed/ast-scu.c
 * Author         : Ryan Chen
-* Description   : AST SCU 
-* 
+* Description   : AST SCU
+*
 * Copyright (C) 2012-2020  ASPEED Technology Inc.
-* This program is free software; you can redistribute it and/or modify 
-* it under the terms of the GNU General Public License as published by the Free Software Foundation; 
-* either version 2 of the License, or (at your option) any later version. 
-* This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY; 
-* without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. 
-* You should have received a copy of the GNU General Public License 
-* along with this program; if not, write to the Free Software 
-* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
-
-CLK24M 
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by the Free Software Foundation;
+* either version 2 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+CLK24M
  |
  |--> H-PLL -->HCLK
  |
@@ -27,9 +27,9 @@ CLK24M
  |--> USB2PHY -->UTMICLK
 
 
-*   History      : 
+*   History      :
 *    1. 2012/08/15 Ryan Chen Create
-* 
+*
 ********************************************************************************/
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -56,34 +56,34 @@ CLK24M
 
 static u32 ast_scu_base = IO_ADDRESS(AST_SCU_BASE);
 
-static inline u32 
+static inline u32
 ast_scu_read(u32 reg)
 {
 	u32 val;
-		
+
 	val = readl(ast_scu_base + reg);
-	
+
 	SCUDBUG("ast_scu_read : reg = 0x%08x, val = 0x%08x\n", reg, val);
-	
+
 	return val;
 }
 
 static inline void
-ast_scu_write(u32 val, u32 reg) 
+ast_scu_write(u32 val, u32 reg)
 {
 	SCUDBUG("ast_scu_write : reg = 0x%08x, val = 0x%08x\n", reg, val);
 #ifdef CONFIG_AST_SCU_LOCK
-	//unlock 
+	//unlock
 	writel(SCU_PROTECT_UNLOCK, ast_scu_base);
 	writel(val, ast_scu_base + reg);
 	//lock
-	writel(0xaa,ast_scu_base);	
+	writel(0xaa,ast_scu_base);
 #else
 	writel(val, ast_scu_base + reg);
 #endif
 }
 
-//SoC mapping Table 
+//SoC mapping Table
 struct soc_id {
 	const char	* name;
 	u32	rev_id;
@@ -180,9 +180,9 @@ ast_scu_init_video(u8 dynamic_en)
 		ast_scu_write((ast_scu_read(AST_SCU_CLK_SEL) & ~SCU_CLK_VIDEO_SLOW_MASK) | SCU_CLK_VIDEO_SLOW_EN | SCU_CLK_VIDEO_SLOW_SET(0), AST_SCU_CLK_SEL);
 	else
 		ast_scu_write((ast_scu_read(AST_SCU_CLK_SEL) & ~SCU_ECLK_SOURCE_MASK) | SCU_ECLK_SOURCE(2), AST_SCU_CLK_SEL);
-	
+
 	// Enable CLK
-	ast_scu_write(ast_scu_read(AST_SCU_CLK_STOP) & ~(SCU_ECLK_STOP_EN | SCU_VCLK_STOP_EN), AST_SCU_CLK_STOP);	
+	ast_scu_write(ast_scu_read(AST_SCU_CLK_STOP) & ~(SCU_ECLK_STOP_EN | SCU_VCLK_STOP_EN), AST_SCU_CLK_STOP);
 	mdelay(10);
 	ast_scu_write(ast_scu_read(AST_SCU_RESET) | SCU_RESET_VIDEO, AST_SCU_RESET);
 	udelay(100);
@@ -201,32 +201,32 @@ ast_scu_init_eth(u8 num)
 		ast_scu_write((ast_scu_read(AST_SCU_CLK_SEL) & ~SCU_CLK_MAC_MASK) | SCU_CLK_MAC_DIV(4), AST_SCU_CLK_SEL);
 
 	//Set MAC delay Timing
-	ast_scu_write(0x2255, AST_SCU_MAC_CLK);	
+	ast_scu_write(0x2255, AST_SCU_MAC_CLK);
 
 	switch(num) {
 		case 0:
-			ast_scu_write(ast_scu_read(AST_SCU_RESET) | SCU_RESET_MAC0, 
-							AST_SCU_RESET);		
+			ast_scu_write(ast_scu_read(AST_SCU_RESET) | SCU_RESET_MAC0,
+							AST_SCU_RESET);
 			udelay(100);
-			ast_scu_write(ast_scu_read(AST_SCU_CLK_STOP) & ~SCU_MAC0CLK_STOP_EN, 
-							AST_SCU_CLK_STOP);		
+			ast_scu_write(ast_scu_read(AST_SCU_CLK_STOP) & ~SCU_MAC0CLK_STOP_EN,
+							AST_SCU_CLK_STOP);
 			udelay(1000);
-			ast_scu_write(ast_scu_read(AST_SCU_RESET) & ~SCU_RESET_MAC0, 
-							AST_SCU_RESET);		
-			
+			ast_scu_write(ast_scu_read(AST_SCU_RESET) & ~SCU_RESET_MAC0,
+							AST_SCU_RESET);
+
 			break;
 		case 1:
-			ast_scu_write(ast_scu_read(AST_SCU_RESET) | SCU_RESET_MAC1, 
-							AST_SCU_RESET);			
+			ast_scu_write(ast_scu_read(AST_SCU_RESET) | SCU_RESET_MAC1,
+							AST_SCU_RESET);
 			udelay(100);
-			ast_scu_write(ast_scu_read(AST_SCU_CLK_STOP) & ~SCU_MAC1CLK_STOP_EN, 
-							AST_SCU_CLK_STOP);		
+			ast_scu_write(ast_scu_read(AST_SCU_CLK_STOP) & ~SCU_MAC1CLK_STOP_EN,
+							AST_SCU_CLK_STOP);
 			udelay(1000);
-			ast_scu_write(ast_scu_read(AST_SCU_RESET) & ~SCU_RESET_MAC1, 
-							AST_SCU_RESET);			
+			ast_scu_write(ast_scu_read(AST_SCU_RESET) & ~SCU_RESET_MAC1,
+							AST_SCU_RESET);
 			break;
-			
-	}		
+
+	}
 }
 
 
@@ -292,7 +292,7 @@ ast_scu_init_sdhci(void)
 {
 	//SDHCI Host's Clock Enable and Reset
 	ast_scu_write(ast_scu_read(AST_SCU_RESET) | SCU_RESET_SD, AST_SCU_RESET);
-	
+
 	ast_scu_write(ast_scu_read(AST_SCU_CLK_STOP) & ~SCU_SDCLK_STOP_EN, AST_SCU_CLK_STOP);
 	mdelay(10);
 
@@ -300,10 +300,10 @@ ast_scu_init_sdhci(void)
 	mdelay(10);
 
 	// SDCLK = H-PLL / 4
-	ast_scu_write((ast_scu_read(AST_SCU_CLK_SEL) & ~SCU_CLK_SD_MASK) | SCU_CLK_SD_DIV(1), 
+	ast_scu_write((ast_scu_read(AST_SCU_CLK_SEL) & ~SCU_CLK_SD_MASK) | SCU_CLK_SD_DIV(1),
 		AST_SCU_CLK_SEL);
 	mdelay(10);
-	
+
 	ast_scu_write(ast_scu_read(AST_SCU_RESET) & ~SCU_RESET_SD, AST_SCU_RESET);
 }
 
@@ -358,13 +358,13 @@ EXPORT_SYMBOL(ast_scu_init_jtag);
 extern void
 ast_scu_init_lpc(void)
 {
-	//Note .. It have been enable in U-boot..... 
+	//Note .. It have been enable in U-boot.....
 //	ast_scu_write(ast_scu_read(AST_SCU_RESET) | SCU_RESET_LPC, AST_SCU_RESET);
 
 	//enable LPC clock LHCLK = H-PLL/8
-	ast_scu_write(ast_scu_read(AST_SCU_CLK_STOP) | 
-					SCU_SET_LHCLK_DIV(3) | 
-					SCU_LHCLK_SOURCE_EN, 
+	ast_scu_write(ast_scu_read(AST_SCU_CLK_STOP) |
+					SCU_SET_LHCLK_DIV(3) |
+					SCU_LHCLK_SOURCE_EN,
 					AST_SCU_CLK_STOP);
 
 }
@@ -377,7 +377,7 @@ ast_scu_get_lpc_plus_enable(void)
 {
 	if(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) & SCU_FUN_PIN_LPC_PLUS)
 		return 1;
-	else 
+	else
 		return 0;
 }
 
@@ -390,10 +390,10 @@ ast_scu_init_crt(void)
 #if defined(CONFIG_AST_DAC) || defined(CONFIG_AST_DVO)
 	ast_scu_write((ast_scu_read(AST_SCU_MISC1_CTRL) & ~(SCU_MISC_D2_PLL_DIS | SCU_MISC_DAC_MASK))
 				| SCU_MISC_DAC_SOURCE_CRT | SCU_MISC_DVO_SOURCE_CRT | SCU_MISC_2D_CRT_EN , AST_SCU_MISC1_CTRL);
-#elif defined(CONFIG_AST_DVO) 
+#elif defined(CONFIG_AST_DVO)
 	ast_scu_write((ast_scu_read(AST_SCU_MISC1_CTRL) & ~(SCU_MISC_D2_PLL_DIS)) |
 				SCU_MISC_DVO_SOURCE_CRT| SCU_MISC_2D_CRT_EN, AST_SCU_MISC1_CTRL);
-#else //default(CONFIG_AST_DAC) 
+#else //default(CONFIG_AST_DAC)
 	ast_scu_write((ast_scu_read(AST_SCU_MISC1_CTRL) & ~(SCU_MISC_D2_PLL_DIS | SCU_MISC_DAC_MASK))
 				| SCU_MISC_DAC_SOURCE_CRT | SCU_MISC_2D_CRT_EN, AST_SCU_MISC1_CTRL);
 #endif
@@ -401,7 +401,7 @@ ast_scu_init_crt(void)
 	ast_scu_write((ast_scu_read(AST_SCU_CLK_SEL) & ~SCU_CLK_VIDEO_DELAY_MASK) |
 						SCU_CLK_VIDEO_DELAY(5), AST_SCU_CLK_SEL);
 
-	/* Reset CRT */ 
+	/* Reset CRT */
 	ast_scu_write(ast_scu_read(AST_SCU_RESET) | SCU_RESET_CRT, AST_SCU_RESET);
 
 	//enable D2 CLK
@@ -409,7 +409,7 @@ ast_scu_init_crt(void)
 
 	udelay(10);
 	ast_scu_write(ast_scu_read(AST_SCU_RESET) & ~SCU_RESET_CRT, AST_SCU_RESET);
-	
+
 }
 
 EXPORT_SYMBOL(ast_scu_init_crt);
@@ -448,7 +448,7 @@ ast_get_h_pll_clk(void)
 
 	if(h_pll_set & SCU_H_PLL_OFF)
 		return 0;
-	
+
 	if(h_pll_set & SCU_H_PLL_PARAMETER) {
 		// Programming
 		clk = ast_get_clk_source();
@@ -470,21 +470,21 @@ ast_get_h_pll_clk(void)
 		speed = SCU_HW_STRAP_GET_H_PLL_CLK(ast_scu_read(AST_SCU_HW_STRAP1));
 		switch (speed) {
 			case 0:
-				clk = 384000000; 
+				clk = 384000000;
 				break;
 			case 1:
-				clk = 360000000; 
+				clk = 360000000;
 				break;
 			case 2:
-				clk = 336000000; 
+				clk = 336000000;
 				break;
 			case 3:
-				clk = 408000000; 
+				clk = 408000000;
 				break;
 			default:
-				BUG(); 
+				BUG();
 				break;
-		}		
+		}
 	}
 	SCUDBUG("h_pll = %d\n",clk);
 	return clk;
@@ -500,7 +500,7 @@ ast_get_m_pll_clk(void)
 
 	if(m_pll_set & SCU_M_PLL_OFF)
 		return 0;
-	
+
 	// Programming
 	clk = ast_get_clk_source();
 	if(m_pll_set & SCU_M_PLL_BYPASS_EN) {
@@ -542,10 +542,10 @@ ast_get_ahbclk(void)
 		case 3:
 			div = 4;
 		break;
-		
+
 	}
-	
-	SCUDBUG("HPLL=%d, Div=%d, AHB CLK=%d\n", hpll, div, hpll/div);	
+
+	SCUDBUG("HPLL=%d, Div=%d, AHB CLK=%d\n", hpll, div, hpll/div);
 	return (hpll/div);
 
 }
@@ -559,8 +559,8 @@ ast_get_pclk(void)
 	hpll = ast_get_h_pll_clk();
 	div = SCU_GET_PCLK_DIV(ast_scu_read(AST_SCU_CLK_SEL));
 	div = (div+1) << 1;
-	
-	SCUDBUG("HPLL=%d, Div=%d, PCLK=%d\n", hpll, div, hpll/div);	
+
+	SCUDBUG("HPLL=%d, Div=%d, PCLK=%d\n", hpll, div, hpll/div);
 	return (hpll/div);
 
 }
@@ -572,7 +572,7 @@ ast_get_lhclk(void)
 	unsigned int div, hpll;
 	u32 clk_sel = ast_scu_read(AST_SCU_CLK_SEL);
 //FPGA AST1070 is default 100/2 Mhz input
-//	return 50000000;	
+//	return 50000000;
 	hpll = ast_get_h_pll_clk();
 	if(SCU_LHCLK_SOURCE_EN & clk_sel) {
 		div = SCU_GET_LHCLK_DIV(clk_sel);
@@ -600,10 +600,10 @@ ast_get_lhclk(void)
 			break;
 			case 7:
 				div = 16;
-			break;			
+			break;
 		}
-		
-		SCUDBUG("HPLL=%d, Div=%d, LHCLK = %d\n", hpll, div, hpll/div);	
+
+		SCUDBUG("HPLL=%d, Div=%d, LHCLK = %d\n", hpll, div, hpll/div);
 		return (hpll/div);
 	} else {
 		SCUMSG("LPC CLK not enable \n");
@@ -704,7 +704,7 @@ ast_get_sd_clock_src(void)
 		sd_div = SCU_CLK_SD_GET_DIV(ast_scu_read(AST_SCU_CLK_SEL));
 		SCUDBUG("div %d, sdclk =%d \n",((sd_div + 1) * 2),clk/((sd_div + 1) * 2));
 		clk /= ((sd_div + 1) * 2);
-		
+
 #endif
 	return clk;
 }
@@ -717,7 +717,7 @@ ast_scu_show_system_info (void)
 	u32 h_pll, div;
 
 	h_pll = ast_get_h_pll_clk();
-	
+
 	div = SCU_HW_STRAP_GET_CPU_AHB_RATIO(ast_scu_read(AST_SCU_HW_STRAP1));
 	switch(div) {
 		case 0:
@@ -732,10 +732,10 @@ ast_scu_show_system_info (void)
 		case 3:
 			div = 4;
 		break;
-		
+
 	}
 
-	SCUMSG("CPU = %d MHz ,AHB = %d MHz (%d:1) \n", h_pll/1000000, h_pll/div/1000000,div); 
+	SCUMSG("CPU = %d MHz ,AHB = %d MHz (%d:1) \n", h_pll/1000000, h_pll/div/1000000,div);
 
 	return ;
 }
@@ -750,54 +750,68 @@ ast_scu_multi_func_uart(u8 uart)
 		case 1:
 			ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL2) |
 						SCU_FUN_PIN_UART1_RXD |
+#ifdef CONFIG_YOSEMITE
+						SCU_FUN_PIN_UART1_TXD,
+#else
 						SCU_FUN_PIN_UART1_TXD |
 						SCU_FUN_PIN_UART1_NRTS |
 						SCU_FUN_PIN_UART1_NDTR |
 						SCU_FUN_PIN_UART1_NRI |
 						SCU_FUN_PIN_UART1_NDSR |
 						SCU_FUN_PIN_UART1_NDCD |
-						SCU_FUN_PIN_UART1_NCTS, 
-				AST_SCU_FUN_PIN_CTRL2); 
-			break;		
+						SCU_FUN_PIN_UART1_NCTS,
+#endif
+				AST_SCU_FUN_PIN_CTRL2);
+			break;
 		case 2:
 			ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL2) |
 						SCU_FUN_PIN_UART2_RXD |
+#ifdef CONFIG_YOSEMITE
+						SCU_FUN_PIN_UART2_TXD,
+#else
 						SCU_FUN_PIN_UART2_TXD |
 						SCU_FUN_PIN_UART2_NRTS |
 						SCU_FUN_PIN_UART2_NDTR |
 						SCU_FUN_PIN_UART2_NRI |
 						SCU_FUN_PIN_UART2_NDSR |
 						SCU_FUN_PIN_UART2_NDCD |
-						SCU_FUN_PIN_UART2_NCTS, 
-				AST_SCU_FUN_PIN_CTRL2); 
-			break;		
+						SCU_FUN_PIN_UART2_NCTS,
+#endif
+				AST_SCU_FUN_PIN_CTRL2);
+			break;
 		case 3:
 			ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL1) |
 						SCU_FUN_PIN_UART3_RXD |
+#ifdef CONFIG_YOSEMITE
+						SCU_FUN_PIN_UART3_TXD,
+#else
 						SCU_FUN_PIN_UART3_TXD |
 						SCU_FUN_PIN_UART3_NRTS |
 						SCU_FUN_PIN_UART3_NDTR |
 						SCU_FUN_PIN_UART3_NRI |
 						SCU_FUN_PIN_UART3_NDSR |
 						SCU_FUN_PIN_UART3_NDCD |
-						SCU_FUN_PIN_UART3_NCTS, 
-				AST_SCU_FUN_PIN_CTRL1); 
+						SCU_FUN_PIN_UART3_NCTS,
+#endif
+				AST_SCU_FUN_PIN_CTRL1);
 			break;
 		case 4:
 			ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL1) |
 						SCU_FUN_PIN_UART4_RXD |
+#ifdef CONFIG_YOSEMITE
+						SCU_FUN_PIN_UART4_TXD,
+#else
 						SCU_FUN_PIN_UART4_TXD |
 						SCU_FUN_PIN_UART4_NRTS |
 						SCU_FUN_PIN_UART4_NDTR |
 						SCU_FUN_PIN_UART4_NRI |
 						SCU_FUN_PIN_UART4_NDSR |
 						SCU_FUN_PIN_UART4_NDCD |
-						SCU_FUN_PIN_UART4_NCTS, 
-				AST_SCU_FUN_PIN_CTRL1); 			
+						SCU_FUN_PIN_UART4_NCTS,
+#endif
+				AST_SCU_FUN_PIN_CTRL1);
 			break;
 	}
-
-
 }
 
 extern void
@@ -806,13 +820,13 @@ ast_scu_multi_func_video()
 #if defined(CONFIG_ARCH_2100) || defined(CONFIG_ARCH_2200)
 	ast_scu_write(ast_scu_read(AST_SCU_MULTI_FUNC_2) |
 				MULTI_FUNC_VIDEO_RGB18 |
-				MULTI_FUNC_VIDEO_SINGLE_EDGE, 
-		AST_SCU_MULTI_FUNC_2); 
+				MULTI_FUNC_VIDEO_SINGLE_EDGE,
+		AST_SCU_MULTI_FUNC_2);
 #elif defined(CONFIG_ARCH_1100) || defined(CONFIG_ARCH_2050)
 	ast_scu_write(ast_scu_read(AST_SCU_MULTI_FUNC_2) |
 				MULTI_FUNC_VIDEO_RGB18 |
-				MULTI_FUNC_VIDEO_SINGLE_EDGE, 
-		AST_SCU_MULTI_FUNC_2); 
+				MULTI_FUNC_VIDEO_SINGLE_EDGE,
+		AST_SCU_MULTI_FUNC_2);
 #else
 
 #endif
@@ -823,40 +837,40 @@ ast_scu_multi_func_eth(u8 num)
 {
 	switch(num) {
 		case 0:
-			if(ast_scu_read(AST_SCU_HW_STRAP1) && SCU_HW_STRAP_MAC0_RGMII) {
+			if(ast_scu_read(AST_SCU_HW_STRAP1) & SCU_HW_STRAP_MAC0_RGMII) {
 				SCUMSG("MAC0 : RGMII \n");
-				ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL1) | 
-							SCU_FUN_PIN_MAC0_PHY_LINK, 
-					AST_SCU_FUN_PIN_CTRL1); 
+				ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL1) |
+							SCU_FUN_PIN_MAC0_PHY_LINK,
+					AST_SCU_FUN_PIN_CTRL1);
 			} else {
-				SCUMSG("MAC0 : RMII/NCSI \n");			
+				SCUMSG("MAC0 : RMII/NCSI \n");
 				ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL1) &
-							~SCU_FUN_PIN_MAC0_PHY_LINK, 
-					AST_SCU_FUN_PIN_CTRL1); 
+							~SCU_FUN_PIN_MAC0_PHY_LINK,
+					AST_SCU_FUN_PIN_CTRL1);
 			}
 
-			ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL3) | 
+			ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL3) |
 						SCU_FUN_PIN_MAC0_MDIO |
-						SCU_FUN_PIN_MAC0_MDC, 
-				AST_SCU_FUN_PIN_CTRL3); 
-			
+						SCU_FUN_PIN_MAC0_MDC,
+				AST_SCU_FUN_PIN_CTRL3);
+
 			break;
 		case 1:
-			if(ast_scu_read(AST_SCU_HW_STRAP1) && SCU_HW_STRAP_MAC1_RGMII) {
+			if(ast_scu_read(AST_SCU_HW_STRAP1) & SCU_HW_STRAP_MAC1_RGMII) {
 				SCUMSG("MAC1 : RGMII \n");
-				ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL1) | 
-							SCU_FUN_PIN_MAC1_PHY_LINK, 
-					AST_SCU_FUN_PIN_CTRL1); 
+				ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL1) |
+							SCU_FUN_PIN_MAC1_PHY_LINK,
+					AST_SCU_FUN_PIN_CTRL1);
 			} else {
 				SCUMSG("MAC1 : RMII/NCSI \n");
-				ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL1) & 
-						~SCU_FUN_PIN_MAC1_PHY_LINK, 
-					AST_SCU_FUN_PIN_CTRL1); 
+				ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL1) &
+						~SCU_FUN_PIN_MAC1_PHY_LINK,
+					AST_SCU_FUN_PIN_CTRL1);
 			}
-			
-			ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | 
+
+			ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) |
 						SCU_FUC_PIN_MAC1_MDIO,
-				AST_SCU_FUN_PIN_CTRL5); 
+				AST_SCU_FUN_PIN_CTRL5);
 
 			break;
 	}
@@ -866,18 +880,18 @@ extern void
 ast_scu_multi_func_nand(void)
 {
 	//enable NAND flash multipin FLBUSY and FLWP
-	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL2) | 
-				SCU_FUN_PIN_NAND_FLBUSY | SCU_FUN_PIN_NAND_FLWP, 
-		AST_SCU_FUN_PIN_CTRL2); 
+	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL2) |
+				SCU_FUN_PIN_NAND_FLBUSY | SCU_FUN_PIN_NAND_FLWP,
+		AST_SCU_FUN_PIN_CTRL2);
 
 }
 
 extern void
 ast_scu_multi_func_nor(void)
 {
-	//Address 
+	//Address
 	//ROMA2~17
-	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL8) | 
+	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL8) |
 				SCU_FUN_PIN_ROMA2 | SCU_FUN_PIN_ROMA3 |
 				SCU_FUN_PIN_ROMA4 | SCU_FUN_PIN_ROMA5 |
 				SCU_FUN_PIN_ROMA6 | SCU_FUN_PIN_ROMA7 |
@@ -885,39 +899,39 @@ ast_scu_multi_func_nor(void)
 				SCU_FUN_PIN_ROMA10 | SCU_FUN_PIN_ROMA11 |
 				SCU_FUN_PIN_ROMA12 | SCU_FUN_PIN_ROMA13 |
 				SCU_FUN_PIN_ROMA14 | SCU_FUN_PIN_ROMA15 |
-				SCU_FUN_PIN_ROMA16 | SCU_FUN_PIN_ROMA17, 
+				SCU_FUN_PIN_ROMA16 | SCU_FUN_PIN_ROMA17,
 		AST_SCU_FUN_PIN_CTRL8);
 
 	//ROMA18~21
-	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL9) | 
+	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL9) |
 				SCU_FUN_PIN_ROMA18 | SCU_FUN_PIN_ROMA19 |
-				SCU_FUN_PIN_ROMA20 | SCU_FUN_PIN_ROMA21, 
-		AST_SCU_FUN_PIN_CTRL9);	
-	
+				SCU_FUN_PIN_ROMA20 | SCU_FUN_PIN_ROMA21,
+		AST_SCU_FUN_PIN_CTRL9);
+
 	//ROMA22,23
-	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL4) | SCU_FUN_PIN_ROMA22 | SCU_FUN_PIN_ROMA23, 
+	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL4) | SCU_FUN_PIN_ROMA22 | SCU_FUN_PIN_ROMA23,
 		AST_SCU_FUN_PIN_CTRL4);
-	
+
 	//ROMA24,25
-	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL3) | SCU_FUN_PIN_ROMA24 | SCU_FUN_PIN_ROMA25, 
+	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL3) | SCU_FUN_PIN_ROMA24 | SCU_FUN_PIN_ROMA25,
 		AST_SCU_FUN_PIN_CTRL3);
 
 	//SCU94 [1] = 0
- 	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL6) & SCU_VIDEO_OUT_MASK, 
+ 	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL6) & SCU_VIDEO_OUT_MASK,
 		AST_SCU_FUN_PIN_CTRL6);
 
-	
+
 	//data
 	//ROMD 4~7 //ROMWE#, OE#
-	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL4) | 
+	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL4) |
 			SCU_FUN_PIN_ROMOE | SCU_FUN_PIN_ROMWE |
 			SCU_FUN_PIN_ROMD4 | SCU_FUN_PIN_ROMD5 |
 			SCU_FUN_PIN_ROMD6 | SCU_FUN_PIN_ROMD7,
 			AST_SCU_FUN_PIN_CTRL4);
-	
+
 	//ROMD 8~15
-	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | 
-			SCU_FUC_PIN_ROM_16BIT, 
+	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) |
+			SCU_FUC_PIN_ROM_16BIT,
 		AST_SCU_FUN_PIN_CTRL5);
 
 }
@@ -925,44 +939,44 @@ ast_scu_multi_func_nor(void)
 extern void
 ast_scu_multi_func_romcs(u8 num)
 {
-	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL3) | 
-			SCU_FUN_PIN_ROMCS(num), 
+	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL3) |
+			SCU_FUN_PIN_ROMCS(num),
 		AST_SCU_FUN_PIN_CTRL3);
 }
 
 extern void
 ast_scu_multi_func_i2c(void)
 {
-	//TODO check ... //In AST2400 Due to share pin with SD , please not enable I2C 10 ~14 
+	//TODO check ... //In AST2400 Due to share pin with SD , please not enable I2C 10 ~14
 	// AST 2400 have 14 , AST 2300 9 ...
 #ifdef CONFIG_MMC_AST
-	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | 
-			SCU_FUC_PIN_I2C3 | 
-			SCU_FUC_PIN_I2C4 | 
-			SCU_FUC_PIN_I2C5 | 
-			SCU_FUC_PIN_I2C6 | 
-			SCU_FUC_PIN_I2C7 | 
-			SCU_FUC_PIN_I2C8 | 
-			SCU_FUC_PIN_I2C9, 
+	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) |
+			SCU_FUC_PIN_I2C3 |
+			SCU_FUC_PIN_I2C4 |
+			SCU_FUC_PIN_I2C5 |
+			SCU_FUC_PIN_I2C6 |
+			SCU_FUC_PIN_I2C7 |
+			SCU_FUC_PIN_I2C8 |
+			SCU_FUC_PIN_I2C9,
 		AST_SCU_FUN_PIN_CTRL5);
 #else
-	ast_scu_write((ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | 
-			SCU_FUC_PIN_I2C3 | 
-			SCU_FUC_PIN_I2C4 | 
-			SCU_FUC_PIN_I2C5 | 
-			SCU_FUC_PIN_I2C6 | 
-			SCU_FUC_PIN_I2C7 | 
-			SCU_FUC_PIN_I2C8 | 
-			SCU_FUC_PIN_I2C9 | 
-			SCU_FUC_PIN_I2C10 | 
-			SCU_FUC_PIN_I2C11 | 
-			SCU_FUC_PIN_I2C12 | 
-			SCU_FUC_PIN_I2C13 | 
+	ast_scu_write((ast_scu_read(AST_SCU_FUN_PIN_CTRL5) |
+			SCU_FUC_PIN_I2C3 |
+			SCU_FUC_PIN_I2C4 |
+			SCU_FUC_PIN_I2C5 |
+			SCU_FUC_PIN_I2C6 |
+			SCU_FUC_PIN_I2C7 |
+			SCU_FUC_PIN_I2C8 |
+			SCU_FUC_PIN_I2C9 |
+			SCU_FUC_PIN_I2C10 |
+			SCU_FUC_PIN_I2C11 |
+			SCU_FUC_PIN_I2C12 |
+			SCU_FUC_PIN_I2C13 |
 			SCU_FUC_PIN_I2C14) &
-			~(SCU_FUC_PIN_SD1 | SCU_FUC_PIN_SD2), 
+			~(SCU_FUC_PIN_SD1 | SCU_FUC_PIN_SD2),
 		AST_SCU_FUN_PIN_CTRL5);
 #endif
-}	
+}
 
 EXPORT_SYMBOL(ast_scu_multi_func_i2c);
 
@@ -972,7 +986,7 @@ ast_scu_multi_func_pwm_tacho(void)
 	//TODO check
 	u32 sts = ast_scu_read(AST_SCU_FUN_PIN_CTRL3) &~0xcfffff;
 	ast_scu_write(sts | 0xc000ff, AST_SCU_FUN_PIN_CTRL3);
-}	
+}
 
 EXPORT_SYMBOL(ast_scu_multi_func_pwm_tacho);
 
@@ -981,12 +995,12 @@ extern void
 ast_scu_multi_func_usb20_host_hub(u8 mode)
 {
 	if(mode)
-		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | SCU_FUC_PIN_USB20_HOST, 
+		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | SCU_FUC_PIN_USB20_HOST,
 					AST_SCU_FUN_PIN_CTRL5);
 	else
-		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) & ~SCU_FUC_PIN_USB20_HOST, 
+		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) & ~SCU_FUC_PIN_USB20_HOST,
 					AST_SCU_FUN_PIN_CTRL5);
-}	
+}
 
 EXPORT_SYMBOL(ast_scu_multi_func_usb20_host_hub);
 
@@ -995,12 +1009,12 @@ extern void
 ast_scu_multi_func_usb11_host_port4(u8 mode)
 {
 	if(mode)
-		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | SCU_FUC_PIN_USB11_PORT4, 
+		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | SCU_FUC_PIN_USB11_PORT4,
 					AST_SCU_FUN_PIN_CTRL5);
 	else
-		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) & ~SCU_FUC_PIN_USB11_PORT4, 
+		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) & ~SCU_FUC_PIN_USB11_PORT4,
 					AST_SCU_FUN_PIN_CTRL5);
-}	
+}
 
 EXPORT_SYMBOL(ast_scu_multi_func_usb11_host_port4);
 
@@ -1009,26 +1023,26 @@ extern void
 ast_scu_multi_func_usb11_host_port2(u8 mode)
 {
 	if(mode)
-		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | SCU_FUC_PIN_USB11_PORT2, 
+		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | SCU_FUC_PIN_USB11_PORT2,
 					AST_SCU_FUN_PIN_CTRL5);
 	else
-		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) & ~SCU_FUC_PIN_USB11_PORT2, 
+		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) & ~SCU_FUC_PIN_USB11_PORT2,
 					AST_SCU_FUN_PIN_CTRL5);
-}	
+}
 
 EXPORT_SYMBOL(ast_scu_multi_func_usb11_host_port2);
 
-//0 : 1: SD1 function 
+//0 : 1: SD1 function
 extern void
 ast_scu_multi_func_sdhc_slot1(u8 mode)
 {
 	if(mode)
-		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | SCU_FUC_PIN_SD1, 
+		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | SCU_FUC_PIN_SD1,
 					AST_SCU_FUN_PIN_CTRL5);
 	else
-		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) & ~SCU_FUC_PIN_SD1, 
+		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) & ~SCU_FUC_PIN_SD1,
 					AST_SCU_FUN_PIN_CTRL5);
-}	
+}
 
 EXPORT_SYMBOL(ast_scu_multi_func_sdhc_slot1);
 
@@ -1036,13 +1050,13 @@ extern void
 ast_scu_multi_func_sdhc_slot2(u8 mode)
 {
 	if(mode)
-		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | SCU_FUC_PIN_SD2, 
+		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) | SCU_FUC_PIN_SD2,
 					AST_SCU_FUN_PIN_CTRL5);
 	else
-		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) & ~SCU_FUC_PIN_SD2, 
+		ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL5) & ~SCU_FUC_PIN_SD2,
 					AST_SCU_FUN_PIN_CTRL5);
 
-}	
+}
 
 EXPORT_SYMBOL(ast_scu_multi_func_sdhc_slot2);
 
@@ -1053,11 +1067,11 @@ ast_scu_multi_func_crt(void)
 
 	//Digital vodeo input function pins : 00 disable, 10 24bits mode 888,
 	ast_scu_write((ast_scu_read(AST_SCU_FUN_PIN_CTRL5) &
-			~SCU_FUC_PIN_DIGI_V_OUT_MASK) | 
+			~SCU_FUC_PIN_DIGI_V_OUT_MASK) |
 			SCU_FUC_PIN_DIGI_V_OUT(VIDEO_24BITS),AST_SCU_FUN_PIN_CTRL5);
 
 	//VPI input
-#if 0	
+#if 0
 	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL2) |
 			SCU_FUN_PIN_VPIB9 | SCU_FUN_PIN_VPIB8 |
 			SCU_FUN_PIN_VPIB7 | SCU_FUN_PIN_VPIB6 |
@@ -1070,11 +1084,11 @@ ast_scu_multi_func_crt(void)
 
 	ast_scu_write(ast_scu_read(AST_SCU_FUN_PIN_CTRL3) |
 			SCU_FUN_PIN_VPIR9 | SCU_FUN_PIN_VPIR8 |
-			SCU_FUN_PIN_VPIR7 | SCU_FUN_PIN_VPIR6 |	
+			SCU_FUN_PIN_VPIR7 | SCU_FUN_PIN_VPIR6 |
 			SCU_FUN_PIN_VPIR5 | SCU_FUN_PIN_VPIR4 |
 			SCU_FUN_PIN_VPIR3 | SCU_FUN_PIN_VPIR2 |
 			SCU_FUN_PIN_VPIR1 | SCU_FUN_PIN_VPIR0 |
-			SCU_FUN_PIN_VPIG9 | SCU_FUN_PIN_VPIG8 |	
+			SCU_FUN_PIN_VPIG9 | SCU_FUN_PIN_VPIG8 |
 			SCU_FUN_PIN_VPIG7 | SCU_FUN_PIN_VPIG6 |
 			SCU_FUN_PIN_VPIG5 | SCU_FUN_PIN_VPIG4 |
 			SCU_FUN_PIN_VPIG3 | SCU_FUN_PIN_VPIG2 |
@@ -1097,9 +1111,9 @@ ast_scu_revision_id(void)
 		SCUMSG("UnKnow-SOC : %x \n",rev_id);
 	else
 		SCUMSG("SOC : %4s \n",soc_map_table[i].name);
-	
+
 	return rev_id;
-}	
+}
 
 EXPORT_SYMBOL(ast_scu_revision_id);
 
diff --git a/arch/arm/plat-aspeed/dev-eth.c b/arch/arm/plat-aspeed/dev-eth.c
index 5d33e33..b115c5a 100644
--- a/arch/arm/plat-aspeed/dev-eth.c
+++ b/arch/arm/plat-aspeed/dev-eth.c
@@ -7,11 +7,11 @@
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by the Free Software Foundation;
 * either version 2 of the License, or (at your option) any later version.
-* 
+*
 * This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-* 
+*
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
@@ -37,7 +37,7 @@
 #if defined(CONFIG_ASPEEDMAC) || defined(CONFIG_ASPEEDMAC_MODULE)
 #ifdef AST_MAC0_BASE
 static struct ftgmac100_eth_data ast_eth0_data = {
-	.dev_addr = { 0x00, 0x84, 0x14, 0xA0, 0xB0, 0x22},		
+	.dev_addr = { 0x00, 0x84, 0x14, 0xA0, 0xB0, 0x22},
 	.phy_id = 1,
 };
 
@@ -69,7 +69,7 @@ static struct platform_device ast_eth0_device = {
 #endif
 #ifdef AST_MAC1_BASE
 static struct ftgmac100_eth_data ast_eth1_data = {
-	.dev_addr = { 0x00, 0x84, 0x14, 0xA0, 0xB0, 0x23},		
+	.dev_addr = { 0x00, 0x84, 0x14, 0xA0, 0xB0, 0x23},
 	.phy_id = 1,
 };
 
@@ -131,11 +131,16 @@ void __init ast_add_device_gmac(void)
 	}
 
 	ast_eth0_data.DF_support = !isRevA0;
-	
+
+	// Wedge/6-Pack hardware attaches to MAC1;  there's nothing on
+	// MAC0.  Older drivers would drop interfaces without PHYs, but
+	// the latest open source drivers do not, so we drop the first
+	// MAC specs.
+#if !defined(CONFIG_WEDGE) && !defined(CONFIG_WEDGE100)
 	ast_scu_init_eth(0);
 	ast_scu_multi_func_eth(0);
-	
-	
+
+
 	/*
 	* D[15:11] in 0x1E6E2040 is NCSI scratch from U-Boot. D[15:14] = MAC1, D[13:12] = MAC2
 	* The meanings of the 2 bits are:
@@ -144,7 +149,7 @@ void __init ast_add_device_gmac(void)
 	* 10(2): ASPEED's MAC is connected to NC-SI PHY chip directly
 	* 11: Reserved
 	*/
-	
+
 	phy_mode = ast_scu_get_phy_config(0);
 	switch(phy_mode) {
 		case 0:
@@ -152,12 +157,12 @@ void __init ast_add_device_gmac(void)
 			ast_eth0_data.NCSI_support = 0;
 			break;
 		case 1:
-			ast_eth0_data.NCSI_support = 1;
+			ast_eth0_data.INTEL_NCSI_EVA_support = 1;
 			break;
 		case 2:
-			ast_eth0_data.INTEL_NCSI_EVA_support = 1;
+			ast_eth0_data.NCSI_support = 1;
 			break;
-			
+
 	}
 
 	phy_inter = ast_scu_get_phy_interface(0);
@@ -165,12 +170,13 @@ void __init ast_add_device_gmac(void)
 	// We assume the Clock Stop register does not disable the MAC1 or MAC2 clock
 	// unless Reset Control also holds the MAC in reset.
 
-	
+
 	platform_device_register(&ast_eth0_device);
+#endif
 
 #ifdef AST_MAC1_BASE
 	ast_scu_init_eth(1);
-	ast_scu_multi_func_eth(1);	
+	ast_scu_multi_func_eth(1);
 
 	ast_eth1_data.DF_support = !isRevA0;
 
@@ -186,7 +192,7 @@ void __init ast_add_device_gmac(void)
 		case 2:
 			ast_eth1_data.INTEL_NCSI_EVA_support = 1;
 			break;
-			
+
 	}
 	phy_inter = ast_scu_get_phy_interface(1);
 
@@ -198,4 +204,3 @@ void __init ast_add_device_gmac(void)
 #else
 void __init ast_add_device_gmac(void) {}
 #endif
-
diff --git a/arch/arm/plat-aspeed/dev-i2c.c b/arch/arm/plat-aspeed/dev-i2c.c
index 9905390..fffa480 100644
--- a/arch/arm/plat-aspeed/dev-i2c.c
+++ b/arch/arm/plat-aspeed/dev-i2c.c
@@ -7,11 +7,11 @@
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by the Free Software Foundation;
 * either version 2 of the License, or (at your option) any later version.
-* 
+*
 * This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-* 
+*
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
@@ -47,59 +47,59 @@
 #if defined (CONFIG_ARCH_AST2400)
 #define I2C_PAGE_SIZE 8
 static spinlock_t page_info_lock = SPIN_LOCK_UNLOCKED;
-static struct buf_page page_info[I2C_PAGE_SIZE] = 
-{  
+static struct buf_page page_info[I2C_PAGE_SIZE] =
+{
 	[0] = {
 		.flag = 0,
 		.page_no = 0,
 		.page_size = 256,
-		.page_addr_point = 0,	
+		.page_addr_point = 0,
 	},
 	[1] = {
 		.flag = 0,
-		.page_no = 1,			
+		.page_no = 1,
 		.page_size = 256,
-		.page_addr_point = 0,		
+		.page_addr_point = 0,
 	},
 	[2] = {
 		.flag = 0,
-		.page_no = 2,			
+		.page_no = 2,
 		.page_size = 256,
 		.page_addr_point = 0,
 	},
 	[3] = {
 		.flag = 0,
-		.page_no = 3,			
+		.page_no = 3,
 		.page_size = 256,
 		.page_addr_point = 0,
 	},
 	[4] = {
 		.flag = 0,
-		.page_no = 4,			
+		.page_no = 4,
 		.page_size = 256,
 		.page_addr_point = 0,
 	},
 	[5] = {
 		.flag = 0,
-		.page_no = 5,			
+		.page_no = 5,
 		.page_size = 256,
 		.page_addr_point = 0,
 	},
 	[6] = {
 		.flag = 0,
-		.page_no = 6,			
+		.page_no = 6,
 		.page_size = 256,
 		.page_addr_point = 0,
 	},
 	[7] = {
 		.flag = 0,
-		.page_no = 7,			
+		.page_no = 7,
 		.page_size = 256,
 		.page_addr_point = 0,
 	},
 };
 
-static void pool_buff_page_init(u32 buf_pool_addr) 
+static void pool_buff_page_init(u32 buf_pool_addr)
 {
 	u32 offset;
 	int i ,j;
@@ -108,7 +108,7 @@ static void pool_buff_page_init(u32 buf_pool_addr)
 		offset = 0;
 		for(j=0;j<i;j++)
 			offset += page_info[i].page_size;
-		
+
 		page_info[i].page_addr = buf_pool_addr + offset;
 //		I2CDBUG( "page[%d],addr :%x \n", i, page_info[i].page_addr);
 	}
@@ -130,7 +130,7 @@ static u8 request_pool_buff_page(struct buf_page **req_page)
 			break;
 		}
 	}
-	spin_unlock_irqrestore(&page_info_lock, flags);	
+	spin_unlock_irqrestore(&page_info_lock, flags);
 	return (i >= I2C_PAGE_SIZE);
 }
 
@@ -140,17 +140,17 @@ static void free_pool_buff_page(struct buf_page *req_page)
         spin_lock_irqsave(&page_info_lock, flags);
 
 	req_page->flag = 0;
-//	I2CDBUG( "free page addr %x \n", req_page->page_addr);	
+//	I2CDBUG( "free page addr %x \n", req_page->page_addr);
 	req_page = NULL;
-	spin_unlock_irqrestore(&page_info_lock, flags);	
+	spin_unlock_irqrestore(&page_info_lock, flags);
 }
 
 #elif defined (CONFIG_ARCH_AST2300)
 #define I2C_PAGE_SIZE 5
 
 static spinlock_t page_info_lock = SPIN_LOCK_UNLOCKED;
-static struct buf_page page_info[I2C_PAGE_SIZE] = 
-{  
+static struct buf_page page_info[I2C_PAGE_SIZE] =
+{
 	[0] = {
 		.flag = 0,
 		.page_size = 128,
@@ -173,7 +173,7 @@ static struct buf_page page_info[I2C_PAGE_SIZE] =
 	},
 };
 
-static void pool_buff_page_init(u32 buf_pool_addr) 
+static void pool_buff_page_init(u32 buf_pool_addr)
 {
 
 	u32 offset;
@@ -183,7 +183,7 @@ static void pool_buff_page_init(u32 buf_pool_addr)
 		offset = 0;
 		for(j=0;j<i;j++)
 			offset += page_info[i].page_size;
-		
+
 		page_info[i].page_addr = buf_pool_addr + offset;
 		page_info[i].page_addr_point = page_info[i].page_addr/4;
 //		printk("page[%d],addr :%x , point : %d\n", i, page_info[i].page_addr, page_info[i].page_addr_point);
@@ -201,11 +201,11 @@ static u8 request_pool_buff_page(struct buf_page **req_page)
 		if(page_info[i].flag ==0) {
 			page_info[i].flag = 1;
 			*req_page = &page_info[i];
-			spin_unlock_irqrestore(&page_info_lock, flags);	
+			spin_unlock_irqrestore(&page_info_lock, flags);
 			return 0;
 		}
 	}
-	spin_unlock_irqrestore(&page_info_lock, flags);	
+	spin_unlock_irqrestore(&page_info_lock, flags);
 	return 1;
 
 }
@@ -217,10 +217,10 @@ static void free_pool_buff_page(struct buf_page *req_page)
         spin_lock_irqsave(&page_info_lock, flags);
 	req_page->flag = 0;
 	req_page = NULL;
-	spin_unlock_irqrestore(&page_info_lock, flags);	
+	spin_unlock_irqrestore(&page_info_lock, flags);
 }
 
-#else 
+#else
 //DO nothing
 static void pool_buff_page_init(void) {}
 static u8 request_pool_buff_page(struct buf_page **req_page) {return 0;}
@@ -228,15 +228,15 @@ static void free_pool_buff_page(struct buf_page *req_page) {}
 #endif
 
 static struct ast_i2c_driver_data ast_i2c_data = {
-	.bus_clk = 100000,		//bus clock 100KHz	
+	.bus_clk = 100000,		//bus clock 100KHz
 	.master_dma = BUFF_MODE,
 	.slave_dma = BYTE_MODE,
 	.request_pool_buff_page = request_pool_buff_page,
 	.free_pool_buff_page = free_pool_buff_page,
-#ifdef CONFIG_AST_I2C_SLAVE_MODE	
+#ifdef CONFIG_AST_I2C_SLAVE_MODE
 	.slave_xfer = i2c_slave_xfer,
 	.slave_init = i2c_slave_init,
-#endif	
+#endif
 	.get_i2c_clock = ast_get_pclk,
 };
 
@@ -285,7 +285,7 @@ struct platform_device ast_i2c_dev2_device = {
 	.dev = {
 		.dma_mask = &ast_i2c_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
-		.platform_data = &ast_i2c_data,		
+		.platform_data = &ast_i2c_data,
 	},
 	.resource = ast_i2c_dev2_resources,
 	.num_resources = ARRAY_SIZE(ast_i2c_dev2_resources),
@@ -310,7 +310,7 @@ struct platform_device ast_i2c_dev3_device = {
 	.dev = {
 		.dma_mask = &ast_i2c_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
-		.platform_data = &ast_i2c_data,		
+		.platform_data = &ast_i2c_data,
 	},
 	.resource = ast_i2c_dev3_resources,
 	.num_resources = ARRAY_SIZE(ast_i2c_dev3_resources),
@@ -335,7 +335,7 @@ struct platform_device ast_i2c_dev4_device = {
 	.dev = {
 		.dma_mask = &ast_i2c_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
-		.platform_data = &ast_i2c_data,		
+		.platform_data = &ast_i2c_data,
 	},
 	.resource = ast_i2c_dev4_resources,
 	.num_resources = ARRAY_SIZE(ast_i2c_dev4_resources),
@@ -360,7 +360,7 @@ struct platform_device ast_i2c_dev5_device = {
 	.dev = {
 		.dma_mask = &ast_i2c_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
-		.platform_data = &ast_i2c_data,		
+		.platform_data = &ast_i2c_data,
 	},
 	.resource = ast_i2c_dev5_resources,
 	.num_resources = ARRAY_SIZE(ast_i2c_dev5_resources),
@@ -385,7 +385,7 @@ struct platform_device ast_i2c_dev6_device = {
 	.dev = {
 		.dma_mask = &ast_i2c_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
-		.platform_data = &ast_i2c_data,		
+		.platform_data = &ast_i2c_data,
 	},
 	.resource = ast_i2c_dev6_resources,
 	.num_resources = ARRAY_SIZE(ast_i2c_dev6_resources),
@@ -410,7 +410,7 @@ struct platform_device ast_i2c_dev7_device = {
 	.dev = {
 		.dma_mask = &ast_i2c_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
-		.platform_data = &ast_i2c_data,		
+		.platform_data = &ast_i2c_data,
 	},
 	.resource = ast_i2c_dev7_resources,
 	.num_resources = ARRAY_SIZE(ast_i2c_dev7_resources),
@@ -435,7 +435,7 @@ struct platform_device ast_i2c_dev8_device = {
 	.dev = {
 		.dma_mask = &ast_i2c_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
-		.platform_data = &ast_i2c_data,		
+		.platform_data = &ast_i2c_data,
 	},
 	.resource = ast_i2c_dev8_resources,
 	.num_resources = ARRAY_SIZE(ast_i2c_dev8_resources),
@@ -460,7 +460,7 @@ struct platform_device ast_i2c_dev9_device = {
 	.dev = {
 		.dma_mask = &ast_i2c_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
-		.platform_data = &ast_i2c_data,		
+		.platform_data = &ast_i2c_data,
 	},
 	.resource = ast_i2c_dev9_resources,
 	.num_resources = ARRAY_SIZE(ast_i2c_dev9_resources),
@@ -486,7 +486,7 @@ struct platform_device ast_i2c_dev10_device = {
 	.dev = {
 		.dma_mask = &ast_i2c_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
-		.platform_data = &ast_i2c_data,		
+		.platform_data = &ast_i2c_data,
 	},
 	.resource = ast_i2c_dev10_resources,
 	.num_resources = ARRAY_SIZE(ast_i2c_dev10_resources),
@@ -511,7 +511,7 @@ struct platform_device ast_i2c_dev11_device = {
 	.dev = {
 		.dma_mask = &ast_i2c_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
-		.platform_data = &ast_i2c_data,		
+		.platform_data = &ast_i2c_data,
 	},
 	.resource = ast_i2c_dev11_resources,
 	.num_resources = ARRAY_SIZE(ast_i2c_dev11_resources),
@@ -536,7 +536,7 @@ struct platform_device ast_i2c_dev12_device = {
 	.dev = {
 		.dma_mask = &ast_i2c_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
-		.platform_data = &ast_i2c_data,		
+		.platform_data = &ast_i2c_data,
 	},
 	.resource = ast_i2c_dev12_resources,
 	.num_resources = ARRAY_SIZE(ast_i2c_dev12_resources),
@@ -561,7 +561,7 @@ struct platform_device ast_i2c_dev13_device = {
 	.dev = {
 		.dma_mask = &ast_i2c_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
-		.platform_data = &ast_i2c_data,		
+		.platform_data = &ast_i2c_data,
 	},
 	.resource = ast_i2c_dev13_resources,
 	.num_resources = ARRAY_SIZE(ast_i2c_dev13_resources),
@@ -586,7 +586,7 @@ struct platform_device ast_i2c_dev14_device = {
 	.dev = {
 		.dma_mask = &ast_i2c_dma_mask,
 		.coherent_dma_mask = 0xffffffff,
-		.platform_data = &ast_i2c_data,		
+		.platform_data = &ast_i2c_data,
 	},
 	.resource = ast_i2c_dev14_resources,
 	.num_resources = ARRAY_SIZE(ast_i2c_dev14_resources),
@@ -594,12 +594,196 @@ struct platform_device ast_i2c_dev14_device = {
 #endif
 
 /*--------- I2C Board devices ------------*/
-//ASPEED AST2300 EVB I2C Device 
+//ASPEED AST2300 EVB I2C Device
 #if defined(CONFIG_ARCH_AST2300) || defined(CONFIG_ARCH_AST2400)
+
+#if defined(CONFIG_WEDGE100)
+
+static struct i2c_board_info __initdata wedge100_i2c_bus1[] = {
+  /* shared NIC, no kernel driver */
+};
+
+static struct i2c_board_info __initdata wedge100_i2c_bus2[] = {
+  /* TODO: one IR3581 and two IR3584 */
+};
+
+static struct i2c_board_info __initdata wedge100_i2c_bus3[] = {
+  /* TODO: one PWR1014A */
+};
+
+static struct i2c_board_info __initdata wedge100_i2c_bus4[] = {
+  {
+    I2C_BOARD_INFO("tmp75", 0x48),
+  },
+  {
+    I2C_BOARD_INFO("tmp75", 0x49),
+  },
+  {
+    I2C_BOARD_INFO("tmp75", 0x4a),
+  },
+  {
+    I2C_BOARD_INFO("tmp75", 0x4b),
+  },
+  {
+    I2C_BOARD_INFO("tmp75", 0x4c),
+  },
+};
+
+static struct i2c_board_info __initdata wedge100_i2c_bus5[] = {
+  /* Panther+ microserver */
+  {
+    I2C_BOARD_INFO("fb_panther_plus", 0x40),
+  },
+};
+
+static struct i2c_board_info __initdata wedge100_i2c_bus6[] = {
+  /* TODO: USB hub */
+};
+
+static struct i2c_board_info __initdata wedge100_i2c_bus7[] = {
+  {
+    I2C_BOARD_INFO("pcf8574", 0x2f),
+  },
+  {
+    I2C_BOARD_INFO("24c64", 0x51),
+  }
+};
+
+static struct i2c_board_info __initdata wedge100_i2c_bus8[] = {
+  /* BMC PHY EEPROM */
+  {
+    I2C_BOARD_INFO("24c02", 0x50),
+  },
+  // EEPROM on the pfe1100 power supplies
+  {
+    I2C_BOARD_INFO("24c64", 0x51),
+  },
+  {
+    I2C_BOARD_INFO("24c64", 0x52),
+  },
+  /* PSU driver */
+  {
+    I2C_BOARD_INFO("pfe1100", 0x59),
+  },
+  {
+    I2C_BOARD_INFO("pfe1100", 0x5a),
+  },
+};
+
+static struct i2c_board_info __initdata wedge100_i2c_bus9[] = {
+  {
+    I2C_BOARD_INFO("fancpld", 0x33),
+  },
+  {
+    I2C_BOARD_INFO("tmp75", 0x48),
+  },
+  {
+    I2C_BOARD_INFO("tmp75", 0x49),
+  },
+};
+
+/* i2c bus 10-12 on wedge100 are not connected as i2c bus */
+
+static struct i2c_board_info __initdata wedge100_i2c_bus13[] = {
+  {
+    I2C_BOARD_INFO("syscpld", 0x31),
+  },
+};
+
+/* i2c bus 14 on wedge100 are not connected as i2c bus */
+
+/* end of defined(CONFIG_WEDGE100) */
+
+#elif defined(CONFIG_YOSEMITE) || defined(CONFIG_FBPLATFORM1)
+
+//Under I2C Dev 1
+static struct i2c_board_info __initdata ast_i2c_board_info_1[] = {
+  // Slot#0 NIC sideband
+};
+
+//Under I2C Dev 2
+static struct i2c_board_info __initdata ast_i2c_board_info_2[] = {
+  // Slot#0 IPMB interface
+};
+
+//Under I2C Dev 3
+static struct i2c_board_info __initdata ast_i2c_board_info_3[] = {
+  // Slot#1 NIC sideband
+};
+
+
+//Under I2C Dev 4
+static struct i2c_board_info __initdata ast_i2c_board_info_4[] = {
+  // Slot#1 IPMB interface
+};
+
+//Under I2C Dev 5
+static struct i2c_board_info __initdata ast_i2c_board_info_5[] = {
+  // Slot#2 NIC sideband
+};
+
+//Under I2C Dev 6
+static struct i2c_board_info __initdata ast_i2c_board_info_6[] = {
+  // Slot#2 IPMB interface
+};
+
+//Under I2C Dev 7
+static struct i2c_board_info __initdata ast_i2c_board_info_7[] = {
+  // Slot#3 NIC sideband
+};
+
+//Under I2C Dev 8
+static struct i2c_board_info __initdata ast_i2c_board_info_8[] = {
+  // Slot#3 IPMB interface
+};
+
+//Under I2C Dev 9
+static struct i2c_board_info __initdata ast_i2c_board_info_9[] = {
+  // FRUID
+  {
+    I2C_BOARD_INFO("24c64", 0x51),
+  },
+};
+
+//Under I2C Dev 10
+static struct i2c_board_info __initdata ast_i2c_board_info_10[] = {
+  // Inlet and Outlet temp. sensors
+  {
+    I2C_BOARD_INFO("tmp75", 0x4e),
+  },
+  {
+    I2C_BOARD_INFO("tmp75", 0x4f),
+  },
+};
+
+//Under I2C Dev 11
+static struct i2c_board_info __initdata ast_i2c_board_info_11[] = {
+  // Hotswap Sensor
+  {
+    I2C_BOARD_INFO("adm1278", 0x40),
+  },
+};
+
+//Under I2C Dev 12
+static struct i2c_board_info __initdata ast_i2c_board_info_12[] = {
+  // Mezz Card LAN_SMB bus (PHY, Temp. Sensor)
+};
+
+//Under I2C Dev 13
+static struct i2c_board_info __initdata ast_i2c_board_info_13[] = {
+  // Mezz Card Mezz_SMB bus (FRUID, GPIO expander, QSFP+)
+};
+
+/* end of CONFIG_YOSEMITE */
+
+#else
+
+/* wedge */
+
 //Under I2C Dev 1
 static struct i2c_board_info __initdata ast_i2c_board_info_1[] = {
 	{
-		I2C_BOARD_INFO("cat9883", 0x4d),						
+		I2C_BOARD_INFO("cat9883", 0x4d),
 	}
 };
 
@@ -612,15 +796,6 @@ static struct i2c_board_info __initdata ast_i2c_board_info_2[] = {
 	{
 		I2C_BOARD_INFO("ncp4200", 0x60),
 	},
-	{
-		I2C_BOARD_INFO("ncp4200", 0x61),
-	},
-	{
-		I2C_BOARD_INFO("ncp4200", 0x62),
-	},
-	{
-		I2C_BOARD_INFO("ncp4200", 0x63),
-	},
 };
 
 
@@ -632,15 +807,6 @@ static struct i2c_board_info __initdata ast_i2c_board_info_3[] = {
 	{
 		I2C_BOARD_INFO("ncp4200", 0x60),
 	},
-	{
-		I2C_BOARD_INFO("ncp4200", 0x61),
-	},
-	{
-		I2C_BOARD_INFO("ncp4200", 0x62),
-	},
-	{
-		I2C_BOARD_INFO("ncp4200", 0x63),
-	},
 };
 
 
@@ -675,7 +841,7 @@ static struct i2c_board_info __initdata ast_i2c_board_info_5[] = {
 		I2C_BOARD_INFO("24c128", 0x51),
 	},
 };
-		
+
 //Under I2C Dev 7
 static struct i2c_board_info __initdata ast_i2c_board_info_7[] = {
 	// Wedge devices
@@ -688,15 +854,23 @@ static struct i2c_board_info __initdata ast_i2c_board_info_7[] = {
 	},
 	{
 		I2C_BOARD_INFO("24c64", 0x50),
-	}
+	},
 };
 
 
 //Under I2C Dev 8
 static struct i2c_board_info __initdata ast_i2c_board_info_8[] = {
 	{
+		// 6pack power supply
+		I2C_BOARD_INFO("pfe3000", 0x10),
+	},
+	{
 		// Eval board:
-		I2C_BOARD_INFO("lm75b", 0x4a),						
+		I2C_BOARD_INFO("lm75b", 0x4a),
+	},
+	{
+		// 6pack power supply EEPROM
+		I2C_BOARD_INFO("24c64", 0x50),
 	},
 	// EEPROMS on the pfe1100 power supplies
 	{
@@ -722,20 +896,12 @@ static struct i2c_board_info __initdata ast_i2c_board_info_9[] = {
 	{
 		I2C_BOARD_INFO("ncp4200", 0x60),
 	},
-	{
-		I2C_BOARD_INFO("ncp4200", 0x61),
-	},
-	{
-		I2C_BOARD_INFO("ncp4200", 0x62),
-	},
-	{
-		I2C_BOARD_INFO("ncp4200", 0x63),
-	},
 };
 
 //Under I2C Dev 12
 static struct i2c_board_info __initdata ast_i2c_board_info_12[] = {
 	{
+		// Early version of 6pack
 		I2C_BOARD_INFO("pfe3000", 0x10),
 	},
 };
@@ -747,6 +913,10 @@ static struct i2c_board_info __initdata ast_i2c_board_info_13[] = {
 	},
 };
 
+/* end of WEDGE case */
+#endif
+
+/* end of defined(CONFIG_ARCH_AST2300) || defined(CONFIG_ARCH_AST2400) */
 #endif
 
 /*-------------------------------------*/
@@ -755,7 +925,7 @@ void __init ast_add_device_i2c(void)
 	//I2C Multi-Pin
 	ast_scu_multi_func_i2c();
 
-	//SCU I2C Reset 
+	//SCU I2C Reset
 	ast_scu_init_i2c();
 
 	ast_i2c_data.reg_gr = ioremap(AST_I2C_BASE, 4*SZ_16);
@@ -777,8 +947,48 @@ void __init ast_add_device_i2c(void)
 		return;
 	}
 #endif
-	//TODO
-	pool_buff_page_init(ast_i2c_data.buf_pool); 
+
+	pool_buff_page_init(ast_i2c_data.buf_pool);
+
+#if defined(CONFIG_WEDGE100)
+
+  platform_device_register(&ast_i2c_dev1_device);
+  i2c_register_board_info(0, wedge100_i2c_bus1, ARRAY_SIZE(wedge100_i2c_bus1));
+
+  platform_device_register(&ast_i2c_dev2_device);
+  i2c_register_board_info(1, wedge100_i2c_bus2, ARRAY_SIZE(wedge100_i2c_bus2));
+
+  platform_device_register(&ast_i2c_dev3_device);
+  i2c_register_board_info(2, wedge100_i2c_bus3, ARRAY_SIZE(wedge100_i2c_bus3));
+
+  platform_device_register(&ast_i2c_dev4_device);
+  i2c_register_board_info(3, wedge100_i2c_bus4, ARRAY_SIZE(wedge100_i2c_bus4));
+
+  platform_device_register(&ast_i2c_dev5_device);
+  i2c_register_board_info(4, wedge100_i2c_bus5, ARRAY_SIZE(wedge100_i2c_bus5));
+
+  platform_device_register(&ast_i2c_dev6_device);
+  i2c_register_board_info(5, wedge100_i2c_bus6, ARRAY_SIZE(wedge100_i2c_bus6));
+
+  platform_device_register(&ast_i2c_dev7_device);
+  i2c_register_board_info(6, wedge100_i2c_bus7, ARRAY_SIZE(wedge100_i2c_bus7));
+
+  platform_device_register(&ast_i2c_dev8_device);
+  i2c_register_board_info(7, wedge100_i2c_bus8, ARRAY_SIZE(wedge100_i2c_bus8));
+
+  platform_device_register(&ast_i2c_dev9_device);
+  i2c_register_board_info(8, wedge100_i2c_bus9, ARRAY_SIZE(wedge100_i2c_bus9));
+
+  /* i2c bus 10 - 12 are not used as i2c on wedge100 */
+
+  platform_device_register(&ast_i2c_dev13_device);
+  i2c_register_board_info(12, wedge100_i2c_bus13, ARRAY_SIZE(wedge100_i2c_bus13));
+
+  /* i2c bug 14 is not used as i2c on wedge100 */
+
+  /* end of defined(CONFIG_WEDGE100) */
+#else
+
 	platform_device_register(&ast_i2c_dev1_device);
 	i2c_register_board_info(0, ast_i2c_board_info_1, ARRAY_SIZE(ast_i2c_board_info_1));
 	platform_device_register(&ast_i2c_dev2_device);
@@ -790,17 +1000,27 @@ void __init ast_add_device_i2c(void)
 	platform_device_register(&ast_i2c_dev5_device);
 	i2c_register_board_info(4, ast_i2c_board_info_5, ARRAY_SIZE(ast_i2c_board_info_5));
 	platform_device_register(&ast_i2c_dev6_device);
+#if defined(CONFIG_YOSEMITE)
+	i2c_register_board_info(5, ast_i2c_board_info_6, ARRAY_SIZE(ast_i2c_board_info_6));
+#endif
 	platform_device_register(&ast_i2c_dev7_device);
 	i2c_register_board_info(6, ast_i2c_board_info_7, ARRAY_SIZE(ast_i2c_board_info_7));
 	platform_device_register(&ast_i2c_dev8_device);
 	i2c_register_board_info(7, ast_i2c_board_info_8, ARRAY_SIZE(ast_i2c_board_info_8));
-	platform_device_register(&ast_i2c_dev9_device);	
+	platform_device_register(&ast_i2c_dev9_device);
 	i2c_register_board_info(8, ast_i2c_board_info_9, ARRAY_SIZE(ast_i2c_board_info_9));
 
 #if defined(CONFIG_ARCH_AST2400)
 	platform_device_register(&ast_i2c_dev10_device);
+
+#if defined(CONFIG_YOSEMITE)
+	i2c_register_board_info(9, ast_i2c_board_info_10, ARRAY_SIZE(ast_i2c_board_info_10));
+	platform_device_register(&ast_i2c_dev11_device);
+	i2c_register_board_info(10, ast_i2c_board_info_11, ARRAY_SIZE(ast_i2c_board_info_11));
+#endif
+
 #if defined(CONFIG_MMC_AST)
-	//Due to share pin with SD 
+	//Due to share pin with SD
 #else
 	/*
 	 * On Wedge, bus 13 is used as i2c bus.  Bus 12 is used on other
@@ -812,7 +1032,12 @@ void __init ast_add_device_i2c(void)
 	i2c_register_board_info(11, ast_i2c_board_info_12, ARRAY_SIZE(ast_i2c_board_info_12));
 	platform_device_register(&ast_i2c_dev13_device);
 	i2c_register_board_info(12, ast_i2c_board_info_13, ARRAY_SIZE(ast_i2c_board_info_13));
-#endif	
+#endif
+
+  /* end of defined(CONFIG_ARCH_AST2400) */
+#endif
+
+  /* end of else of defined(CONFIG_WEDGE100) */
 #endif
 }
 #else
diff --git a/arch/arm/plat-aspeed/dev-spi.c b/arch/arm/plat-aspeed/dev-spi.c
index e22c49e..0cb0189 100644
--- a/arch/arm/plat-aspeed/dev-spi.c
+++ b/arch/arm/plat-aspeed/dev-spi.c
@@ -344,8 +344,8 @@ static struct flash_platform_data wedge_spi_flash_data = {
 
 
 /* Device info for the flash on ast-spi */
-#ifdef CONFIG_ARCH_AST2400
-static struct mtd_partition ast_spi5_flash_partitions[] = {
+#ifdef CONFIG_WEDGE
+static struct mtd_partition wedge_spi5_flash_partitions[] = {
   {
     .name = "led-fpga",
     .offset = 0, /* From 0 */
@@ -355,8 +355,8 @@ static struct mtd_partition ast_spi5_flash_partitions[] = {
 
 static struct flash_platform_data wedge_spi5_flash_data = {
   .type = "at45db011d",
-  .nr_parts = ARRAY_SIZE(ast_spi5_flash_partitions),
-  .parts = ast_spi5_flash_partitions,
+  .nr_parts = ARRAY_SIZE(wedge_spi5_flash_partitions),
+  .parts = wedge_spi5_flash_partitions,
 };
 #endif
 
@@ -372,6 +372,7 @@ static struct spi_board_info ast_spi_devices[] = {
     }, 
 #endif
 #ifdef CONFIG_ARCH_AST2400
+#ifdef CONFIG_WEDGE
     {
         .modalias    = "mtd_dataflash",
         .platform_data  = &wedge_spi5_flash_data,
@@ -380,6 +381,15 @@ static struct spi_board_info ast_spi_devices[] = {
         .bus_num    = 5,
         .mode = SPI_MODE_0,
     },
+#elif defined CONFIG_WEDGE100
+    {
+        .modalias    = "spidev",
+        .chip_select    = 0,
+        .max_speed_hz    = 33 * 1000 * 1000,
+        .bus_num    = 5,
+        .mode = SPI_MODE_0,
+    },
+#endif
     {
         .modalias    = "m25p80",
         .platform_data  = &wedge_spi_flash_data,
@@ -389,13 +399,6 @@ static struct spi_board_info ast_spi_devices[] = {
         .mode = SPI_MODE_0,
     },
 #endif
-    {
-        .modalias    = "spidev",
-        .chip_select    = 0,
-        .max_speed_hz    = 30 * 1000 * 1000,
-        .bus_num    = 1,
-		.mode = SPI_MODE_0,
-    },
 };
 
 #if defined(AST_SPI1_BASE)
@@ -490,5 +493,3 @@ void __init ast_add_device_spi(void)
 #else
 void __init ast_add_device_spi(void) {}
 #endif
-
-
diff --git a/arch/arm/plat-aspeed/dev-uart.c b/arch/arm/plat-aspeed/dev-uart.c
index 0b7b614..e424a5a 100644
--- a/arch/arm/plat-aspeed/dev-uart.c
+++ b/arch/arm/plat-aspeed/dev-uart.c
@@ -6,11 +6,11 @@
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by the Free Software Foundation;
 * either version 2 of the License, or (at your option) any later version.
-* 
+*
 * This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-* 
+*
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
@@ -50,14 +50,14 @@ static struct plat_serial8250_port ast_uart_data[] = {
 		.irq		= IRQ_UART0,
 		.uartclk	= (24*1000000L),
 		.regshift	= 2,
-#if defined(CONFIG_COLDFIRE)		
+#if defined(CONFIG_COLDFIRE)
 		.iotype		= UPIO_MEM32,
 #else
 		.iotype		= UPIO_MEM,
-#endif		
+#endif
 		.flags		= UPF_IOREMAP | UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
 	},
-#if defined(CONFIG_ARCH_AST1010)	
+#if defined(CONFIG_ARCH_AST1010)
 	{
 		.mapbase	= AST_UART1_BASE,
 		.irq		= IRQ_UART1,
@@ -65,7 +65,7 @@ static struct plat_serial8250_port ast_uart_data[] = {
 		.regshift	= 2,
 		.iotype		= UPIO_MEM32,
 		.flags		= UPF_IOREMAP | UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
-	},	
+	},
 	{
 		.mapbase	= AST_UART2_BASE,
 		.irq		= IRQ_UART2,
@@ -73,7 +73,7 @@ static struct plat_serial8250_port ast_uart_data[] = {
 		.regshift	= 2,
 		.iotype 	= UPIO_MEM32,
 		.flags		= UPF_IOREMAP | UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
-	},	
+	},
 #else
 //BMC UART 1 ,2 default to LPC
 #ifdef CONFIG_ARCH_AST1070
@@ -85,7 +85,7 @@ static struct plat_serial8250_port ast_uart_data[] = {
 		.regshift	= 2,
 		.iotype		= UPIO_MEM,
 		.flags		= UPF_IOREMAP | UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
-	},	
+	},
 #endif
 #ifdef AST_UART2_BASE
 	{
@@ -95,7 +95,7 @@ static struct plat_serial8250_port ast_uart_data[] = {
 		.regshift	= 2,
 		.iotype		= UPIO_MEM,
 		.flags		= UPF_IOREMAP | UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
-	},	
+	},
 #endif
 #endif
 #ifdef AST_UART1_BASE
@@ -109,6 +109,19 @@ static struct plat_serial8250_port ast_uart_data[] = {
 		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
 	},
 #endif
+#if defined(CONFIG_YOSEMITE) //Without this, tty offset might change for others
+#ifdef AST_UART2_BASE
+	{
+		.mapbase	= AST_UART2_BASE,
+		.membase	= (char*)(IO_ADDRESS(AST_UART2_BASE)),
+		.irq		= IRQ_UART2,
+		.uartclk	= (24*1000000L),
+		.regshift	= 2,
+		.iotype		= UPIO_MEM,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
+	},
+#endif
+#endif
 #ifdef AST_UART3_BASE
 	{
 		.mapbase	= AST_UART3_BASE,
@@ -117,7 +130,7 @@ static struct plat_serial8250_port ast_uart_data[] = {
 		.regshift	= 2,
 		.iotype		= UPIO_MEM,
 		.flags		= UPF_IOREMAP | UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
-	},	
+	},
 #endif
 #ifdef AST_UART4_BASE
 	{
@@ -127,9 +140,9 @@ static struct plat_serial8250_port ast_uart_data[] = {
 		.regshift	= 2,
 		.iotype 	= UPIO_MEM,
 		.flags		= UPF_IOREMAP | UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
-	},	
+	},
+#endif
 #endif
-#endif	
 	{ },
 };
 
@@ -144,11 +157,16 @@ struct platform_device ast_uart_device = {
 void __init ast_add_device_uart(void)
 {
 #if defined(CONFIG_ARCH_AST1010)
+#elif defined(CONFIG_YOSEMITE)
+	ast_scu_multi_func_uart(1);
+	ast_scu_multi_func_uart(2);
+	ast_scu_multi_func_uart(3);
+	ast_scu_multi_func_uart(4);
 #else
-	ast_scu_multi_func_uart(1);		
-	ast_scu_multi_func_uart(3);		
-	ast_scu_multi_func_uart(4);	
-#endif	
+	ast_scu_multi_func_uart(1);
+	ast_scu_multi_func_uart(3);
+	ast_scu_multi_func_uart(4);
+#endif
 	platform_device_register(&ast_uart_device);
 }
 #else
diff --git a/arch/arm/plat-aspeed/irq.c b/arch/arm/plat-aspeed/irq.c
index b118359..f6100fa 100644
--- a/arch/arm/plat-aspeed/irq.c
+++ b/arch/arm/plat-aspeed/irq.c
@@ -48,13 +48,14 @@ static void ast_mask_irq(unsigned int irq)
 	if((irq >= IRQ_TIMER0) && (irq <= IRQ_TIMER2))
 		timer = 1;
 #endif
-	
-	if (irq > 32) {
+
+  // for irq0-irq31 use LOW register; for irq32-irq63 use HIGH register set.
+	if (irq >= 32) {
 		i=1;
 		irq = irq - 32;
 	} else
 		i=0;
-	
+
 	regVal = readl(AST_INTR_DIS(i));
 	regVal |= (1 << irq);
 	writel(regVal, AST_INTR_DIS(i));
@@ -63,8 +64,8 @@ static void ast_mask_irq(unsigned int irq)
 	 * clear the interrupt
 	 */
 	if(timer)
-		IRQ_EDGE_CLEAR(i,irq);	
-	
+		IRQ_EDGE_CLEAR(i,irq);
+
 }
 
 static void ast_unmask_irq(unsigned int irq)
@@ -72,12 +73,13 @@ static void ast_unmask_irq(unsigned int irq)
 	int i;
 	u32 regVal;
 
-	if (irq > 32) {
+  // for irq0-irq31 use LOW register; for irq32-irq63 use HIGH register set.
+	if (irq >= 32) {
 		i=1;
 		irq = irq - 32;
 	} else
 		i=0;
-	
+
 	regVal = readl(AST_INTR_EN(i));
 	regVal |= (1 << irq);
 	writel(regVal, AST_INTR_EN(i));
@@ -88,8 +90,8 @@ static struct irq_chip ast_irq_chip = {
 	.ack	= ast_mask_irq,
 	.mask	= ast_mask_irq,
 	.unmask = ast_unmask_irq,
-}; 
- 
+};
+
 void __init ast_init_irq(void)
 {
 	unsigned int i;
@@ -107,8 +109,8 @@ void __init ast_init_irq(void)
 	writel(0xFFFFFFFF, AST_INTR_EDGE_CLR(1));
 #endif
 
-	//TOTAL IRQ NUM = 
-	for (i = 0; i < AST_VIC_NUM; i++) 
+	//TOTAL IRQ NUM =
+	for (i = 0; i < AST_VIC_NUM; i++)
 	{
 		if(i<32) {
 			if((i >= IRQ_TIMER0) && (i <= IRQ_TIMER2)) //Timer0/1/2
@@ -125,9 +127,9 @@ void __init ast_init_irq(void)
 				IRQ_SET_HIGH_LEVEL(1,i-32);
 				IRQ_SET_LEVEL_TRIGGER(1,i-32);
 			}
-#endif			
+#endif
 		}
-			
+
 		set_irq_chip(i, &ast_irq_chip);
 		set_irq_handler(i, handle_level_irq);
 		set_irq_flags(i, IRQF_VALID);
diff --git a/drivers/hwmon/ast_adc.c b/drivers/hwmon/ast_adc.c
index 3f95dc6..8f5aa54 100644
--- a/drivers/hwmon/ast_adc.c
+++ b/drivers/hwmon/ast_adc.c
@@ -13,10 +13,10 @@
  *    2012.11.26: Initial version [Ryan Chen]
  */
 
-/* attr ADC sysfs 0~max adc channel 
+/* attr ADC sysfs 0~max adc channel
 *	 0 - show/store enable
 *	 3 - show value
-*	 1 - show/store alarm_en set enable 
+*	 1 - show/store alarm_en set enable
 *	 2 - show alarm   get statuse
 *	 4 - show/store upper
 *	 5 - show/store lower  */
@@ -44,13 +44,33 @@
 
 #define REST_DESIGN		5
 
+
+#ifdef CONFIG_YOSEMITE
+enum {
+  ADC_P5V = 0,
+  ADC_P12V,
+  ADC_P3V3_STBY,
+  ADC_P12V_SLOT0,
+  ADC_P12V_SLOT1,
+  ADC_P12V_SLOT2,
+  ADC_P12V_SLOT3,
+  ADC_P3V3,
+};
+
+enum {
+  REST_DESIGN_P3V3 = 6,
+  REST_DESIGN_P5V = 7,
+  REST_DESIGN_P12V = 8,
+};
+#endif // CONFIG_YOSEMITE
+
 struct adc_vcc_ref_data {
 	int v2;
 	int r1;
-	int r2;	
+	int r2;
 };
 
-static struct adc_vcc_ref_data adc_vcc_ref[6] = {
+static struct adc_vcc_ref_data adc_vcc_ref[9] = {
 	[0] = {
 		.v2 = 0,
 		.r1 = 5600,
@@ -81,6 +101,24 @@ static struct adc_vcc_ref_data adc_vcc_ref[6] = {
 		.r1 = 1000,
 		.r2 = 1000,
 	},
+  // P3V3
+	[6] = {
+		.v2 = 0,
+		.r1 = 5110,
+		.r2 = 8250,
+	},
+  // P5V
+	[7] = {
+		.v2 = 0,
+		.r1 = 5110,
+		.r2 = 3480,
+	},
+  // P12V
+	[8] = {
+		.v2 = 0,
+		.r1 = 5110,
+		.r2 = 1020,
+	},
 };
 
 /* Divisors for voltage sense;  right now adc5 & adc6 divide by 2 */
@@ -93,7 +131,7 @@ static int adc_divisor[] = { 1, 1, 1, 1,
 struct ast_adc_data {
 	struct device			*hwmon_dev;
 	void __iomem			*reg_base;			/* virtual */
-	int 					irq;				//ADC IRQ number 
+	int 					irq;				//ADC IRQ number
 	int						compen_value;		//Compensating value
 };
 
@@ -123,14 +161,14 @@ static void ast_adc_ctrl_init(void)
 	ast_adc_write(ast_adc, AST_ADC_CTRL_COMPEN | AST_ADC_CTRL_NORMAL | AST_ADC_CTRL_EN, AST_ADC_CTRL);
 
 	//Set wait a sensing cycle t (s) = 1000 * 12 * (1/PCLK) * 2 * (ADC0c[31:17] + 1) * (ADC0c[9:0] +1)
-	//ex : pclk = 48Mhz , ADC0c[31:17] = 0,  ADC0c[9:0] = 0x40 : 64,  ADC0c[31:17] = 0x3e7 : 999 
+	//ex : pclk = 48Mhz , ADC0c[31:17] = 0,  ADC0c[9:0] = 0x40 : 64,  ADC0c[31:17] = 0x3e7 : 999
 	// --> 0.0325s	= 12 * 2 * (0x3e7 + 1) *(64+1) / 48000000
-	// --> 0.0005s	= 12 * 2 * (0x3e7 + 1) / 48000000	
-	
+	// --> 0.0005s	= 12 * 2 * (0x3e7 + 1) / 48000000
+
 	pclk = ast_get_pclk();
 
 #if defined(CONFIG_ARCH_AST2300)
-	ast_adc_write(ast_adc, 0x3e7, AST_ADC_CLK); 
+	ast_adc_write(ast_adc, 0x3e7, AST_ADC_CLK);
 
 	ast_adc_write(ast_adc, AST_ADC_CTRL_CH12_EN | AST_ADC_CTRL_COMPEN_CLR| ast_adc_read(ast_adc, AST_ADC_CTRL), AST_ADC_CTRL);
 
@@ -141,16 +179,16 @@ static void ast_adc_ctrl_init(void)
 		ast_adc->compen_value = 0x200 - (ast_adc_read(ast_adc, AST_ADC_CH12_13) & AST_ADC_L_CH_MASK);
 	else
 		ast_adc->compen_value = 0 - (ast_adc_read(ast_adc, AST_ADC_CH12_13) & AST_ADC_L_CH_MASK);
-	
-	printk("compensating value %d \n",ast_adc->compen_value);
-	
+
+	// printk("compensating value %d \n",ast_adc->compen_value);
+
 #elif defined(CONFIG_ARCH_AST2400)
 
 	//For AST2400 A0 workaround  ... ADC0c = 1 ;
 //	ast_adc_write(ast_adc, 1, AST_ADC_CLK);
 //	ast_adc_write(ast_adc, (0x3e7<< 17) | 0x40, AST_ADC_CLK);
 	ast_adc_write(ast_adc, 0x40, AST_ADC_CLK);
-	
+
 	ast_adc_write(ast_adc, AST_ADC_CTRL_CH0_EN | AST_ADC_CTRL_COMPEN | AST_ADC_CTRL_NORMAL | AST_ADC_CTRL_EN, AST_ADC_CTRL);
 
 	ast_adc_read(ast_adc, AST_ADC_CTRL);
@@ -159,15 +197,15 @@ static void ast_adc_ctrl_init(void)
 
 	//compensating value = 0x200 - ADC10[9:0]
 	ast_adc->compen_value = 0x200 - (ast_adc_read(ast_adc, AST_ADC_CH0_1) & AST_ADC_L_CH_MASK);
-	printk("compensating value %d \n",ast_adc->compen_value);
+	// printk("compensating value %d \n",ast_adc->compen_value);
 
 #elif defined(CONFIG_ARCH_AST2500)
-//	TODO ... 
-//	scu read trim 
+//	TODO ...
+//	scu read trim
 //	write trim 0xc4 [3:0]
-	
+
 	ast_adc_write(ast_adc, 0x40, AST_ADC_CLK);
-	
+
 	ast_adc_write(ast_adc, AST_ADC_CTRL_NORMAL | AST_ADC_CTRL_EN, AST_ADC_CTRL);
 
     while(!ast_adc_read(ast_adc, AST_ADC_CTRL) & 0x100);
@@ -175,17 +213,17 @@ static void ast_adc_ctrl_init(void)
 	ast_adc_write(ast_adc, AST_ADC_CTRL_COMPEN  | AST_ADC_CTRL_NORMAL | AST_ADC_CTRL_EN, AST_ADC_CTRL);
 
 	while(ast_adc_read(ast_adc, AST_ADC_CTRL) & AST_ADC_CTRL_COMPEN);
-	
+
 	//compensating value = 0x200 - ADC10[9:0]
 	ast_adc->compen_value = 0x200 - ((ast_adc_read(ast_adc, AST_ADC_TRIM) >> 16) & 0x3ff);
-	printk("compensating value %d \n",ast_adc->compen_value);
-	
+	// printk("compensating value %d \n",ast_adc->compen_value);
+
 #else
 #err "No define for ADC "
 #endif
 
 	ast_adc_write(ast_adc, AST_ADC_CTRL_NORMAL | AST_ADC_CTRL_EN, AST_ADC_CTRL);
-	
+
 }
 
 static u16
@@ -203,9 +241,9 @@ ast_get_adc_hyster_lower(struct ast_adc_data *ast_adc, u8 adc_ch)
 static void
 ast_set_adc_hyster_lower(struct ast_adc_data *ast_adc, u8 adc_ch, u16 value)
 {
-	ast_adc_write(ast_adc, 
+	ast_adc_write(ast_adc,
 			(ast_adc_read(ast_adc, AST_ADC_HYSTER0 + (adc_ch *4)) & ~AST_ADC_L_BOUND) |
-			value, 
+			value,
 			AST_ADC_HYSTER0 + (adc_ch *4));
 
 }
@@ -224,9 +262,9 @@ ast_get_adc_hyster_upper(struct ast_adc_data *ast_adc, u8 adc_ch)
 static void
 ast_set_adc_hyster_upper(struct ast_adc_data *ast_adc, u8 adc_ch, u32 value)
 {
-	ast_adc_write(ast_adc, 
+	ast_adc_write(ast_adc,
 			(ast_adc_read(ast_adc, AST_ADC_HYSTER0 + (adc_ch *4)) & ~AST_ADC_H_BOUND) |
-			(value << 16), 
+			(value << 16),
 			AST_ADC_HYSTER0 + (adc_ch *4));
 
 }
@@ -244,7 +282,7 @@ ast_get_adc_hyster_en(struct ast_adc_data *ast_adc, u8 adc_ch)
 static void
 ast_set_adc_hyster_en(struct ast_adc_data *ast_adc, u8 adc_ch, u8 enable)
 {
-	//tacho source 
+	//tacho source
 	if(enable == 1)
 		ast_adc_write(ast_adc,
 			ast_adc_read(ast_adc, AST_ADC_HYSTER0 + (adc_ch *4)) | AST_ADC_HYSTER_EN,
@@ -270,9 +308,9 @@ ast_get_adc_lower(struct ast_adc_data *ast_adc, u8 adc_ch)
 static void
 ast_set_adc_lower(struct ast_adc_data *ast_adc, u8 adc_ch, u16 value)
 {
-	ast_adc_write(ast_adc, 
+	ast_adc_write(ast_adc,
 			(ast_adc_read(ast_adc, AST_ADC_BOUND0 + (adc_ch *4)) & ~AST_ADC_L_BOUND) |
-			value, 
+			value,
 			AST_ADC_BOUND0 + (adc_ch *4));
 
 }
@@ -293,9 +331,9 @@ ast_get_adc_upper(struct ast_adc_data *ast_adc, u8 adc_ch)
 static void
 ast_set_adc_upper(struct ast_adc_data *ast_adc, u8 adc_ch, u32 value)
 {
-	ast_adc_write(ast_adc, 
+	ast_adc_write(ast_adc,
 			(ast_adc_read(ast_adc, AST_ADC_BOUND0 + (adc_ch *4)) & ~AST_ADC_H_BOUND) |
-			(value << 16), 
+			(value << 16),
 			AST_ADC_BOUND0 + (adc_ch *4));
 
 }
@@ -304,7 +342,7 @@ ast_set_adc_upper(struct ast_adc_data *ast_adc, u8 adc_ch, u32 value)
 static u8
 ast_get_adc_alarm(struct ast_adc_data *ast_adc, u8 adc_ch)
 {
-	//adc ch source 
+	//adc ch source
 	if(ast_adc_read(ast_adc, AST_ADC_IER) & (0x1 << adc_ch))
 		return 1;
 	else
@@ -322,61 +360,61 @@ ast_get_adc_value(struct ast_adc_data *ast_adc, u8 adc_ch)
 			break;
 		case 1:
 			tmp = (ast_adc_read(ast_adc, AST_ADC_CH0_1) & AST_ADC_H_CH_MASK) >> 16;
-			break;	
+			break;
 		case 2:
 			tmp = ast_adc_read(ast_adc, AST_ADC_CH2_3) & AST_ADC_L_CH_MASK;
 			break;
 		case 3:
 			tmp = (ast_adc_read(ast_adc, AST_ADC_CH2_3) & AST_ADC_H_CH_MASK) >> 16;
-			break;	
+			break;
 		case 4:
 			tmp = ast_adc_read(ast_adc, AST_ADC_CH4_5) & AST_ADC_L_CH_MASK;
 			break;
 		case 5:
 			tmp = (ast_adc_read(ast_adc, AST_ADC_CH4_5) & AST_ADC_H_CH_MASK) >> 16;
-			break;	
+			break;
 		case 6:
 			tmp = ast_adc_read(ast_adc, AST_ADC_CH6_7) & AST_ADC_L_CH_MASK;
 			break;
 		case 7:
 			tmp = (ast_adc_read(ast_adc, AST_ADC_CH6_7) & AST_ADC_H_CH_MASK) >> 16;
-			break;	
+			break;
 		case 8:
 			tmp = ast_adc_read(ast_adc, AST_ADC_CH8_9) & AST_ADC_L_CH_MASK;
 			break;
 		case 9:
 			tmp = (ast_adc_read(ast_adc, AST_ADC_CH8_9) & AST_ADC_H_CH_MASK) >> 16;
-			break;	
+			break;
 		case 10:
 			tmp = ast_adc_read(ast_adc, AST_ADC_CH10_11) & AST_ADC_L_CH_MASK;
 			break;
 		case 11:
 			tmp = (ast_adc_read(ast_adc, AST_ADC_CH10_11) & AST_ADC_H_CH_MASK) >> 16;
-			break;	
+			break;
 		case 12:
 			tmp = ast_adc_read(ast_adc, AST_ADC_CH12_13) & AST_ADC_L_CH_MASK;
 			break;
 		case 13:
 			tmp = (ast_adc_read(ast_adc, AST_ADC_CH12_13) & AST_ADC_H_CH_MASK) >> 16;
-			break;	
+			break;
 		case 14:
 			tmp = ast_adc_read(ast_adc, AST_ADC_CH14_15) & AST_ADC_L_CH_MASK;
 			break;
 		case 15:
 			tmp = (ast_adc_read(ast_adc, AST_ADC_CH14_15) & AST_ADC_H_CH_MASK) >> 16;
-			break;	
+			break;
 
 	}
 
 	tmp += ast_adc->compen_value;
 
 //	printk("voltage = %d \n",tmp);
-	
+
 	return tmp;
 
 }
 
-static u8 
+static u8
 ast_get_adc_en(struct ast_adc_data *ast_adc, u8 adc_ch)
 {
     u8 tmp=0;
@@ -390,7 +428,7 @@ ast_get_adc_en(struct ast_adc_data *ast_adc, u8 adc_ch)
 
 }
 
-static void 
+static void
 ast_set_adc_en(struct ast_adc_data *ast_adc, u8 adc_ch, u8 enable)
 {
 	if(enable)
@@ -401,7 +439,7 @@ ast_set_adc_en(struct ast_adc_data *ast_adc, u8 adc_ch, u8 enable)
 
 
 /* NAME sysfs */
-static ssize_t 
+static ssize_t
 show_name(struct device *dev, struct device_attribute *devattr,
                          char *buf)
 {
@@ -416,38 +454,63 @@ static const struct attribute_group name_attribute_groups = {
 	.attrs = name_attributes,
 };
 
-/* attr ADC sysfs 0~max adc channel 
+/* attr ADC sysfs 0~max adc channel
 *	 0 - show/store channel enable
-*	 1 - show value 
+*	 1 - show value
 *	 2 - show alarm   get statuse
 *	 3 - show/store upper
-*	 4 - show/store lower 
-*	 5 - show/store hystersis enable  
-*	 6 - show/store hystersis upper  
-*	 7 - show/store hystersis low  
+*	 4 - show/store lower
+*	 5 - show/store hystersis enable
+*	 6 - show/store hystersis upper
+*	 7 - show/store hystersis low
 */
 
-static u32 
+static u32
 ast_get_voltage(int idx) {
+  u8 rest_design = REST_DESIGN;
   u16 tmp;
   u32 voltage, tmp1, tmp2, tmp3;
   tmp = ast_get_adc_value(ast_adc, idx);
+
+#ifdef CONFIG_YOSEMITE
+  switch (idx) {
+  case ADC_P3V3:
+  case ADC_P3V3_STBY:
+    rest_design = REST_DESIGN_P3V3;
+    break;
+  case ADC_P5V:
+    rest_design = REST_DESIGN_P5V;
+    break;
+  case ADC_P12V:
+  case ADC_P12V_SLOT0:
+  case ADC_P12V_SLOT1:
+  case ADC_P12V_SLOT2:
+  case ADC_P12V_SLOT3:
+    rest_design = REST_DESIGN_P12V;
+    break;
+  default:
+    rest_design = REST_DESIGN;
+  }
+#endif // CONFIG_YOSEMITE
+
   // Voltage Sense Method
-  tmp1 = (adc_vcc_ref[REST_DESIGN].r1 + adc_vcc_ref[REST_DESIGN].r2) * tmp * 25 * 10;
-  tmp2 = adc_vcc_ref[REST_DESIGN].r2 * 1024 ;
-  tmp3 = (adc_vcc_ref[REST_DESIGN].r1 * adc_vcc_ref[REST_DESIGN].v2) / adc_vcc_ref[REST_DESIGN].r2;
+  tmp1 = (adc_vcc_ref[rest_design].r1 + adc_vcc_ref[rest_design].r2) * tmp * 25 * 10;
+  tmp2 = adc_vcc_ref[rest_design].r2 * 1024 ;
+  tmp3 = (adc_vcc_ref[rest_design].r1 * adc_vcc_ref[rest_design].v2) / adc_vcc_ref[rest_design].r2;
   // printk("tmp3 = %d \n",tmp3);
   voltage = (tmp1/tmp2) - tmp3;
 
+#ifndef CONFIG_YOSEMITE
   // Higher voltage inputs require a divisor
 
   if (adc_divisor[idx])
 	voltage /= adc_divisor[idx];
+#endif //CONFIG_YOSEMITE
 
   return voltage;
 }
 
-static ssize_t 
+static ssize_t
 ast_show_adc(struct device *dev, struct device_attribute *attr, char *sysfsbuf)
 {
 	struct sensor_device_attribute_2 *sensor_attr = to_sensor_dev_attr_2(attr);
@@ -455,7 +518,7 @@ ast_show_adc(struct device *dev, struct device_attribute *attr, char *sysfsbuf)
 
 	//sensor_attr->index : pwm_ch#
 	//sensor_attr->nr : attr#
-	switch(sensor_attr->nr) 
+	switch(sensor_attr->nr)
 	{
 		case 0: //channel enable, disable
 			return sprintf(sysfsbuf, "%d : %s\n", ast_get_adc_en(ast_adc,sensor_attr->index),ast_get_adc_en(ast_adc,sensor_attr->index) ? "Enable":"Disable");
@@ -466,23 +529,23 @@ ast_show_adc(struct device *dev, struct device_attribute *attr, char *sysfsbuf)
 			break;
 		case 2: //alarm
 			return sprintf(sysfsbuf, "%d \n", ast_get_adc_alarm(ast_adc,sensor_attr->index));
-			break;			
+			break;
 		case 3: //upper
 			return sprintf(sysfsbuf, "%d \n", ast_get_adc_upper(ast_adc,sensor_attr->index));
-			break;			
+			break;
 		case 4: //lower
 			return sprintf(sysfsbuf, "%d \n", ast_get_adc_lower(ast_adc,sensor_attr->index));
-			break;			
-		case 5: //hystersis enable 
+			break;
+		case 5: //hystersis enable
 			return sprintf(sysfsbuf, "%d : %s\n", ast_get_adc_hyster_en(ast_adc,sensor_attr->index),ast_get_adc_hyster_en(ast_adc,sensor_attr->index) ? "Enable":"Disable");
-			break;			
+			break;
 		case 6: //hystersis upper
 			return sprintf(sysfsbuf, "%d \n", ast_get_adc_hyster_upper(ast_adc,sensor_attr->index));
-			break;			
+			break;
 		case 7: //hystersis lower
 			return sprintf(sysfsbuf, "%d \n", ast_get_adc_hyster_lower(ast_adc,sensor_attr->index));
-			break;			
-		case 8: 
+			break;
+		case 8:
 			voltage = ast_get_voltage(sensor_attr->index);
 			return sprintf(sysfsbuf, "%d\n",voltage * 10);
 
@@ -492,7 +555,7 @@ ast_show_adc(struct device *dev, struct device_attribute *attr, char *sysfsbuf)
 	}
 }
 
-static ssize_t 
+static ssize_t
 ast_store_adc(struct device *dev, struct device_attribute *attr, const char *sysfsbuf, size_t count)
 {
 	u32 input_val;
@@ -503,16 +566,16 @@ ast_store_adc(struct device *dev, struct device_attribute *attr, const char *sys
 
 	//sensor_attr->index : pwm_ch#
 	//sensor_attr->nr : attr#
-	switch(sensor_attr->nr) 
+	switch(sensor_attr->nr)
 	{
 		case 0: //enable, disable
 			ast_set_adc_en(ast_adc, sensor_attr->index, input_val);
 			break;
 		case 1: //value
-			
+
 			break;
 		case 2: //alarm
-			break;			
+			break;
 		case 3:
 			ast_set_adc_upper(ast_adc, sensor_attr->index, input_val);
 			break;
@@ -521,14 +584,14 @@ ast_store_adc(struct device *dev, struct device_attribute *attr, const char *sys
 			break;
 		case 5: //hystersis
 			ast_set_adc_hyster_en(ast_adc, sensor_attr->index, input_val);
-			break;			
+			break;
 		case 6:
 			ast_set_adc_hyster_upper(ast_adc, sensor_attr->index, input_val);
 			break;
 		case 7:
 			ast_set_adc_hyster_lower(ast_adc, sensor_attr->index, input_val);
 			break;
-			
+
 		default:
 			return -EINVAL;
 			break;
@@ -537,15 +600,15 @@ ast_store_adc(struct device *dev, struct device_attribute *attr, const char *sys
 	return count;
 }
 
-/* attr ADC sysfs 0~max adc channel 
+/* attr ADC sysfs 0~max adc channel
 *	 0 - show/store channel enable
-*	 1 - show value 
+*	 1 - show value
 *	 2 - show alarm   get statuse
 *	 3 - show/store upper
-*	 4 - show/store lower 
-*	 5 - show/store hystersis enable  
-*	 6 - show/store hystersis upper  
-*	 7 - show/store hystersis low  
+*	 4 - show/store lower
+*	 5 - show/store hystersis enable
+*	 6 - show/store hystersis upper
+*	 7 - show/store hystersis low
 *	 8 - show value as 1000s, expected by lm-sensors
 */
 
@@ -624,18 +687,18 @@ static const struct attribute_group adc_attribute_groups[] = {
 	{ .attrs = adc7_attributes },
 	{ .attrs = adc8_attributes },
 	{ .attrs = adc9_attributes },
-	{ .attrs = adc10_attributes },	
+	{ .attrs = adc10_attributes },
 	{ .attrs = adc11_attributes },
 #if defined(CONFIG_ARCH_AST2400) || defined(CONFIG_ARCH_AST2500)
 	{ .attrs = adc12_attributes },
 	{ .attrs = adc13_attributes },
 	{ .attrs = adc14_attributes },
 	{ .attrs = adc15_attributes },
-#endif	
+#endif
 };
 
 
-static int 
+static int
 ast_adc_probe(struct platform_device *pdev)
 {
 	struct resource *res;
@@ -695,7 +758,7 @@ ast_adc_probe(struct platform_device *pdev)
 	}
 
 	ast_adc_ctrl_init();
-	
+
 	printk(KERN_INFO "ast_adc: driver successfully loaded.\n");
 
 	return 0;
@@ -714,7 +777,7 @@ out:
 	return ret;
 }
 
-static int 
+static int
 ast_adc_remove(struct platform_device *pdev)
 {
 	int i=0;
@@ -739,14 +802,14 @@ ast_adc_remove(struct platform_device *pdev)
 }
 
 #ifdef CONFIG_PM
-static int 
+static int
 ast_adc_suspend(struct platform_device *pdev, pm_message_t state)
 {
 	printk("ast_adc_suspend : TODO \n");
 	return 0;
 }
 
-static int 
+static int
 ast_adc_resume(struct platform_device *pdev)
 {
 	ast_adc_ctrl_init();
@@ -769,13 +832,13 @@ static struct platform_driver ast_adc_driver = {
     },
 };
 
-static int __init 
+static int __init
 ast_adc_init(void)
 {
 	return platform_driver_register(&ast_adc_driver);
 }
 
-static void __exit 
+static void __exit
 ast_adc_exit(void)
 {
 	platform_driver_unregister(&ast_adc_driver);
diff --git a/drivers/i2c/busses/i2c-ast.c b/drivers/i2c/busses/i2c-ast.c
index 7a083de..9bb3154 100644
--- a/drivers/i2c/busses/i2c-ast.c
+++ b/drivers/i2c/busses/i2c-ast.c
@@ -40,63 +40,68 @@
 #include <plat/ast_i2c.h>
 #endif
 
-//AST2400 buffer mode issue , force I2C slave write use byte mode , read use buffer mode 
+//AST2400 buffer mode issue , force I2C slave write use byte mode , read use buffer mode
 /* Use platform_data instead of module parameters */
 /* Fast Mode = 400 kHz, Standard = 100 kHz */
 //static int clock = 100; /* Default: 100 kHz */
 
 
 /***************************************************************************/
+
+#ifdef CONFIG_AST_I2C_SLAVE_RDWR
+#define I2C_S_BUF_SIZE 		64
+#define I2C_S_RX_BUF_NUM 		4
+#define BUFF_FULL		0xff00
+#define BUFF_ONGOING	1
+#endif
+
+#define AST_LOCKUP_DETECTED (0x1 << 15)
+
 struct ast_i2c_dev {
 	struct ast_i2c_driver_data *ast_i2c_data;
 	struct device		*dev;
-	void __iomem		*reg_base;			/* virtual */	
-	int 				irq;				//I2C IRQ number 
-	u32					bus_id;				//for i2c dev# IRQ number check 
-	u32					state;				//I2C xfer mode state matchine 
+	void __iomem		*reg_base;			/* virtual */
+	int 				irq;				//I2C IRQ number
+	u32					bus_id;				//for i2c dev# IRQ number check
+	u32					state;				//I2C xfer mode state matchine
 	struct i2c_adapter	adap;
-	struct buf_page		*req_page;	
+	struct buf_page		*req_page;
 //dma or buff mode needed
 	unsigned char		*dma_buf;
 	dma_addr_t			dma_addr;
-	
-//master	
+
+//master
 	int					xfer_last;			//cur xfer is last msgs for stop msgs
 	struct i2c_msg 		*master_msgs;		//cur xfer msgs
-	int					master_xfer_len;			//cur xfer len 
+	int					master_xfer_len;			//cur xfer len
 	int					master_xfer_cnt;			//total xfer count
 	u32					master_xfer_mode;			//cur xfer mode ... 0 : no_op , master: 1 byte , 2 : buffer , 3: dma , slave : xxxx
 	struct completion	cmd_complete;
 	int					cmd_err;
 	u8 					blk_r_flag; 		//for smbus block read
-	void 				(*do_master_xfer)(struct ast_i2c_dev *i2c_dev);	
-//Slave structure	
+	void 				(*do_master_xfer)(struct ast_i2c_dev *i2c_dev);
+  spinlock_t  master_lock;
+//Slave structure
 	u8					slave_operation;
 	u8					slave_event;
 	struct i2c_msg		*slave_msgs; 		//cur slave xfer msgs
-	int 				slave_xfer_len;			
-	int 				slave_xfer_cnt;		
-	u32					slave_xfer_mode;			//cur xfer mode ... 0 : no_op , master: 1 byte , 2 : buffer , 3: dma , slave : xxxx		
+	int 				slave_xfer_len;
+	int 				slave_xfer_cnt;
+	u32					slave_xfer_mode;			//cur xfer mode ... 0 : no_op , master: 1 byte , 2 : buffer , 3: dma , slave : xxxx
 	void				(*do_slave_xfer)(struct ast_i2c_dev *i2c_dev);
-};
-
 #ifdef CONFIG_AST_I2C_SLAVE_RDWR
-#define I2C_S_BUF_SIZE 		64
-#define I2C_S_RX_BUF_NUM 		4
-#define BUFF_FULL		0xff00
-#define BUFF_ONGOING	1	
-
-struct i2c_msg		slave_rx_msg[I2C_S_RX_BUF_NUM + 1];
-struct i2c_msg		slave_tx_msg;	
-static spinlock_t	slave_rx_lock = SPIN_LOCK_UNLOCKED;
+  struct i2c_msg		slave_rx_msg[I2C_S_RX_BUF_NUM + 1];
+  struct i2c_msg		slave_tx_msg;
+  spinlock_t	slave_rx_lock;
 #endif
+};
+
 
-static spinlock_t g_master_lock = SPIN_LOCK_UNLOCKED;
 
 static inline void
 ast_i2c_write(struct ast_i2c_dev *i2c_dev, u32 val, u32 reg)
 {
-//	dev_dbg(i2c_dev->dev, "ast_i2c_write : val: %x , reg : %x \n",val,reg);	
+//	dev_dbg(i2c_dev->dev, "ast_i2c_write : val: %x , reg : %x \n",val,reg);
 	writel(val, i2c_dev->reg_base+ reg);
 }
 
@@ -107,7 +112,7 @@ ast_i2c_read(struct ast_i2c_dev *i2c_dev, u32 reg)
 	u32 val = readl(i2c_dev->reg_base + reg);
 	printk("R : reg %x , val: %x \n",reg, val);
 	return val;
-#else	
+#else
 	return readl(i2c_dev->reg_base + reg);
 #endif
 }
@@ -152,7 +157,7 @@ static void ast_slave_issue_alert(struct ast_i2c_dev *i2c_dev, u8 enable)
 static void ast_slave_mode_enable(struct ast_i2c_dev *i2c_dev, struct i2c_msg *msgs)
 {
 	if(msgs->buf[0] == 1) {
-		ast_i2c_write(i2c_dev, msgs->addr, I2C_DEV_ADDR_REG);	
+		ast_i2c_write(i2c_dev, msgs->addr, I2C_DEV_ADDR_REG);
 		ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_FUN_CTRL_REG) | AST_I2CD_SLAVE_EN, I2C_FUN_CTRL_REG);
 	} else
 		ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_FUN_CTRL_REG) & ~AST_I2CD_SLAVE_EN, I2C_FUN_CTRL_REG);
@@ -162,12 +167,14 @@ static void ast_slave_mode_enable(struct ast_i2c_dev *i2c_dev, struct i2c_msg *m
 
 static void ast_i2c_dev_init(struct ast_i2c_dev *i2c_dev)
 {
-	//I2CG Reset 
+	//I2CG Reset
 	ast_i2c_write(i2c_dev, 0, I2C_FUN_CTRL_REG);
 
-#ifdef CONFIG_AST_I2C_SLAVE_EEPROM	
+#ifdef CONFIG_AST_I2C_SLAVE_EEPROM
 	i2c_dev->ast_i2c_data->slave_init(&(i2c_dev->slave_msgs));
 	ast_slave_mode_enable(i2c_dev, i2c_dev->slave_msgs);
+#else
+  i2c_dev->slave_msgs = i2c_dev->slave_rx_msg;
 #endif
 
 	//Enable Master Mode
@@ -177,20 +184,20 @@ static void ast_i2c_dev_init(struct ast_i2c_dev *i2c_dev)
 	/* Set AC Timing */
 #if defined(CONFIG_ARCH_AST2400)
 	if(i2c_dev->ast_i2c_data->bus_clk/1000 > 400) {
-		printk("high speed mode enable clk [%dkhz]\n",i2c_dev->ast_i2c_data->bus_clk/1000);		
+		printk("high speed mode enable clk [%dkhz]\n",i2c_dev->ast_i2c_data->bus_clk/1000);
 		ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev, I2C_FUN_CTRL_REG) |
 							AST_I2CD_M_HIGH_SPEED_EN |
 							AST_I2CD_M_SDA_DRIVE_1T_EN |
-							AST_I2CD_SDA_DRIVE_1T_EN 
+							AST_I2CD_SDA_DRIVE_1T_EN
 							, I2C_FUN_CTRL_REG);
-		
+
 		/* Set AC Timing */
 		ast_i2c_write(i2c_dev, 0x3, I2C_AC_TIMING_REG2);
-		ast_i2c_write(i2c_dev, select_i2c_clock(i2c_dev), I2C_AC_TIMING_REG1);		
+		ast_i2c_write(i2c_dev, select_i2c_clock(i2c_dev), I2C_AC_TIMING_REG1);
 	}else {
-		/* target apeed is xxKhz*/	
+		/* target apeed is xxKhz*/
 		ast_i2c_write(i2c_dev, select_i2c_clock(i2c_dev), I2C_AC_TIMING_REG1);
-		ast_i2c_write(i2c_dev, AST_NO_TIMEOUT_CTRL, I2C_AC_TIMING_REG2);	
+		ast_i2c_write(i2c_dev, AST_NO_TIMEOUT_CTRL, I2C_AC_TIMING_REG2);
 	}
 #else
 	/* target apeed is xxKhz*/
@@ -206,12 +213,12 @@ static void ast_i2c_dev_init(struct ast_i2c_dev *i2c_dev)
 
 	//TODO
 //	ast_i2c_write(i2c_dev, 0xAF, I2C_INTR_CTRL_REG);
-	//Enable Interrupt, STOP Interrupt has bug in AST2000 
-	
+	//Enable Interrupt, STOP Interrupt has bug in AST2000
+
 	/* Set interrupt generation of I2C controller */
 	ast_i2c_write(i2c_dev,
-				AST_I2CD_SDA_DL_TO_INTR_EN | 	
-				AST_I2CD_BUS_RECOVER_INTR_EN | 	
+				AST_I2CD_SDA_DL_TO_INTR_EN |
+				AST_I2CD_BUS_RECOVER_INTR_EN |
 				AST_I2CD_SMBUS_ALT_INTR_EN |
 //				AST_I2CD_SLAVE_MATCH_INTR_EN |
 				AST_I2CD_SCL_TO_INTR_EN |
@@ -230,16 +237,16 @@ static void ast_i2c_dev_init(struct ast_i2c_dev *i2c_dev)
 static void ast_i2c_slave_buff_init(struct ast_i2c_dev *i2c_dev)
 {
 	int i;
-	//Tx buf  1 
-	slave_tx_msg.len = I2C_S_BUF_SIZE;
-	slave_tx_msg.buf = kzalloc(I2C_S_BUF_SIZE, GFP_KERNEL);
+	//Tx buf  1
+	i2c_dev->slave_tx_msg.len = I2C_S_BUF_SIZE;
+	i2c_dev->slave_tx_msg.buf = kzalloc(I2C_S_BUF_SIZE, GFP_KERNEL);
 	//Rx buf 4
 	for(i=0; i<I2C_S_RX_BUF_NUM+1; i++) {
-		slave_rx_msg[i].addr = ~BUFF_ONGOING;
-		slave_rx_msg[i].flags = 0;	//mean empty buffer 
-		slave_rx_msg[i].len = I2C_S_BUF_SIZE;
-		slave_rx_msg[i].buf = kzalloc(I2C_S_BUF_SIZE, GFP_KERNEL);
-	}	
+		i2c_dev->slave_rx_msg[i].addr = ~BUFF_ONGOING;
+		i2c_dev->slave_rx_msg[i].flags = 0;	//mean empty buffer
+		i2c_dev->slave_rx_msg[i].len = I2C_S_BUF_SIZE;
+		i2c_dev->slave_rx_msg[i].buf = kzalloc(I2C_S_BUF_SIZE, GFP_KERNEL);
+	}
 }
 
 static void ast_i2c_slave_rdwr_xfer(struct ast_i2c_dev *i2c_dev)
@@ -247,13 +254,13 @@ static void ast_i2c_slave_rdwr_xfer(struct ast_i2c_dev *i2c_dev)
 	int i;
 	unsigned long flags;
 
-	spin_lock_irqsave(&slave_rx_lock, flags);
-	
+	spin_lock_irqsave(&i2c_dev->slave_rx_lock, flags);
+
 	switch(i2c_dev->slave_event) {
 		case I2C_SLAVE_EVENT_START_WRITE:
 			for(i=0; i<I2C_S_RX_BUF_NUM; i++) {
-				if((slave_rx_msg[i].flags == 0) && (slave_rx_msg[i].addr != BUFF_ONGOING)) {
-					slave_rx_msg[i].addr = BUFF_ONGOING;
+				if((i2c_dev->slave_rx_msg[i].flags == 0) && (i2c_dev->slave_rx_msg[i].addr != BUFF_ONGOING)) {
+					i2c_dev->slave_rx_msg[i].addr = BUFF_ONGOING;
 					break;
 				}
 			}
@@ -261,40 +268,40 @@ static void ast_i2c_slave_rdwr_xfer(struct ast_i2c_dev *i2c_dev)
 				printk("RX buffer full ........use tmp msgs buff \n");
 				//TODO...
 			}
-			printk("I2C_SLAVE_EVENT_START_WRITE ... %d \n", i);
+			//printk("I2C_SLAVE_EVENT_START_WRITE ... %d \n", i);
 
-			i2c_dev->slave_msgs = &slave_rx_msg[i];
+			i2c_dev->slave_msgs = &i2c_dev->slave_rx_msg[i];
 			break;
 		case I2C_SLAVE_EVENT_START_READ:
-			printk("I2C_SLAVE_EVENT_START_READ ERROR .. not imple \n");
-			i2c_dev->slave_msgs = &slave_tx_msg;
+			//printk("I2C_SLAVE_EVENT_START_READ ERROR .. not imple \n");
+			i2c_dev->slave_msgs = &i2c_dev->slave_tx_msg;
 			break;
 		case I2C_SLAVE_EVENT_WRITE:
-			printk("I2C_SLAVE_EVENT_WRITE next write ERROR ...\n");			
-			i2c_dev->slave_msgs = &slave_tx_msg;
+			//printk("I2C_SLAVE_EVENT_WRITE next write ERROR ...\n");
+			i2c_dev->slave_msgs = &i2c_dev->slave_tx_msg;
 			break;
 		case I2C_SLAVE_EVENT_READ:
-			printk("I2C_SLAVE_EVENT_READ ERROR ... \n");			
-			i2c_dev->slave_msgs = &slave_tx_msg;
+			printk("I2C_SLAVE_EVENT_READ ERROR ... \n");
+			i2c_dev->slave_msgs = &i2c_dev->slave_tx_msg;
 			break;
 		case I2C_SLAVE_EVENT_NACK:
-			printk("I2C_SLAVE_EVENT_NACK ERROR ... \n");			
-			i2c_dev->slave_msgs = &slave_tx_msg;
+			//printk("I2C_SLAVE_EVENT_NACK ERROR ... \n");
+			i2c_dev->slave_msgs = &i2c_dev->slave_tx_msg;
 			break;
 		case I2C_SLAVE_EVENT_STOP:
-			printk("I2C_SLAVE_EVENT_STOP \n");			
+			//printk("I2C_SLAVE_EVENT_STOP \n");
 			for(i=0; i<I2C_S_RX_BUF_NUM; i++) {
-				if(slave_rx_msg[i].addr == BUFF_ONGOING) {
-					slave_rx_msg[i].flags = BUFF_FULL;
-					slave_rx_msg[i].addr = 0;
+				if(i2c_dev->slave_rx_msg[i].addr == BUFF_ONGOING) {
+					i2c_dev->slave_rx_msg[i].flags = BUFF_FULL;
+					i2c_dev->slave_rx_msg[i].addr = 0;
 					break;
 				}
 			}
-			
-			i2c_dev->slave_msgs = &slave_tx_msg;
+
+			i2c_dev->slave_msgs = &i2c_dev->slave_tx_msg;
 			break;
 	}
-	spin_unlock_irqrestore(&slave_rx_lock, flags);
+	spin_unlock_irqrestore(&i2c_dev->slave_rx_lock, flags);
 
 }
 
@@ -308,29 +315,29 @@ static int ast_i2c_slave_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs)
 		case 0:
 //			printk("slave read \n");
 			//cur_msg = get_free_msg;
-			spin_lock_irqsave(&slave_rx_lock, flags);
+			spin_lock_irqsave(&i2c_dev->slave_rx_lock, flags);
 
 			for(i=0; i<I2C_S_RX_BUF_NUM; i++) {
-				if((slave_rx_msg[i].addr == 0) && (slave_rx_msg[i].flags == BUFF_FULL)) {
-					memcpy(msgs->buf, slave_rx_msg[i].buf, slave_rx_msg[i].len);
-					msgs->len = slave_rx_msg[i].len;
-					slave_rx_msg[i].flags = 0;
-					slave_rx_msg[i].len = 0;
+				if((i2c_dev->slave_rx_msg[i].addr == 0) && (i2c_dev->slave_rx_msg[i].flags == BUFF_FULL)) {
+					memcpy(msgs->buf, i2c_dev->slave_rx_msg[i].buf, i2c_dev->slave_rx_msg[i].len);
+					msgs->len = i2c_dev->slave_rx_msg[i].len;
+					i2c_dev->slave_rx_msg[i].flags = 0;
+					i2c_dev->slave_rx_msg[i].len = 0;
 					break;
 				}
 			}
-			spin_unlock_irqrestore(&slave_rx_lock, flags);
-			
+			spin_unlock_irqrestore(&i2c_dev->slave_rx_lock, flags);
+
 			if(i == I2C_S_RX_BUF_NUM) {
-				printk("No buffer ........ \n");
+				//printk("No buffer ........ \n");
 				msgs->len = 0;
 				ret = -1;
 			}
 			break;
 		case I2C_M_RD:	//slave write
 //			printk("slave write \n");
-			memcpy(msgs->buf, slave_tx_msg.buf, I2C_S_BUF_SIZE);
-			break;		
+			memcpy(msgs->buf, i2c_dev->slave_tx_msg.buf, I2C_S_BUF_SIZE);
+			break;
 		case I2C_S_EN:
 			if((msgs->addr < 0x1) || (msgs->addr > 0xff)) {
 				ret = -1;
@@ -352,7 +359,7 @@ static int ast_i2c_slave_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs)
 		default:
 			printk("slave xfer error \n");
 			break;
-		
+
 	}
 	return ret;
 }
@@ -360,16 +367,16 @@ static int ast_i2c_slave_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs)
 
 #endif
 
-static u8 
+static u8
 ast_i2c_bus_error_recover(struct ast_i2c_dev *i2c_dev)
 {
 	u32 sts;
-	int r;		
+	int r;
 	u32 i = 0;
-	
+
 	//Check 0x14's SDA and SCL status
 	sts = ast_i2c_read(i2c_dev,I2C_CMD_REG);
-	
+
 	if ((sts & AST_I2CD_SDA_LINE_STS) && (sts & AST_I2CD_SCL_LINE_STS)) {
 		//Means bus is idle.
 		dev_dbg(i2c_dev->dev, "I2C bus (%d) is idle. I2C slave doesn't exist?!\n", i2c_dev->bus_id);
@@ -377,11 +384,11 @@ ast_i2c_bus_error_recover(struct ast_i2c_dev *i2c_dev)
 	}
 
 	dev_dbg(i2c_dev->dev, "ERROR!! I2C(%d) bus hanged, try to recovery it!\n", i2c_dev->bus_id);
-	
-	
+
+
 	if ((sts & AST_I2CD_SDA_LINE_STS) && !(sts & AST_I2CD_SCL_LINE_STS)) {
 		//if SDA == 1 and SCL == 0, it means the master is locking the bus.
-		//Send a stop command to unlock the bus.		
+		//Send a stop command to unlock the bus.
 		dev_dbg(i2c_dev->dev, "I2C's master is locking the bus, try to stop it.\n");
 //
 		init_completion(&i2c_dev->cmd_complete);
@@ -397,12 +404,12 @@ ast_i2c_bus_error_recover(struct ast_i2c_dev *i2c_dev)
 			dev_dbg(i2c_dev->dev, "recovery error \n");
 			return -1;
 		}
-			
+
 		if (r == 0) {
 			 dev_dbg(i2c_dev->dev, "recovery timed out\n");
 			 return -1;
 		} else {
-			dev_dbg(i2c_dev->dev, "Recovery successfully\n");		
+			dev_dbg(i2c_dev->dev, "Recovery successfully\n");
 			return 0;
 		}
 
@@ -415,11 +422,11 @@ ast_i2c_bus_error_recover(struct ast_i2c_dev *i2c_dev)
 		for (i = 0; i < 10; i++) {
 			ast_i2c_dev_init(i2c_dev);
 			//Do the recovery command BIT11
-			init_completion(&i2c_dev->cmd_complete);			
+			init_completion(&i2c_dev->cmd_complete);
 			ast_i2c_write(i2c_dev, AST_I2CD_BUS_RECOVER_CMD_EN, I2C_CMD_REG);
-			
+
 			r = wait_for_completion_interruptible_timeout(&i2c_dev->cmd_complete,
-														   i2c_dev->adap.timeout*HZ);			
+														   i2c_dev->adap.timeout*HZ);
 			if (i2c_dev->cmd_err != 0 &&
 			   i2c_dev->cmd_err != AST_I2CD_INTR_STS_NORMAL_STOP) {
 				dev_dbg(i2c_dev->dev, "ERROR!! Failed to do recovery command(0x%08x)\n", i2c_dev->cmd_err);
@@ -438,31 +445,56 @@ ast_i2c_bus_error_recover(struct ast_i2c_dev *i2c_dev)
 		dev_dbg(i2c_dev->dev, "Don't know how to handle this case?!\n");
 		return -1;
 	}
-	dev_dbg(i2c_dev->dev, "Recovery successfully\n");
+  dev_dbg(i2c_dev->dev, "Recovery successfully\n");
 	return 0;
 }
 
-static void ast_master_alert_recv(struct ast_i2c_dev *i2c_dev)	
+static void ast_master_alert_recv(struct ast_i2c_dev *i2c_dev)
 {
 	printk("ast_master_alert_recv bus id %d, Disable Alt, Please Imple \n",i2c_dev->bus_id);
 }
 
 static int ast_i2c_wait_bus_not_busy(struct ast_i2c_dev *i2c_dev)
 {
-	int timeout = 32; //TODO number
+	int timeout = 10; //TODO number
+  volatile u8 mode = 0;
 //	printk("ast_i2c_wait_bus_not_busy \n");
+
+  // Wait for slave transfer to finish
+  mode = i2c_dev->slave_operation;
+  while (mode == 1) {
+    if (timeout <= 0) {
+      break;
+    }
+    mode = i2c_dev->slave_operation;
+    timeout--;
+    msleep(1);
+  }
+
+  if (timeout <= 0) {
+    return -EAGAIN;
+  }
+
+  // Wait for Bus to go IDLE
+  timeout = 10;
 	while (ast_i2c_read(i2c_dev,I2C_CMD_REG) & AST_I2CD_BUS_BUSY_STS) {
-		ast_i2c_bus_error_recover(i2c_dev);
-		if(timeout<=0)
+		if(timeout<=0) {
 			break;
+    }
+
 		timeout--;
-		msleep(2);
+		msleep(1);
 	}
 
-	return timeout <= 0 ? EAGAIN : 0;
+  if (timeout <=0) {
+    ast_i2c_bus_error_recover(i2c_dev);
+    return 0;
+  }
+
+  return 0;
 }
 
-static void ast_i2c_do_dma_xfer(struct ast_i2c_dev *i2c_dev)	
+static void ast_i2c_do_dma_xfer(struct ast_i2c_dev *i2c_dev)
 {
 	u32 cmd = 0;
 	int i;
@@ -470,49 +502,49 @@ static void ast_i2c_do_dma_xfer(struct ast_i2c_dev *i2c_dev)
 	i2c_dev->master_xfer_mode = DMA_XFER;
 	i2c_dev->slave_xfer_mode = DMA_XFER;
 
-	if(i2c_dev->slave_operation == 1) { 
+	if(i2c_dev->slave_operation == 1) {
 		if(i2c_dev->slave_msgs->flags & I2C_M_RD) {
 			//DMA tx mode
 			if(i2c_dev->slave_msgs->len > AST_I2C_DMA_SIZE)
 				i2c_dev->slave_xfer_len = AST_I2C_DMA_SIZE;
-			else 
+			else
 				i2c_dev->slave_xfer_len = i2c_dev->slave_msgs->len;
-			
+
 			dev_dbg(i2c_dev->dev, "(<--) slave tx DMA \n");
 			for(i=0; i<i2c_dev->slave_xfer_len; i++)
 				i2c_dev->dma_buf[i] = i2c_dev->slave_msgs->buf[i2c_dev->slave_xfer_cnt + i];
-			
+
 			ast_i2c_write(i2c_dev, i2c_dev->dma_addr, I2C_DMA_BASE_REG);
 			ast_i2c_write(i2c_dev, (i2c_dev->slave_xfer_len-1), I2C_DMA_LEN_REG);
-			ast_i2c_write(i2c_dev, AST_I2CD_TX_DMA_ENABLE | AST_I2CD_S_TX_CMD,I2C_CMD_REG);	
+			ast_i2c_write(i2c_dev, AST_I2CD_TX_DMA_ENABLE | AST_I2CD_S_TX_CMD,I2C_CMD_REG);
 		} else {
 			//DMA prepare rx
 			dev_dbg(i2c_dev->dev, "(-->) slave rx DMA \n");
 			ast_i2c_write(i2c_dev, i2c_dev->dma_addr, I2C_DMA_BASE_REG);
 			ast_i2c_write(i2c_dev, (AST_I2C_DMA_SIZE-1), I2C_DMA_LEN_REG);
-			ast_i2c_write(i2c_dev, AST_I2CD_RX_DMA_ENABLE, I2C_CMD_REG);		
+			ast_i2c_write(i2c_dev, AST_I2CD_RX_DMA_ENABLE, I2C_CMD_REG);
 		}
 	} else {
 		dev_dbg(i2c_dev->dev,"M cnt %d, xf len %d \n",i2c_dev->master_xfer_cnt, i2c_dev->master_msgs->len);
 		if(i2c_dev->master_xfer_cnt == -1) {
-			//send start 
+			//send start
 			dev_dbg(i2c_dev->dev, " %sing %d byte%s %s 0x%02x\n",
 							i2c_dev->master_msgs->flags & I2C_M_RD ? "read" : "write",
 							i2c_dev->master_msgs->len, i2c_dev->master_msgs->len > 1 ? "s" : "",
 							i2c_dev->master_msgs->flags & I2C_M_RD ? "from" : "to", i2c_dev->master_msgs->addr);
 
 			if(i2c_dev->master_msgs->flags & I2C_M_RD) {
-				//workaround .. HW can;t send start read addr with buff mode 
+				//workaround .. HW can;t send start read addr with buff mode
 				cmd = AST_I2CD_M_START_CMD | AST_I2CD_M_TX_CMD;
 				ast_i2c_write(i2c_dev, (i2c_dev->master_msgs->addr <<1) |0x1, I2C_BYTE_BUF_REG);
 
 //				tx_buf[0] = (i2c_dev->master_msgs->addr <<1); //+1
 				i2c_dev->master_xfer_len = 1;
 				ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-									AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);	
+									AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
 			} else {
 				//tx
-				cmd = AST_I2CD_M_START_CMD | AST_I2CD_M_TX_CMD | AST_I2CD_TX_DMA_ENABLE;		
+				cmd = AST_I2CD_M_START_CMD | AST_I2CD_M_TX_CMD | AST_I2CD_TX_DMA_ENABLE;
 
 				i2c_dev->dma_buf[0] = (i2c_dev->master_msgs->addr <<1);	//+1
 				//next data write
@@ -520,44 +552,44 @@ static void ast_i2c_do_dma_xfer(struct ast_i2c_dev *i2c_dev)
 					i2c_dev->master_xfer_len = AST_I2C_DMA_SIZE;
 				else
 					i2c_dev->master_xfer_len = i2c_dev->master_msgs->len + 1;
-				
+
 				for(i = 1; i < i2c_dev->master_xfer_len; i++)
 					i2c_dev->dma_buf[i] = i2c_dev->master_msgs->buf[i2c_dev->master_xfer_cnt+i];
-				
+
 				if (i2c_dev->xfer_last == 1) {
 					dev_dbg(i2c_dev->dev, "last stop \n");
 					cmd |= AST_I2CD_M_STOP_CMD;
 					ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) &
-										~AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);				
-					
+										~AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
+
 				} else {
 					ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-										AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);			
+										AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
 				}
 				ast_i2c_write(i2c_dev, i2c_dev->dma_addr, I2C_DMA_BASE_REG);
 				ast_i2c_write(i2c_dev, (i2c_dev->master_xfer_len-1), I2C_DMA_LEN_REG);
-				
+
 			}
-			ast_i2c_write(i2c_dev, cmd, I2C_CMD_REG);			
+			ast_i2c_write(i2c_dev, cmd, I2C_CMD_REG);
 			dev_dbg(i2c_dev->dev, "txfer size %d , cmd = %x \n",i2c_dev->master_xfer_len, cmd);
 
 		} else if (i2c_dev->master_xfer_cnt < i2c_dev->master_msgs->len){
-			//Next send 
+			//Next send
 			if(i2c_dev->master_msgs->flags & I2C_M_RD) {
 				//Rx data
 				cmd = AST_I2CD_M_RX_CMD | AST_I2CD_RX_DMA_ENABLE;
-															
+
 				if((i2c_dev->master_msgs->len - i2c_dev->master_xfer_cnt) > AST_I2C_DMA_SIZE) {
 					i2c_dev->master_xfer_len = AST_I2C_DMA_SIZE;
 					ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
 										AST_I2CD_RX_DOWN_INTR_EN, I2C_INTR_CTRL_REG);
-					
+
 				} else {
 					i2c_dev->master_xfer_len = i2c_dev->master_msgs->len - i2c_dev->master_xfer_cnt;
 					if((i2c_dev->master_msgs->flags & I2C_M_RECV_LEN) && (i2c_dev->blk_r_flag == 0)) {
 						dev_dbg(i2c_dev->dev, "I2C_M_RECV_LEN \n");
 						ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-											AST_I2CD_RX_DOWN_INTR_EN, I2C_INTR_CTRL_REG);						
+											AST_I2CD_RX_DOWN_INTR_EN, I2C_INTR_CTRL_REG);
 					} else {
 #ifdef CONFIG_AST1010
 						//Workaround for ast1010 can't send NACK
@@ -568,7 +600,7 @@ static void ast_i2c_do_dma_xfer(struct ast_i2c_dev *i2c_dev)
 							i2c_dev->master_xfer_mode = BYTE_XFER;
 							ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) &
 												~AST_I2CD_RX_DOWN_INTR_EN, I2C_INTR_CTRL_REG);
-							
+
 						} else if (i2c_dev->master_xfer_len > 1) {
 							i2c_dev->master_xfer_len -=1;
 							ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
@@ -578,8 +610,8 @@ static void ast_i2c_do_dma_xfer(struct ast_i2c_dev *i2c_dev)
 						}
 #else
 						if(i2c_dev->xfer_last == 1) {
-							dev_dbg(i2c_dev->dev, "last stop \n");							
-							cmd |= AST_I2CD_M_STOP_CMD; 
+							dev_dbg(i2c_dev->dev, "last stop \n");
+							cmd |= AST_I2CD_M_STOP_CMD;
 							ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) &
 											~AST_I2CD_RX_DOWN_INTR_EN, I2C_INTR_CTRL_REG);
 						} else {
@@ -588,9 +620,9 @@ static void ast_i2c_do_dma_xfer(struct ast_i2c_dev *i2c_dev)
 						}
 						//TODO check....
 						cmd |= AST_I2CD_M_S_RX_CMD_LAST;
-#endif						
+#endif
 					}
-					
+
 				}
 				ast_i2c_write(i2c_dev, i2c_dev->dma_addr, I2C_DMA_BASE_REG);
 				ast_i2c_write(i2c_dev, i2c_dev->master_xfer_len-1, I2C_DMA_LEN_REG);
@@ -603,23 +635,23 @@ static void ast_i2c_do_dma_xfer(struct ast_i2c_dev *i2c_dev)
 				if((i2c_dev->master_msgs->len - i2c_dev->master_xfer_cnt) > AST_I2C_DMA_SIZE) {
 					i2c_dev->master_xfer_len = AST_I2C_DMA_SIZE;
 					ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-										AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);			
-				
+										AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
+
 				} else {
 					i2c_dev->master_xfer_len = i2c_dev->master_msgs->len - i2c_dev->master_xfer_cnt;
 					if(i2c_dev->xfer_last == 1) {
 						dev_dbg(i2c_dev->dev, "last stop \n");
 						cmd |= AST_I2CD_M_STOP_CMD;
 						ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) &
-											~AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);				
-						
+											~AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
+
 					} else {
 						ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-											AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);			
+											AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
 					}
 				}
 
-				for(i = 0; i < i2c_dev->master_xfer_len; i++) 
+				for(i = 0; i < i2c_dev->master_xfer_len; i++)
 					i2c_dev->dma_buf[i] = i2c_dev->master_msgs->buf[i2c_dev->master_xfer_cnt + i];
 
 				ast_i2c_write(i2c_dev, i2c_dev->dma_addr, I2C_DMA_BASE_REG);
@@ -627,33 +659,33 @@ static void ast_i2c_do_dma_xfer(struct ast_i2c_dev *i2c_dev)
 				ast_i2c_write(i2c_dev, cmd , I2C_CMD_REG);
 				dev_dbg(i2c_dev->dev, "txfer size %d , cmd = %x \n",i2c_dev->master_xfer_len, cmd);
 
-			}		
+			}
 		}else {
-			//should send next msg 
+			//should send next msg
 			 if(i2c_dev->master_xfer_cnt != i2c_dev->master_msgs->len)
 					 printk("complete rx ... bus=%d addr=0x%x (%d vs. %d) ERROR\n",
 					 i2c_dev->bus_id, i2c_dev->master_msgs->addr,
 					 i2c_dev->master_xfer_cnt, i2c_dev->master_msgs->len);
-			
+
 			 dev_dbg(i2c_dev->dev, "ast_i2c_do_byte_xfer complete \n");
 			 i2c_dev->cmd_err = 0;
-			 complete(&i2c_dev->cmd_complete);		
+			 complete(&i2c_dev->cmd_complete);
 		}
-	
+
 	}
 
-	
+
 }
 
-static void ast_i2c_do_pool_xfer(struct ast_i2c_dev *i2c_dev)	
+static void ast_i2c_do_pool_xfer(struct ast_i2c_dev *i2c_dev)
 {
 	u32 cmd = 0;
 	int i;
 	u32 *tx_buf;
 
 	i2c_dev->master_xfer_mode = BUFF_XFER;
-	i2c_dev->slave_xfer_mode = BUFF_XFER; 	
-	
+	i2c_dev->slave_xfer_mode = BUFF_XFER;
+
 #if defined(CONFIG_ARCH_AST2400)
 	ast_i2c_write(i2c_dev,
 					(ast_i2c_read(i2c_dev, I2C_FUN_CTRL_REG) &
@@ -665,15 +697,15 @@ static void ast_i2c_do_pool_xfer(struct ast_i2c_dev *i2c_dev)
 	tx_buf = (u32 *) i2c_dev->req_page->page_addr;
 
 
-	if(i2c_dev->slave_operation == 1) { 
+	if(i2c_dev->slave_operation == 1) {
 		if(i2c_dev->slave_msgs->flags & I2C_M_RD) {
 			dev_dbg(i2c_dev->dev, "(<--) slave tx buf \n");
-	
+
 			if(i2c_dev->slave_msgs->len > i2c_dev->req_page->page_size)
 				i2c_dev->slave_xfer_len = i2c_dev->req_page->page_size;
 			else
 				i2c_dev->slave_xfer_len = i2c_dev->slave_msgs->len;
-			
+
 			for(i = 0; i< i2c_dev->slave_xfer_len; i++) {
 				if(i%4 == 0)
 					tx_buf[i/4] = 0;
@@ -681,80 +713,80 @@ static void ast_i2c_do_pool_xfer(struct ast_i2c_dev *i2c_dev)
 				dev_dbg(i2c_dev->dev, "[%x] ",tx_buf[i/4]);
 			}
 			dev_dbg(i2c_dev->dev, "\n");
-		
-			ast_i2c_write(i2c_dev, AST_I2CD_TX_DATA_BUF_END_SET((i2c_dev->slave_xfer_len-1)) | 
-						AST_I2CD_BUF_BASE_ADDR_SET((i2c_dev->req_page->page_addr_point)), 
+
+			ast_i2c_write(i2c_dev, AST_I2CD_TX_DATA_BUF_END_SET((i2c_dev->slave_xfer_len-1)) |
+						AST_I2CD_BUF_BASE_ADDR_SET((i2c_dev->req_page->page_addr_point)),
 						I2C_BUF_CTRL_REG);
-		
+
 			ast_i2c_write(i2c_dev, AST_I2CD_TX_BUFF_ENABLE | AST_I2CD_S_TX_CMD, I2C_CMD_REG);
 		} else {
 			//prepare for new rx
 			dev_dbg(i2c_dev->dev, "(-->) slave prepare rx buf \n");
-			ast_i2c_write(i2c_dev, 
+			ast_i2c_write(i2c_dev,
 						AST_I2CD_RX_BUF_END_ADDR_SET((i2c_dev->req_page->page_size-1)) |
 						AST_I2CD_BUF_BASE_ADDR_SET((i2c_dev->req_page->page_addr_point)),
 						I2C_BUF_CTRL_REG);
 
-			ast_i2c_write(i2c_dev, AST_I2CD_RX_BUFF_ENABLE, I2C_CMD_REG);			
-			
+			ast_i2c_write(i2c_dev, AST_I2CD_RX_BUFF_ENABLE, I2C_CMD_REG);
+
 		}
 	} else {
 		dev_dbg(i2c_dev->dev,"M cnt %d, xf len %d \n",i2c_dev->master_xfer_cnt, i2c_dev->master_msgs->len);
 		if(i2c_dev->master_xfer_cnt == -1) {
-			//send start 
+			//send start
 			dev_dbg(i2c_dev->dev, " %sing %d byte%s %s 0x%02x\n",
 							i2c_dev->master_msgs->flags & I2C_M_RD ? "read" : "write",
 							i2c_dev->master_msgs->len, i2c_dev->master_msgs->len > 1 ? "s" : "",
 							i2c_dev->master_msgs->flags & I2C_M_RD ? "from" : "to", i2c_dev->master_msgs->addr);
 
 			if(i2c_dev->master_msgs->flags & I2C_M_RD) {
-//workaround .. HW can;t send start read addr with buff mode 
+//workaround .. HW can;t send start read addr with buff mode
 				cmd = AST_I2CD_M_START_CMD | AST_I2CD_M_TX_CMD;
 				ast_i2c_write(i2c_dev, (i2c_dev->master_msgs->addr <<1) |0x1, I2C_BYTE_BUF_REG);
 
 //				tx_buf[0] = (i2c_dev->master_msgs->addr <<1); //+1
 				i2c_dev->master_xfer_len = 1;
 				ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-									AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);			
+									AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
 			} else {
-				cmd = AST_I2CD_M_START_CMD | AST_I2CD_M_TX_CMD | AST_I2CD_TX_BUFF_ENABLE;			
+				cmd = AST_I2CD_M_START_CMD | AST_I2CD_M_TX_CMD | AST_I2CD_TX_BUFF_ENABLE;
 				tx_buf[0] = (i2c_dev->master_msgs->addr <<1);	//+1
 				//next data write
 				if((i2c_dev->master_msgs->len + 1) > i2c_dev->req_page->page_size)
 					i2c_dev->master_xfer_len = i2c_dev->req_page->page_size;
 				else
 					i2c_dev->master_xfer_len = i2c_dev->master_msgs->len + 1;
-				
+
 				for(i = 1; i < i2c_dev->master_xfer_len; i++) {
 					if(i%4 == 0)
 						tx_buf[i/4] = 0;
 					tx_buf[i/4] |= (i2c_dev->master_msgs->buf[i2c_dev->master_xfer_cnt + i] << ((i%4)*8)) ;
 				}
-				
+
 				if (i2c_dev->xfer_last == 1) {
 					dev_dbg(i2c_dev->dev, "last stop \n");
 					cmd |= AST_I2CD_M_STOP_CMD;
 					ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) &
-										~AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);				
-					
+										~AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
+
 				} else {
 					ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-										AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);			
+										AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
 				}
-				ast_i2c_write(i2c_dev, 
+				ast_i2c_write(i2c_dev,
 							AST_I2CD_TX_DATA_BUF_END_SET((i2c_dev->master_xfer_len - 1)) |
 							AST_I2CD_BUF_BASE_ADDR_SET(i2c_dev->req_page->page_addr_point),
 							I2C_BUF_CTRL_REG);
 			}
-			ast_i2c_write(i2c_dev, cmd, I2C_CMD_REG);			
+			ast_i2c_write(i2c_dev, cmd, I2C_CMD_REG);
 			dev_dbg(i2c_dev->dev, "txfer size %d , cmd = %x \n",i2c_dev->master_xfer_len, cmd);
 
 		} else if (i2c_dev->master_xfer_cnt < i2c_dev->master_msgs->len){
-			//Next send 
+			//Next send
 			if(i2c_dev->master_msgs->flags & I2C_M_RD) {
 				//Rx data
 				cmd = AST_I2CD_M_RX_CMD | AST_I2CD_RX_BUFF_ENABLE;
-															
+
 				if((i2c_dev->master_msgs->len - i2c_dev->master_xfer_cnt) > i2c_dev->req_page->page_size) {
 					i2c_dev->master_xfer_len = i2c_dev->req_page->page_size;
 					ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
@@ -764,11 +796,11 @@ static void ast_i2c_do_pool_xfer(struct ast_i2c_dev *i2c_dev)
 					if((i2c_dev->master_msgs->flags & I2C_M_RECV_LEN) && (i2c_dev->blk_r_flag == 0)) {
 						dev_dbg(i2c_dev->dev, "I2C_M_RECV_LEN \n");
 						ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-											AST_I2CD_RX_DOWN_INTR_EN, I2C_INTR_CTRL_REG);						
+											AST_I2CD_RX_DOWN_INTR_EN, I2C_INTR_CTRL_REG);
 					} else {
 						if(i2c_dev->xfer_last == 1) {
-							dev_dbg(i2c_dev->dev, "last stop \n");							
-							cmd |= AST_I2CD_M_STOP_CMD; 
+							dev_dbg(i2c_dev->dev, "last stop \n");
+							cmd |= AST_I2CD_M_STOP_CMD;
 							ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) &
 											~AST_I2CD_RX_DOWN_INTR_EN, I2C_INTR_CTRL_REG);
 						} else {
@@ -791,46 +823,46 @@ static void ast_i2c_do_pool_xfer(struct ast_i2c_dev *i2c_dev)
 				if((i2c_dev->master_msgs->len - i2c_dev->master_xfer_cnt) > i2c_dev->req_page->page_size) {
 					i2c_dev->master_xfer_len = i2c_dev->req_page->page_size;
 					ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-										AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);			
-				
+										AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
+
 				} else {
 					i2c_dev->master_xfer_len = i2c_dev->master_msgs->len - i2c_dev->master_xfer_cnt;
 					if(i2c_dev->xfer_last == 1) {
 						dev_dbg(i2c_dev->dev, "last stop \n");
 						cmd |= AST_I2CD_M_STOP_CMD;
 						ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) &
-											~AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);				
-						
+											~AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
+
 					} else {
 						ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-											AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);			
+											AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
 					}
 				}
-				
+
 				for(i = 0; i < i2c_dev->master_xfer_len; i++) {
 					if(i%4 == 0)
 						tx_buf[i/4] = 0;
 					tx_buf[i/4] |= (i2c_dev->master_msgs->buf[i2c_dev->master_xfer_cnt + i] << ((i%4)*8)) ;
 				}
-//				printk("count %x \n",ast_i2c_read(i2c_dev,I2C_CMD_REG));				
-				ast_i2c_write(i2c_dev, 
+//				printk("count %x \n",ast_i2c_read(i2c_dev,I2C_CMD_REG));
+				ast_i2c_write(i2c_dev,
 							AST_I2CD_TX_DATA_BUF_END_SET((i2c_dev->master_xfer_len - 1)) |
 							AST_I2CD_BUF_BASE_ADDR_SET(i2c_dev->req_page->page_addr_point),
 							I2C_BUF_CTRL_REG);
-		
+
 				ast_i2c_write(i2c_dev, cmd , I2C_CMD_REG);
 				dev_dbg(i2c_dev->dev, "txfer size %d , cmd = %x \n",i2c_dev->master_xfer_len, cmd);
 			}
 		} else {
-			//should send next msg 
+			//should send next msg
 			if(i2c_dev->master_xfer_cnt != i2c_dev->master_msgs->len)
 				printk("complete rx ... bus=%d addr=0x%x (%d vs. %d) ERROR\n",
 				i2c_dev->bus_id, i2c_dev->master_msgs->addr,
 				i2c_dev->master_xfer_cnt, i2c_dev->master_msgs->len);
-			
+
 			dev_dbg(i2c_dev->dev, "ast_i2c_do_byte_xfer complete \n");
 			i2c_dev->cmd_err = 0;
-			complete(&i2c_dev->cmd_complete);										
+			complete(&i2c_dev->cmd_complete);
 		}
 
 	}
@@ -843,16 +875,16 @@ static void ast_i2c_do_byte_xfer(struct ast_i2c_dev *i2c_dev)
 	i2c_dev->master_xfer_mode = BYTE_XFER;
 	i2c_dev->master_xfer_len = 1;
 
-	i2c_dev->slave_xfer_mode = BYTE_XFER;	
+	i2c_dev->slave_xfer_mode = BYTE_XFER;
 	i2c_dev->slave_xfer_len = 1;
-	
-	if(i2c_dev->slave_operation == 1) { 
+
+	if(i2c_dev->slave_operation == 1) {
 		dev_dbg(i2c_dev->dev,"S cnt %d, xf len %d \n",i2c_dev->slave_xfer_cnt, i2c_dev->slave_msgs->len);
 		if(i2c_dev->slave_msgs->flags & I2C_M_RD) {
 			//READ <-- TX
 			dev_dbg(i2c_dev->dev, "(<--) slave(tx) buf %d [%x]\n", i2c_dev->slave_xfer_cnt, i2c_dev->slave_msgs->buf[i2c_dev->slave_xfer_cnt]);
 			ast_i2c_write(i2c_dev, i2c_dev->slave_msgs->buf[i2c_dev->slave_xfer_cnt], I2C_BYTE_BUF_REG);
-			ast_i2c_write(i2c_dev, AST_I2CD_S_TX_CMD, I2C_CMD_REG); 
+			ast_i2c_write(i2c_dev, AST_I2CD_S_TX_CMD, I2C_CMD_REG);
 		} else {
 			// Write -->Rx
 			//no need to handle in byte mode
@@ -862,21 +894,21 @@ static void ast_i2c_do_byte_xfer(struct ast_i2c_dev *i2c_dev)
 	} else {
 		dev_dbg(i2c_dev->dev,"M cnt %d, xf len %d \n",i2c_dev->master_xfer_cnt, i2c_dev->master_msgs->len);
 		if(i2c_dev->master_xfer_cnt == -1) {
-			//first start 
+			//first start
 			dev_dbg(i2c_dev->dev, " %sing %d byte%s %s 0x%02x\n",
 							i2c_dev->master_msgs->flags & I2C_M_RD ? "read" : "write",
 							i2c_dev->master_msgs->len, i2c_dev->master_msgs->len > 1 ? "s" : "",
 							i2c_dev->master_msgs->flags & I2C_M_RD ? "from" : "to", i2c_dev->master_msgs->addr);
-			
-		
-			if(i2c_dev->master_msgs->flags & I2C_M_RD) 
+
+
+			if(i2c_dev->master_msgs->flags & I2C_M_RD)
 				ast_i2c_write(i2c_dev, (i2c_dev->master_msgs->addr <<1) |0x1, I2C_BYTE_BUF_REG);
 			else
 				ast_i2c_write(i2c_dev, (i2c_dev->master_msgs->addr <<1), I2C_BYTE_BUF_REG);
 
 			ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-								AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);			
-			
+								AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
+
 			ast_i2c_write(i2c_dev, AST_I2CD_M_TX_CMD | AST_I2CD_M_START_CMD, I2C_CMD_REG);
 
 
@@ -888,7 +920,7 @@ static void ast_i2c_do_byte_xfer(struct ast_i2c_dev *i2c_dev)
 				if((i2c_dev->master_msgs->flags & I2C_M_RECV_LEN) && (i2c_dev->master_xfer_cnt == 0)) {
 					dev_dbg(i2c_dev->dev, "I2C_M_RECV_LEN \n");
 					ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-										AST_I2CD_RX_DOWN_INTR_EN, I2C_INTR_CTRL_REG);			
+										AST_I2CD_RX_DOWN_INTR_EN, I2C_INTR_CTRL_REG);
 
 				} else if((i2c_dev->xfer_last == 1) && (i2c_dev->master_xfer_cnt + 1 == i2c_dev->master_msgs->len)) {
 					cmd |= AST_I2CD_M_S_RX_CMD_LAST | AST_I2CD_M_STOP_CMD;
@@ -897,11 +929,11 @@ static void ast_i2c_do_byte_xfer(struct ast_i2c_dev *i2c_dev)
 										~AST_I2CD_RX_DOWN_INTR_EN, I2C_INTR_CTRL_REG);
 				} else {
 					ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-										AST_I2CD_RX_DOWN_INTR_EN, I2C_INTR_CTRL_REG);			
+										AST_I2CD_RX_DOWN_INTR_EN, I2C_INTR_CTRL_REG);
 				}
 
 				dev_dbg(i2c_dev->dev, "(<--) rx byte, cmd = %x \n",cmd);
-				
+
 				ast_i2c_write(i2c_dev, cmd, I2C_CMD_REG);
 
 
@@ -911,29 +943,29 @@ static void ast_i2c_do_byte_xfer(struct ast_i2c_dev *i2c_dev)
 				ast_i2c_write(i2c_dev, *(xfer_buf + i2c_dev->master_xfer_cnt), I2C_BYTE_BUF_REG);
 				if((i2c_dev->xfer_last == 1) && (i2c_dev->master_xfer_cnt + 1 == i2c_dev->master_msgs->len)) {
 					ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) &
-										~AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);				
+										~AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
 					ast_i2c_write(i2c_dev, AST_I2CD_M_TX_CMD | AST_I2CD_M_STOP_CMD, I2C_CMD_REG);
 				} else {
 					ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
-										AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);			
+										AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
 					ast_i2c_write(i2c_dev, AST_I2CD_M_TX_CMD, I2C_CMD_REG);
 				}
 			}
-					
+
 		} else {
-			//should send next msg 
+			//should send next msg
 			if(i2c_dev->master_xfer_cnt != i2c_dev->master_msgs->len)
 				printk("CNT ERROR bus=%d addr=0x%x (%d vs. %d)\n",
 				       i2c_dev->bus_id, i2c_dev->master_msgs->addr,
 				       i2c_dev->master_xfer_cnt, i2c_dev->master_msgs->len);
-			
+
 			dev_dbg(i2c_dev->dev, "ast_i2c_do_byte_xfer complete \n");
 			i2c_dev->cmd_err = 0;
-			complete(&i2c_dev->cmd_complete);		
-			
+			complete(&i2c_dev->cmd_complete);
+
 		}
 	}
-		
+
 }
 
 static void ast_i2c_slave_xfer_done(struct ast_i2c_dev *i2c_dev)
@@ -941,8 +973,8 @@ static void ast_i2c_slave_xfer_done(struct ast_i2c_dev *i2c_dev)
 	u32 xfer_len;
 	int i;
 	u8 *rx_buf;
-	
-	dev_dbg(i2c_dev->dev, "ast_i2c_slave_xfer_done [%d]\n",i2c_dev->slave_xfer_mode);	
+
+	dev_dbg(i2c_dev->dev, "ast_i2c_slave_xfer_done [%d]\n",i2c_dev->slave_xfer_mode);
 
 	if (i2c_dev->slave_msgs->flags & I2C_M_RD) {
 		//tx done , only check tx count ...
@@ -979,16 +1011,16 @@ static void ast_i2c_slave_xfer_done(struct ast_i2c_dev *i2c_dev)
 			xfer_len = AST_I2CD_RX_BUF_ADDR_GET(ast_i2c_read(i2c_dev, I2C_BUF_CTRL_REG));
 			if(xfer_len == 0)
 				xfer_len = AST_I2C_PAGE_SIZE;
-	
+
 			dev_dbg(i2c_dev->dev,"rx buff done len %d \n",xfer_len);
-			
+
 			rx_buf = (u8 *)i2c_dev->req_page->page_addr;
-	
+
 			for(i=0;i<xfer_len;i++) {
 				i2c_dev->slave_msgs->buf[i2c_dev->slave_xfer_cnt+i] = rx_buf[i];
 				dev_dbg(i2c_dev->dev,"%d, [%x] \n",i2c_dev->slave_xfer_cnt+i ,i2c_dev->slave_msgs->buf[i2c_dev->slave_xfer_cnt+i]);
 			}
-		
+
 		} else {
 			//RX DMA DOWN
 			xfer_len = ast_i2c_read(i2c_dev, I2C_DMA_LEN_REG);
@@ -996,15 +1028,15 @@ static void ast_i2c_slave_xfer_done(struct ast_i2c_dev *i2c_dev)
 				xfer_len = i2c_dev->slave_xfer_len;
 			else
 				xfer_len = i2c_dev->slave_xfer_len - xfer_len - 1;
-			
+
 			dev_dbg(i2c_dev->dev, " rx dma done len %d \n", xfer_len);
-			
+
 			for(i=0;i<xfer_len;i++) {
 				i2c_dev->slave_msgs->buf[i2c_dev->slave_xfer_cnt+i] = i2c_dev->dma_buf[i];
 				dev_dbg(i2c_dev->dev,"%d, [%x] \n",i2c_dev->slave_xfer_cnt+i ,i2c_dev->slave_msgs->buf[i2c_dev->slave_xfer_cnt+i]);
 			}
 		}
-	
+
 	}
 
 	if(xfer_len !=i2c_dev->slave_xfer_len) {
@@ -1012,7 +1044,7 @@ static void ast_i2c_slave_xfer_done(struct ast_i2c_dev *i2c_dev)
 		printk(" **slave xfer error ====\n");
 		//should goto stop....
 	} else
-		i2c_dev->slave_xfer_cnt += i2c_dev->slave_xfer_len; 
+		i2c_dev->slave_xfer_cnt += i2c_dev->slave_xfer_len;
 
 
 	if((i2c_dev->slave_event == I2C_SLAVE_EVENT_NACK) || (i2c_dev->slave_event == I2C_SLAVE_EVENT_STOP)) {
@@ -1020,33 +1052,33 @@ static void ast_i2c_slave_xfer_done(struct ast_i2c_dev *i2c_dev)
 			ast_i2c_slave_rdwr_xfer(i2c_dev);
 #else
 			i2c_dev->ast_i2c_data->slave_xfer(i2c_dev->slave_event, &(i2c_dev->slave_msgs));
-#endif				
+#endif
 		i2c_dev->slave_xfer_cnt = 0;
 	} else {
 		if(i2c_dev->slave_xfer_cnt == i2c_dev->slave_msgs->len)	{
-			dev_dbg(i2c_dev->dev,"slave next msgs \n"); 	
+			dev_dbg(i2c_dev->dev,"slave next msgs \n");
 #ifdef CONFIG_AST_I2C_SLAVE_RDWR
 			ast_i2c_slave_rdwr_xfer(i2c_dev);
 #else
 			i2c_dev->ast_i2c_data->slave_xfer(i2c_dev->slave_event, &(i2c_dev->slave_msgs));
-#endif			
+#endif
 
 			i2c_dev->slave_xfer_cnt = 0;
-		} 
+		}
 		i2c_dev->do_slave_xfer(i2c_dev);
 	}
 
 
 	if(AST_I2CD_IDLE == i2c_dev->state) {
-		dev_dbg(i2c_dev->dev,"** Slave go IDLE **\n");		
+		dev_dbg(i2c_dev->dev,"** Slave go IDLE **\n");
 		i2c_dev->slave_operation = 0;
-	
+
 		if(i2c_dev->slave_xfer_mode == BUFF_XFER) {
 			i2c_dev->ast_i2c_data->free_pool_buff_page(i2c_dev->req_page);
-		} 
-		
-	} 
-	
+		}
+
+	}
+
 }
 
 //TX/Rx Done
@@ -1057,7 +1089,7 @@ static void ast_i2c_master_xfer_done(struct ast_i2c_dev *i2c_dev)
 	u8 *pool_buf;
 	unsigned long flags;
 
-	spin_lock_irqsave(&g_master_lock, flags);
+	spin_lock_irqsave(&i2c_dev->master_lock, flags);
 
 	/*
 	 * This function shall be involked during interrupt handling.
@@ -1068,8 +1100,8 @@ static void ast_i2c_master_xfer_done(struct ast_i2c_dev *i2c_dev)
 		goto unlock_out;
 	}
 
-	dev_dbg(i2c_dev->dev, "ast_i2c_master_xfer_done mode[%d]\n",i2c_dev->master_xfer_mode);	
-		
+	dev_dbg(i2c_dev->dev, "ast_i2c_master_xfer_done mode[%d]\n",i2c_dev->master_xfer_mode);
+
 	if (i2c_dev->master_msgs->flags & I2C_M_RD) {
 		if(i2c_dev->master_xfer_cnt == -1) {
 			xfer_len = 1;
@@ -1077,16 +1109,16 @@ static void ast_i2c_master_xfer_done(struct ast_i2c_dev *i2c_dev)
 		}
 		if(i2c_dev->master_xfer_mode == BYTE_XFER) {
 			if ((i2c_dev->master_msgs->flags & I2C_M_RECV_LEN) && (i2c_dev->blk_r_flag == 0)) {
-				i2c_dev->master_msgs->len += (ast_i2c_read(i2c_dev,I2C_BYTE_BUF_REG) & AST_I2CD_RX_BYTE_BUFFER) >> 8; 
+				i2c_dev->master_msgs->len += (ast_i2c_read(i2c_dev,I2C_BYTE_BUF_REG) & AST_I2CD_RX_BYTE_BUFFER) >> 8;
 				i2c_dev->blk_r_flag = 1;
-				dev_dbg(i2c_dev->dev, "I2C_M_RECV_LEN %d \n", i2c_dev->master_msgs->len -1);			
+				dev_dbg(i2c_dev->dev, "I2C_M_RECV_LEN %d \n", i2c_dev->master_msgs->len -1);
 			}
 			xfer_len = 1;
 			i2c_dev->master_msgs->buf[i2c_dev->master_xfer_cnt] = (ast_i2c_read(i2c_dev,I2C_BYTE_BUF_REG) & AST_I2CD_RX_BYTE_BUFFER) >> 8;
 		} else if (i2c_dev->master_xfer_mode == BUFF_XFER) {
 			pool_buf = (u8 *)i2c_dev->req_page->page_addr;
 			xfer_len = AST_I2CD_RX_BUF_ADDR_GET(ast_i2c_read(i2c_dev, I2C_BUF_CTRL_REG));
-			
+
 			if(xfer_len == 0)
 				xfer_len = AST_I2C_PAGE_SIZE;
 
@@ -1098,7 +1130,7 @@ static void ast_i2c_master_xfer_done(struct ast_i2c_dev *i2c_dev)
 			if ((i2c_dev->master_msgs->flags & I2C_M_RECV_LEN) && (i2c_dev->blk_r_flag == 0)) {
 				i2c_dev->master_msgs->len += pool_buf[0];
 				i2c_dev->blk_r_flag = 1;
-				dev_dbg(i2c_dev->dev, "I2C_M_RECV_LEN %d \n", i2c_dev->master_msgs->len -1);			
+				dev_dbg(i2c_dev->dev, "I2C_M_RECV_LEN %d \n", i2c_dev->master_msgs->len -1);
 			}
 		} else {
 			//DMA Mode
@@ -1114,13 +1146,13 @@ static void ast_i2c_master_xfer_done(struct ast_i2c_dev *i2c_dev)
 				dev_dbg(i2c_dev->dev, "buf[%x] \n", i2c_dev->dma_buf[i]);
 				dev_dbg(i2c_dev->dev, "buf[%x] \n", i2c_dev->dma_buf[i+1]);
 			}
-	
+
 			if ((i2c_dev->master_msgs->flags & I2C_M_RECV_LEN) && (i2c_dev->blk_r_flag == 0)) {
 					i2c_dev->master_msgs->len += i2c_dev->dma_buf[0];
 					i2c_dev->blk_r_flag = 1;
-					dev_dbg(i2c_dev->dev, "I2C_M_RECV_LEN %d \n", i2c_dev->master_msgs->len -1);			
+					dev_dbg(i2c_dev->dev, "I2C_M_RECV_LEN %d \n", i2c_dev->master_msgs->len -1);
 			}
-			
+
 		}
 
 	}else {
@@ -1153,28 +1185,28 @@ next_xfer:
 		i2c_dev->cmd_err = 1;
 		goto done_out;
 	} else
-		i2c_dev->master_xfer_cnt += i2c_dev->master_xfer_len; 
+		i2c_dev->master_xfer_cnt += i2c_dev->master_xfer_len;
 
 	if(i2c_dev->master_xfer_cnt != i2c_dev->master_msgs->len) {
 		dev_dbg(i2c_dev->dev,"do next cnt \n");
 		i2c_dev->do_master_xfer(i2c_dev);
 	} else {
-#if 0	
-		int i;		
+#if 0
+		int i;
 		printk(" ===== \n");
 		for(i=0;i<i2c_dev->master_msgs->len;i++)
 			printk("rx buf i,[%x]\n",i,i2c_dev->master_msgs->buf[i]);
-		printk(" ===== \n");	
-#endif		
+		printk(" ===== \n");
+#endif
 		i2c_dev->cmd_err = 0;
 
 done_out:
 		dev_dbg(i2c_dev->dev,"msgs complete \n");
-		complete(&i2c_dev->cmd_complete);					
+		complete(&i2c_dev->cmd_complete);
 	}
 
 unlock_out:
-	spin_unlock_irqrestore(&g_master_lock, flags);
+	spin_unlock_irqrestore(&i2c_dev->master_lock, flags);
 }
 
 static void ast_i2c_slave_addr_match(struct ast_i2c_dev *i2c_dev)
@@ -1187,7 +1219,7 @@ static void ast_i2c_slave_addr_match(struct ast_i2c_dev *i2c_dev)
 	i2c_dev->slave_msgs->buf[0] = match;
 	dev_dbg(i2c_dev->dev, "S Start Addr match [%x] \n",match);
 
-	
+
 	if(match & 1) {
 		i2c_dev->slave_event = I2C_SLAVE_EVENT_START_READ;
 	} else {
@@ -1201,7 +1233,7 @@ static void ast_i2c_slave_addr_match(struct ast_i2c_dev *i2c_dev)
 #else
 	i2c_dev->ast_i2c_data->slave_xfer(i2c_dev->slave_event, &(i2c_dev->slave_msgs));
 	i2c_dev->slave_xfer_cnt = 0;
-#endif			
+#endif
 
 	//request
 	if(i2c_dev->ast_i2c_data->slave_dma == BYTE_MODE)
@@ -1211,7 +1243,7 @@ static void ast_i2c_slave_addr_match(struct ast_i2c_dev *i2c_dev)
 	else {
 		if(i2c_dev->ast_i2c_data->request_pool_buff_page(&(i2c_dev->req_page)) == 0)
 			i2c_dev->do_slave_xfer = ast_i2c_do_pool_xfer;
-		else								
+		else
 			i2c_dev->do_slave_xfer = ast_i2c_do_byte_xfer;
 	}
 
@@ -1221,7 +1253,7 @@ static void ast_i2c_slave_addr_match(struct ast_i2c_dev *i2c_dev)
 
 static irqreturn_t i2c_ast_handler(int this_irq, void *dev_id)
 {
-	u32 sts;	
+	u32 sts;
 
 	struct ast_i2c_dev *i2c_dev = dev_id;
 	u32 isr_sts = readl(i2c_dev->ast_i2c_data->reg_gr);
@@ -1231,7 +1263,7 @@ static irqreturn_t i2c_ast_handler(int this_irq, void *dev_id)
 
 	i2c_dev->state = (ast_i2c_read(i2c_dev,I2C_CMD_REG) >> 19) & 0xf;
 	sts = ast_i2c_read(i2c_dev,I2C_INTR_STS_REG);
-//	printk("ISR : %x , sts [%x]\n",sts , xfer_sts);	
+//	printk("ISR : %x , sts [%x]\n",sts , xfer_sts);
 //	dev_dbg(i2c_dev->dev,"ISR : %x , sts [%x]\n",sts , xfer_sts);
 
 //	dev_dbg(i2c_dev->dev,"sts machine %x, slave_op %d \n", xfer_sts,i2c_dev->slave_operation);
@@ -1244,9 +1276,9 @@ static irqreturn_t i2c_ast_handler(int this_irq, void *dev_id)
 					I2C_INTR_CTRL_REG);
 		ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_SMBUS_ALT, I2C_INTR_STS_REG);
 		ast_master_alert_recv(i2c_dev);
-		sts &= ~AST_I2CD_SMBUS_ALT_INTR_EN; 
+		sts &= ~AST_I2CD_SMBUS_ALT_INTR_EN;
 	}
-	
+
 	if(AST_I2CD_INTR_STS_ABNORMAL & sts) {
 		i2c_dev->cmd_err |= AST_I2CD_INTR_STS_ABNORMAL;
 		// Turn off interrupts for further abnormal
@@ -1257,6 +1289,8 @@ static irqreturn_t i2c_ast_handler(int this_irq, void *dev_id)
 			I2C_INTR_CTRL_REG);
 		complete(&i2c_dev->cmd_complete);
 		sts &= ~AST_I2CD_INTR_STS_ABNORMAL;
+    // Need to clear the interrupt
+    ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_ABNORMAL, I2C_INTR_STS_REG);
 	}
 
 	switch(sts) {
@@ -1265,7 +1299,7 @@ static irqreturn_t i2c_ast_handler(int this_irq, void *dev_id)
 				i2c_dev->slave_event = I2C_SLAVE_EVENT_READ;
 				ast_i2c_slave_xfer_done(i2c_dev);
 				dev_dbg(i2c_dev->dev, "S clear isr: AST_I2CD_INTR_STS_TX_ACK = %x\n",sts);
-				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_TX_ACK, I2C_INTR_STS_REG);		   
+				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_TX_ACK, I2C_INTR_STS_REG);
 			} else {
 				dev_dbg(i2c_dev->dev, "M clear isr: AST_I2CD_INTR_STS_TX_ACK = %x\n",sts);
 				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_TX_ACK, I2C_INTR_STS_REG);
@@ -1280,9 +1314,17 @@ static irqreturn_t i2c_ast_handler(int this_irq, void *dev_id)
 					ast_i2c_write(i2c_dev, ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
 										AST_I2CD_TX_ACK_INTR_EN, I2C_INTR_CTRL_REG);
 					ast_i2c_master_xfer_done(i2c_dev);
-					
+
 				} else {
-					printk("TODO ...\n");
+					printk("ast_i2c:  TX_ACK | NORMAL_STOP;  xfer_last %d\n", i2c_dev->xfer_last);
+					ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_TX_ACK | AST_I2CD_INTR_STS_NORMAL_STOP, I2C_INTR_STS_REG);
+					uint32_t new_val = ast_i2c_read(i2c_dev,I2C_INTR_CTRL_REG) |
+						        	AST_I2CD_NORMAL_STOP_INTR_EN | 
+								AST_I2CD_TX_ACK_INTR_EN;
+					ast_i2c_write(i2c_dev, new_val, I2C_INTR_CTRL_REG);
+					//take care
+					i2c_dev->cmd_err |= AST_LOCKUP_DETECTED;
+					complete(&i2c_dev->cmd_complete);
 				}
 			break;
 
@@ -1291,8 +1333,8 @@ static irqreturn_t i2c_ast_handler(int this_irq, void *dev_id)
 				i2c_dev->slave_event = I2C_SLAVE_EVENT_NACK;
 				ast_i2c_slave_xfer_done(i2c_dev);
 				dev_dbg(i2c_dev->dev, "S clear isr: AST_I2CD_INTR_STS_TX_NAK = %x\n",sts);
-				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_TX_NAK, I2C_INTR_STS_REG); 
-				
+				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_TX_NAK, I2C_INTR_STS_REG);
+
 			} else {
 				dev_dbg(i2c_dev->dev, "M clear isr: AST_I2CD_INTR_STS_TX_NAK = %x\n",sts);
 				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_TX_NAK, I2C_INTR_STS_REG);
@@ -1310,7 +1352,7 @@ static irqreturn_t i2c_ast_handler(int this_irq, void *dev_id)
 		case AST_I2CD_INTR_STS_TX_NAK | AST_I2CD_INTR_STS_NORMAL_STOP:
 			if(i2c_dev->slave_operation == 1) {
 				printk("SLAVE TODO .... \n");
-				
+
 			} else {
 				dev_dbg(i2c_dev->dev, "M clear isr: AST_I2CD_INTR_STS_TX_NAK| AST_I2CD_INTR_STS_NORMAL_STOP = %x\n",sts);
 				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_TX_NAK | AST_I2CD_INTR_STS_NORMAL_STOP, I2C_INTR_STS_REG);
@@ -1320,47 +1362,47 @@ static irqreturn_t i2c_ast_handler(int this_irq, void *dev_id)
 			}
 			break;
 
-		//Issue : Workaround for I2C slave mode 
+		//Issue : Workaround for I2C slave mode
 		case AST_I2CD_INTR_STS_TX_NAK | AST_I2CD_INTR_STS_SLAVE_MATCH:
 			if(i2c_dev->slave_operation == 1) {
 				i2c_dev->slave_event = I2C_SLAVE_EVENT_NACK;
 				ast_i2c_slave_xfer_done(i2c_dev);
 				ast_i2c_slave_addr_match(i2c_dev);
-				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_TX_NAK | AST_I2CD_INTR_STS_SLAVE_MATCH , I2C_INTR_STS_REG); 
+				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_TX_NAK | AST_I2CD_INTR_STS_SLAVE_MATCH , I2C_INTR_STS_REG);
 			} else {
 				printk("ERROR !!!!\n");
 			}
 			break;
 		case AST_I2CD_INTR_STS_RX_DOWN | AST_I2CD_INTR_STS_SLAVE_MATCH:
 			ast_i2c_slave_addr_match(i2c_dev);
-			dev_dbg(i2c_dev->dev, "S clear isr: AST_I2CD_INTR_STS_RX_DOWN | AST_I2CD_INTR_STS_SLAVE_MATCH = %x\n",sts);	
+			dev_dbg(i2c_dev->dev, "S clear isr: AST_I2CD_INTR_STS_RX_DOWN | AST_I2CD_INTR_STS_SLAVE_MATCH = %x\n",sts);
 			ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_RX_DOWN | AST_I2CD_INTR_STS_SLAVE_MATCH, I2C_INTR_STS_REG);
 			break;
-			
+
 		case AST_I2CD_INTR_STS_RX_DOWN:
 			if(i2c_dev->slave_operation == 1) {
 				i2c_dev->slave_event = I2C_SLAVE_EVENT_WRITE;
 				ast_i2c_slave_xfer_done(i2c_dev);
 				dev_dbg(i2c_dev->dev, "S clear isr: AST_I2CD_INTR_STS_RX_DOWN = %x\n",sts);
-				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_RX_DOWN, I2C_INTR_STS_REG);					
+				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_RX_DOWN, I2C_INTR_STS_REG);
 			} else {
 				dev_dbg(i2c_dev->dev, "M clear isr: AST_I2CD_INTR_STS_RX_DOWN = %x\n",sts);
 				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_RX_DOWN, I2C_INTR_STS_REG);
 				ast_i2c_master_xfer_done(i2c_dev);
-				
+
 			}
 			break;
-			
+
 		case AST_I2CD_INTR_STS_NORMAL_STOP:
 			if(i2c_dev->slave_operation == 1) {
 				i2c_dev->slave_event = I2C_SLAVE_EVENT_STOP;
 				ast_i2c_slave_xfer_done(i2c_dev);
 				dev_dbg(i2c_dev->dev, "S clear isr: AST_I2CD_INTR_STS_NORMAL_STOP = %x\n",sts);
-				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_NORMAL_STOP, I2C_INTR_STS_REG);					
+				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_NORMAL_STOP, I2C_INTR_STS_REG);
 				dev_dbg(i2c_dev->dev, "state [%x] \n",i2c_dev->state);
-			} else {							
+			} else {
 				dev_dbg(i2c_dev->dev, "M clear isr: AST_I2CD_INTR_STS_NORMAL_STOP = %x\n",sts);
-				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_NORMAL_STOP, I2C_INTR_STS_REG);			
+				ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_NORMAL_STOP, I2C_INTR_STS_REG);
 				i2c_dev->cmd_err |= AST_I2CD_INTR_STS_NORMAL_STOP;
 				complete(&i2c_dev->cmd_complete);
 			}
@@ -1380,24 +1422,24 @@ static irqreturn_t i2c_ast_handler(int this_irq, void *dev_id)
 			dev_dbg(i2c_dev->dev, "M clear isr: AST_I2CD_INTR_STS_ARBIT_LOSS = %x\n",sts);
 			ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_ARBIT_LOSS, I2C_INTR_STS_REG);
 			i2c_dev->cmd_err |= AST_I2CD_INTR_STS_ARBIT_LOSS;
-			complete(&i2c_dev->cmd_complete);					
+			complete(&i2c_dev->cmd_complete);
 			break;
 		case AST_I2CD_INTR_STS_SCL_TO:
 			i2c_dev->cmd_err |= AST_I2CD_INTR_STS_SCL_TO;
-			complete(&i2c_dev->cmd_complete);					
-			
+			complete(&i2c_dev->cmd_complete);
+
 			break;
  		case AST_I2CD_INTR_STS_GCALL_ADDR:
 			i2c_dev->cmd_err |= AST_I2CD_INTR_STS_GCALL_ADDR;
-			complete(&i2c_dev->cmd_complete);					
+			complete(&i2c_dev->cmd_complete);
 
 			break;
 		case AST_I2CD_INTR_STS_SMBUS_DEF_ADDR:
 			break;
 		case AST_I2CD_INTR_STS_SMBUS_DEV_ALT:
-			
+
 			break;
-			
+
 		case AST_I2CD_INTR_STS_SMBUS_ARP_ADDR:
 			break;
 		case AST_I2CD_INTR_STS_SDA_DL_TO:
@@ -1405,25 +1447,50 @@ static irqreturn_t i2c_ast_handler(int this_irq, void *dev_id)
 		case AST_I2CD_INTR_STS_BUS_RECOVER:
 			dev_dbg(i2c_dev->dev, "M clear isr: AST_I2CD_INTR_STS_BUS_RECOVER= %x\n",sts);
 			ast_i2c_write(i2c_dev, AST_I2CD_INTR_STS_BUS_RECOVER, I2C_INTR_STS_REG);
-			complete(&i2c_dev->cmd_complete);				
+			complete(&i2c_dev->cmd_complete);
 			break;
 		default:
-			if(sts)
-				printk("GR %x : No one care : %x, bus_id %d\n",i2c_dev->ast_i2c_data->reg_gr, sts, i2c_dev->bus_id);
-			return IRQ_NONE;
+      //TODO: Clearing this interrupt for now, but needs to cleanup this ISR function
+			ast_i2c_write(i2c_dev, sts, I2C_INTR_STS_REG);
+
+      // Handle Arbitration Loss
+      if (sts & AST_I2CD_INTR_STS_ARBIT_LOSS) {
+        i2c_dev->cmd_err |= AST_I2CD_INTR_STS_ARBIT_LOSS;
+        complete(&i2c_dev->cmd_complete);
+        sts &= (~AST_I2CD_INTR_STS_ARBIT_LOSS);
+      }
+
+      // Handle the write transaction ACK
+      if (sts & AST_I2CD_INTR_STS_TX_ACK) {
+        ast_i2c_master_xfer_done(i2c_dev);
+        complete(&i2c_dev->cmd_complete);
+        sts &= (~AST_I2CD_INTR_STS_TX_ACK);
+      }
+
+      // Handle the Slave address match
+      if (sts & AST_I2CD_INTR_STS_SLAVE_MATCH) {
+        ast_i2c_slave_addr_match(i2c_dev);
+        sts &= (~AST_I2CD_INTR_STS_SLAVE_MATCH);
+      }
+
+      // TODO: Debug print for any unhandled condition
+			if(sts) {
+				printk("GR %x : Status : %x, bus_id %d\n",i2c_dev->ast_i2c_data->reg_gr, sts, i2c_dev->bus_id);
+      }
+
+			return IRQ_HANDLED;
 	}
 
 	return IRQ_HANDLED;
-
 }
 
 static int ast_i2c_do_msgs_xfer(struct ast_i2c_dev *i2c_dev, struct i2c_msg *msgs, int num)
 {
 	int i;
-	int ret = 1;	
+	int ret = 1;
 	unsigned long flags;
 
-	spin_lock_irqsave(&g_master_lock, flags);
+	spin_lock_irqsave(&i2c_dev->master_lock, flags);
 
 	//request
 	if(i2c_dev->ast_i2c_data->master_dma == BYTE_MODE)
@@ -1433,7 +1500,7 @@ static int ast_i2c_do_msgs_xfer(struct ast_i2c_dev *i2c_dev, struct i2c_msg *msg
 	else {
 		if(i2c_dev->ast_i2c_data->request_pool_buff_page(&(i2c_dev->req_page)) == 0)
 			i2c_dev->do_master_xfer = ast_i2c_do_pool_xfer;
-		else								
+		else
 			i2c_dev->do_master_xfer = ast_i2c_do_byte_xfer;
 	}
 
@@ -1458,12 +1525,12 @@ static int ast_i2c_do_msgs_xfer(struct ast_i2c_dev *i2c_dev, struct i2c_msg *msg
 
 		i2c_dev->do_master_xfer(i2c_dev);
 
-		spin_unlock_irqrestore(&g_master_lock, flags);
+		spin_unlock_irqrestore(&i2c_dev->master_lock, flags);
 
 		ret = wait_for_completion_interruptible_timeout(&i2c_dev->cmd_complete,
 													   i2c_dev->adap.timeout*HZ);
-	
-		spin_lock_irqsave(&g_master_lock, flags);
+
+		spin_lock_irqsave(&i2c_dev->master_lock, flags);
 		i2c_dev->master_msgs = NULL;
 
 		if (ret == 0) {
@@ -1471,25 +1538,30 @@ static int ast_i2c_do_msgs_xfer(struct ast_i2c_dev *i2c_dev, struct i2c_msg *msg
 			i2c_dev->state = (ast_i2c_read(i2c_dev,I2C_CMD_REG) >> 19) & 0xf;
 //			printk("sts [%x], isr sts [%x] \n",i2c_dev->state, ast_i2c_read(i2c_dev,I2C_INTR_STS_REG));
 			ret = -ETIMEDOUT;
-			spin_unlock_irqrestore(&g_master_lock, flags);
+			spin_unlock_irqrestore(&i2c_dev->master_lock, flags);
 			goto stop;
 		}
-		
+
 		if(i2c_dev->cmd_err != 0 &&
 		   i2c_dev->cmd_err != AST_I2CD_INTR_STS_NORMAL_STOP) {
+			if (i2c_dev->cmd_err & AST_LOCKUP_DETECTED) {
+				printk("ast-i2c:  error got unexpected STOP\n");
+				// reset the bus
+				ast_i2c_bus_error_recover(i2c_dev);
+			}
 			ret = -EAGAIN;
-			spin_unlock_irqrestore(&g_master_lock, flags);
+			spin_unlock_irqrestore(&i2c_dev->master_lock, flags);
 			goto stop;
 		}
 	}
 
-	spin_unlock_irqrestore(&g_master_lock, flags);
+	spin_unlock_irqrestore(&i2c_dev->master_lock, flags);
 
 	if(i2c_dev->cmd_err == 0 ||
 	   i2c_dev->cmd_err == AST_I2CD_INTR_STS_NORMAL_STOP) {
 		ret = num;
 		goto out;
-		
+
 	}
 stop:
 	init_completion(&i2c_dev->cmd_complete);
@@ -1503,8 +1575,8 @@ out:
 	//Free ..
 	if(i2c_dev->master_xfer_mode == BUFF_XFER) {
 		i2c_dev->ast_i2c_data->free_pool_buff_page(i2c_dev->req_page);
-		
-	} 
+
+	}
 	dev_dbg(i2c_dev->dev, "end xfer ret = %d, xfer mode[%d]\n",ret, i2c_dev->master_xfer_mode);
 	return ret;
 
@@ -1521,7 +1593,7 @@ static int ast_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 	/*
 	 * Wait for the bus to become free.
 	 */
-	
+
 	ret = ast_i2c_wait_bus_not_busy(i2c_dev);
 	if (ret) {
 		dev_err(&i2c_dev->adap.dev, "i2c_ast: timeout waiting for bus free\n");
@@ -1536,7 +1608,7 @@ static int ast_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 		dev_dbg(&adap->dev, "Retrying transmission [%d]\n",i);
 		udelay(100);
 	}
-		
+
 	ret = -EREMOTEIO;
 out:
 
@@ -1550,9 +1622,9 @@ static u32 ast_i2c_functionality(struct i2c_adapter *adap)
 
 static const struct i2c_algorithm i2c_ast_algorithm = {
 	.master_xfer	= ast_i2c_xfer,
-#ifdef CONFIG_AST_I2C_SLAVE_RDWR		
+#ifdef CONFIG_AST_I2C_SLAVE_RDWR
 	.slave_xfer		= ast_i2c_slave_xfer,
-#endif	
+#endif
 	.functionality	= ast_i2c_functionality,
 };
 
@@ -1572,23 +1644,23 @@ static int ast_i2c_probe(struct platform_device *pdev)
 
 	i2c_dev->ast_i2c_data = pdev->dev.platform_data;
 	if(i2c_dev->ast_i2c_data->master_dma == BUFF_MODE) {
-		dev_dbg(&pdev->dev, "use buffer pool mode 256\n");	
-		
+		dev_dbg(&pdev->dev, "use buffer pool mode 256\n");
+
 	} else if ((i2c_dev->ast_i2c_data->master_dma == DMA_MODE) || (i2c_dev->ast_i2c_data->slave_dma == DMA_MODE)) {
-		dev_dbg(&pdev->dev, "use dma mode \n");	
+		dev_dbg(&pdev->dev, "use dma mode \n");
 		if (!i2c_dev->dma_buf) {
 			i2c_dev->dma_buf = dma_alloc_coherent(NULL, AST_I2C_DMA_SIZE, &i2c_dev->dma_addr, GFP_KERNEL);
 			if (!i2c_dev->dma_buf) {
 				printk("unable to allocate tx Buffer memory\n");
 				ret = -ENOMEM;
-				goto err_no_dma;	
+				goto err_no_dma;
 			}
 			if(i2c_dev->dma_addr%4 !=0) {
 				printk("not 4 byte boundary \n");
 				ret = -ENOMEM;
-				goto err_no_dma;	
-			}				
-//			printk("dma_buf = [0x%x] dma_addr = [0x%x], please check 4byte boundary \n",i2c_dev->dma_buf,i2c_dev->dma_addr);	
+				goto err_no_dma;
+			}
+//			printk("dma_buf = [0x%x] dma_addr = [0x%x], please check 4byte boundary \n",i2c_dev->dma_buf,i2c_dev->dma_addr);
 			memset (i2c_dev->dma_buf, 0, AST_I2C_DMA_SIZE);
 		}
 
@@ -1596,7 +1668,7 @@ static int ast_i2c_probe(struct platform_device *pdev)
 		//master_mode 0: use byte mode
 		dev_dbg(&pdev->dev, "use default byte mode \n");
 	}
-		
+
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (NULL == res) {
 		dev_err(&pdev->dev, "cannot get IORESOURCE_MEM\n");
@@ -1628,11 +1700,11 @@ static int ast_i2c_probe(struct platform_device *pdev)
 	if(i2c_dev->irq == IRQ_C0_I2C) {
 		i2c_dev->bus_id = pdev->id - NUM_BUS;
 		dev_dbg(&pdev->dev, "C0 :: pdev->id %d , i2c_dev->bus_id = %d, i2c_dev->irq =%d\n",pdev->id, i2c_dev->bus_id,i2c_dev->irq);
-#if (CONFIG_AST1070_NR >= 2)		
+#if (CONFIG_AST1070_NR >= 2)
 	} else if(i2c_dev->irq == IRQ_C1_I2C) {
 		i2c_dev->bus_id = pdev->id - (NUM_BUS + 8);
-		dev_dbg(&pdev->dev, "C1 :: pdev->id %d , i2c_dev->bus_id = %d, i2c_dev->irq =%d\n",pdev->id, i2c_dev->bus_id,i2c_dev->irq);			
-#endif		
+		dev_dbg(&pdev->dev, "C1 :: pdev->id %d , i2c_dev->bus_id = %d, i2c_dev->irq =%d\n",pdev->id, i2c_dev->bus_id,i2c_dev->irq);
+#endif
 	} else {
 		i2c_dev->bus_id = pdev->id;
 		dev_dbg(&pdev->dev, "AST pdev->id %d , i2c_dev->bus_id = %d, i2c_dev->irq =%d\n",pdev->id, i2c_dev->bus_id,i2c_dev->irq);
@@ -1644,13 +1716,13 @@ static int ast_i2c_probe(struct platform_device *pdev)
  	/* Initialize the I2C adapter */
 	i2c_dev->adap.owner   = THIS_MODULE;
 //TODO
-	i2c_dev->adap.retries = 0;	
+	i2c_dev->adap.retries = 0;
 
-//	i2c_dev->adap.retries = 3;	
+//	i2c_dev->adap.retries = 3;
 
-	i2c_dev->adap.timeout = 5; 
+	i2c_dev->adap.timeout = 5;
 
-	i2c_dev->master_xfer_mode = BYTE_XFER;	
+	i2c_dev->master_xfer_mode = BYTE_XFER;
 
 	/*
 	 * If "pdev->id" is negative we consider it as zero.
@@ -1662,7 +1734,7 @@ static int ast_i2c_probe(struct platform_device *pdev)
 		 i2c_dev->adap.nr);
 
 	i2c_dev->slave_operation = 0;
-	i2c_dev->blk_r_flag = 0; 
+	i2c_dev->blk_r_flag = 0;
 	i2c_dev->adap.algo = &i2c_ast_algorithm;
 
 	ast_i2c_dev_init(i2c_dev);
@@ -1674,8 +1746,11 @@ static int ast_i2c_probe(struct platform_device *pdev)
 		goto ereqirq;
 	}
 
+  spin_lock_init(&i2c_dev->master_lock);
+
 #ifdef CONFIG_AST_I2C_SLAVE_RDWR
 	ast_i2c_slave_buff_init(i2c_dev);
+  spin_lock_init(&i2c_dev->slave_rx_lock);
 #endif
 
 	i2c_dev->adap.algo_data = i2c_dev;
@@ -1718,7 +1793,7 @@ static int ast_i2c_remove(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, NULL);
 	i2c_del_adapter(&i2c_dev->adap);
-	
+
 	free_irq(i2c_dev->irq, i2c_dev);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -1742,7 +1817,7 @@ static int ast_i2c_resume(struct platform_device *pdev)
 {
 	//TODO
 //	struct ast_i2c_dev *i2c_dev = platform_get_drvdata(pdev);
-	//Should reset i2c ??? 
+	//Should reset i2c ???
 	return 0;
 }
 #else
diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c
index c8e3cf6..06d9042 100644
--- a/drivers/i2c/i2c-core.c
+++ b/drivers/i2c/i2c-core.c
@@ -1064,7 +1064,7 @@ int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num)
 EXPORT_SYMBOL(i2c_transfer);
 
 #ifdef CONFIG_AST_I2C_SLAVE_RDWR
-int i2c_slave_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs)
+int i2c_slave_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 {
 	unsigned long orig_jiffies;
 	int ret, try;
@@ -1075,9 +1075,18 @@ int i2c_slave_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs)
 			"len=%d\n", (msgs->flags & I2C_S_RD)
 			? 'R' : 'W', msgs->addr, msgs->len);
 #endif
-		i2c_lock_adapter(adap);
+    if (in_atomic() || irqs_disabled()) {
+      ret = mutex_trylock(&adap->bus_lock);
+      if (!ret)
+        /* I2C activity is ongoing. */
+        return -EAGAIN;
+    } else {
+      mutex_lock_nested(&adap->bus_lock, adap->level);
+    }
+
 		ret = adap->algo->slave_xfer(adap, msgs);
-		i2c_unlock_adapter(adap);
+
+    mutex_unlock(&adap->bus_lock);
 
 		return ret;
 	} else {
diff --git a/drivers/i2c/i2c-dev.c b/drivers/i2c/i2c-dev.c
index 07f393d..82f2c7c 100644
--- a/drivers/i2c/i2c-dev.c
+++ b/drivers/i2c/i2c-dev.c
@@ -38,7 +38,7 @@
 #include <asm/uaccess.h>
 
 #ifdef CONFIG_AST_I2C_SLAVE_RDWR
-#include <asm/arch/ast_i2c.h>
+#include <plat/ast_i2c.h>
 #endif
 
 static struct i2c_driver i2cdev_driver;
@@ -310,6 +310,113 @@ static noinline int i2cdev_ioctl_rdrw(struct i2c_client *client,
 	return res;
 }
 
+static noinline int i2cdev_ioctl_slave_rdrw(struct i2c_client *client,
+    unsigned long arg)
+{
+  struct i2c_rdwr_ioctl_data rdwr_arg;
+  struct i2c_msg *rdwr_pa;
+  u8 __user **data_ptrs;
+  int i, res;
+
+  if (copy_from_user(&rdwr_arg,
+         (struct i2c_rdwr_ioctl_data __user *)arg,
+         sizeof(rdwr_arg)))
+    return -EFAULT;
+
+  /* Put an arbitrary limit on the number of messages that can
+   * be sent at once */
+  if (rdwr_arg.nmsgs > I2C_RDRW_IOCTL_MAX_MSGS)
+    return -EINVAL;
+
+  rdwr_pa = (struct i2c_msg *)
+    kmalloc(rdwr_arg.nmsgs * sizeof(struct i2c_msg),
+    GFP_KERNEL);
+  if (!rdwr_pa)
+    return -ENOMEM;
+
+  if (copy_from_user(rdwr_pa, rdwr_arg.msgs,
+         rdwr_arg.nmsgs * sizeof(struct i2c_msg))) {
+    kfree(rdwr_pa);
+    return -EFAULT;
+  }
+
+  data_ptrs = kmalloc(rdwr_arg.nmsgs * sizeof(u8 __user *), GFP_KERNEL);
+  if (data_ptrs == NULL) {
+    kfree(rdwr_pa);
+    return -ENOMEM;
+  }
+
+  res = 0;
+  for (i = 0; i < rdwr_arg.nmsgs; i++) {
+    /* Limit the size of the message to a sane amount;
+     * and don't let length change either. */
+    if (rdwr_pa[i].len > 8192) {
+      res = -EINVAL;
+      break;
+    }
+    data_ptrs[i] = (u8 __user *)rdwr_pa[i].buf;
+    rdwr_pa[i].buf = kmalloc(rdwr_pa[i].len, GFP_KERNEL);
+    if (rdwr_pa[i].buf == NULL) {
+      res = -ENOMEM;
+      break;
+    }
+    if (copy_from_user(rdwr_pa[i].buf, data_ptrs[i],
+           rdwr_pa[i].len)) {
+        ++i; /* Needs to be kfreed too */
+        res = -EFAULT;
+      break;
+    }
+
+    /* From Linux 3.5: */
+    /*
+     * If the message length is received from the slave (similar
+     * to SMBus block read), we must ensure that the buffer will
+     * be large enough to cope with a message length of
+     * I2C_SMBUS_BLOCK_MAX as this is the maximum underlying bus
+     * drivers allow. The first byte in the buffer must be
+     * pre-filled with the number of extra bytes, which must be
+     * at least one to hold the message length, but can be
+     * greater (for example to account for a checksum byte at
+     * the end of the message.)
+     */
+         if (rdwr_pa[i].flags & I2C_M_RECV_LEN) {
+           if (!(rdwr_pa[i].flags & I2C_M_RD) ||
+         rdwr_pa[i].buf[0] < 1 ||
+         rdwr_pa[i].len < rdwr_pa[i].buf[0] +
+              I2C_SMBUS_BLOCK_MAX) {
+             res = -EINVAL;
+             break;
+           }
+
+           rdwr_pa[i].len = rdwr_pa[i].buf[0];
+         }
+
+  }
+  if (res < 0) {
+    int j;
+    for (j = 0; j < i; ++j)
+      kfree(rdwr_pa[j].buf);
+    kfree(data_ptrs);
+    kfree(rdwr_pa);
+    return res;
+  }
+
+  res = i2c_slave_transfer(client->adapter, rdwr_pa, rdwr_arg.nmsgs);
+  while (i-- > 0) {
+    if (res >= 0 ) {
+      if (copy_to_user(data_ptrs[i], rdwr_pa[i].buf,
+           rdwr_pa[i].len))
+        res = -EFAULT;
+
+      rdwr_arg.msgs[i].len = rdwr_pa[i].len;
+    }
+    kfree(rdwr_pa[i].buf);
+  }
+  kfree(data_ptrs);
+  kfree(rdwr_pa);
+  return res;
+}
+
 static noinline int i2cdev_ioctl_smbus(struct i2c_client *client,
 		unsigned long arg)
 {
@@ -448,8 +555,8 @@ static long i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 #ifdef CONFIG_AST_I2C_SLAVE_RDWR
 	case I2C_SLAVE_RDWR:
-		return i2cdev_ioctl_slave_rdrw(client->adapter, (struct i2c_msg __user *)arg);
-#endif		
+		return i2cdev_ioctl_slave_rdrw(client, arg);
+#endif
 
 	case I2C_SMBUS:
 		return i2cdev_ioctl_smbus(client, arg);
diff --git a/drivers/net/ftgmac100_26.c b/drivers/net/ftgmac100_26.c
index fdc77fc..3a5d796 100644
--- a/drivers/net/ftgmac100_26.c
+++ b/drivers/net/ftgmac100_26.c
@@ -1,16 +1,16 @@
 /********************************************************************************
 * File Name     : ftgmac100_26.c
-* 
+*
 * Copyright (C) 2012-2020  ASPEED Technology Inc.
-* This program is free software; you can redistribute it and/or modify 
-* it under the terms of the GNU General Public License as published by the Free Software Foundation; 
-* either version 2 of the License, or (at your option) any later version. 
-* This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY; 
-* without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. 
-* You should have received a copy of the GNU General Public License 
-* along with this program; if not, write to the Free Software 
-* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by the Free Software Foundation;
+* either version 2 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 ********************************************************************************/
 //-----------------------------------------------------------------------------
 //  "ASPEED MAC Driver, (Linux Kernel 2.6.15.7) 10/02/07 - by ASPEED\n"
@@ -76,7 +76,7 @@
 //AST2300 SDK 0.14
 //19.09/13/2010 - by river@aspeed
 //   Support Realtek RTL8201EL 10/100M PHY
-//AST2400 
+//AST2400
 //20.06/25/2013 - by CC@aspeed
 //   Support BCM54612E 10/100/1000M PHY
 //-----------------------------------------------------------------------------
@@ -120,7 +120,12 @@
 #err "Not define include for GMAC"
 #endif
 
+#ifdef CONFIG_WEDGE100
+#define PHY_DEFAULT_ADDR 0x18
+#else
+/* wedge */
 #define PHY_DEFAULT_ADDR 0x1F
+#endif
 
 /*------------------------------------------------------------------------
  .
@@ -172,7 +177,6 @@ static int ftgmac100_wait_to_send_packet(struct sk_buff * skb, struct net_device
 
 static volatile int trans_busy = 0;
 
-
 void ftgmac100_phy_rw_waiting(unsigned int ioaddr)
 {
 	unsigned int tmp;
@@ -255,6 +259,7 @@ static void getMacHwConfig( struct net_device* dev, struct AstMacHwConfig* out )
 
 //	out->macId   = dev->dev_id;
 //..	getMacAndPhy(dev, out);
+	out->phyAddr = PHY_DEFAULT_ADDR;
 	out->miiPhyId = 0;
 
 	// We assume the Clock Stop register does not disable the MAC1 or MAC2 clock
@@ -272,7 +277,7 @@ no_phy_access:
 			out->phyAddr = 1;
 		}
 #if 0
-		if (out->miiPhyId == 0x0362) { 
+		if (out->miiPhyId == 0x0362) {
 			out->phyAddr = 1;
 		}
 #endif
@@ -297,6 +302,902 @@ no_phy_access:
 	return;
 }
 
+// --------------------------------------------------------------------
+//  NCSI function
+// --------------------------------------------------------------------
+void NCSI_Struct_Initialize(struct net_device *dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long i;
+
+  for (i = 0; i < 6; i++) {
+    lp->NCSI_Request.DA[i] = 0xFF;
+    lp->NCSI_Respond.DA[i] = 0xFF;
+    lp->NCSI_Respond.SA[i] = 0xFF;
+    lp->NCSI_Request.SA[i] = dev->dev_addr[i];
+  }
+  lp->NCSI_Request.EtherType = 0xF888;
+  lp->NCSI_Request.MC_ID = 0;
+  lp->NCSI_Request.Header_Revision = 0x01;
+  lp->NCSI_Request.Reserved_1 = 0;
+  lp->NCSI_Request.Reserved_2 = 0;
+  lp->NCSI_Request.Reserved_3 = 0;
+  lp->NCSI_Respond.EtherType = 0xF888;
+  lp->NCSI_Respond.MC_ID = 0;
+  lp->NCSI_Respond.Header_Revision = 0x01;
+  lp->NCSI_Respond.Reserved_1 = 0;
+  lp->NCSI_Respond.Reserved_2 = 0;
+  lp->NCSI_Respond.Reserved_3 = 0;
+
+  lp->InstanceID = 0;
+  lp->Payload_Checksum = 0;
+  for (i = 0; i < 4; i++) {
+    lp->Payload_Pad[i] = 0;
+  }
+  for (i = 0; i < 64; i++) {
+    lp->Payload_Data[i] = 0;
+  }
+}
+
+void Calculate_Checksum(struct net_device * dev, unsigned char *buffer_base, int Length)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned int i, CheckSum = 0;
+  unsigned int Data, Data1;
+
+  for (i = 0; i < ((Length - 14) / 2); i++) {
+    Data = buffer_base[i * 2];
+    Data1 = buffer_base[i * 2 + 1];
+    CheckSum += ((Data << 8) + Data1);
+  }
+  lp->Payload_Checksum = (~(CheckSum) + 1); //2's complement
+//Inverse for insert into buffer
+  Data = (lp->Payload_Checksum & 0xFF000000) >> 24;
+  Data1 = (lp->Payload_Checksum & 0x000000FF) << 24;
+  lp->Payload_Checksum = (lp->Payload_Checksum & 0x00FFFF00) + Data + Data1;
+  Data = (lp->Payload_Checksum & 0x00FF0000) >> 8;
+  Data1 = (lp->Payload_Checksum & 0x0000FF00) << 8;
+  lp->Payload_Checksum = (lp->Payload_Checksum & 0xFF0000FF) + Data + Data1;
+}
+
+void copy_data (struct net_device * dev, struct sk_buff * skb, int Length)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+
+  memcpy ((unsigned char *)(skb->data + 30), &lp->Payload_Data, Length);
+  Calculate_Checksum(dev, skb->data + 14, 30 + Length);
+  memcpy ((unsigned char *)(skb->data + 30 + Length), &lp->Payload_Checksum, 4);
+}
+
+void NCSI_Rx (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long status, length, i = 0;
+  volatile RX_DESC *cur_desc;
+
+ncsi_rx:
+  i = 0;
+  cur_desc = &lp->rx_descs[lp->rx_idx];
+  do {
+    status = cur_desc->RXPKT_RDY;
+    i++;
+  } while (!(((status & RX_OWNBY_SOFTWARE) != 0) || (i >= NCSI_LOOP)));
+
+  if (i < NCSI_LOOP) {
+    if (cur_desc->LRS) {
+      length = cur_desc->VDBC;
+      unsigned char *tbuf = (unsigned char *)phys_to_virt(cur_desc->RXBUF_BADR);
+      if (length <= 128 && tbuf[12] == 0x88 && tbuf[13] == 0xF8) {
+        memcpy (&lp->NCSI_Respond, (unsigned char *)phys_to_virt(cur_desc->RXBUF_BADR), length);
+      } else {
+          printk("NCSI_RX: Skip len: %d, proto: %x:%x\n", length, tbuf[12], tbuf[13]);
+          lp->rx_descs[lp->rx_idx].RXPKT_RDY = RX_OWNBY_FTGMAC100;
+          lp->rx_idx = (lp->rx_idx+1)%RXDES_NUM;
+          goto ncsi_rx;
+      }
+
+    }
+    lp->rx_descs[lp->rx_idx].RXPKT_RDY = RX_OWNBY_FTGMAC100;
+    lp->rx_idx = (lp->rx_idx+1)%RXDES_NUM;
+  } else {
+    printk("NCSI_Rx: Failed\n");
+  }
+}
+
+void DeSelect_Package (struct net_device * dev, int Package_ID)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = DESELECT_PACKAGE;
+  Combined_Channel_ID = (Package_ID << 5) + 0x1F; //Internal Channel ID = 0x1F, 0x1F means all channel
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = 0;
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (DESELECT_PACKAGE | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+int Select_Package (struct net_device * dev, int Package_ID)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID, Found = 0;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = SELECT_PACKAGE;
+  Combined_Channel_ID = (Package_ID << 5) + 0x1F; //Internal Channel ID = 0x1F
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = (4 << 8);
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  lp->NCSI_Request.Payload_Length = 4;
+  memset ((void *)lp->Payload_Data, 0, 4);
+  lp->Payload_Data[3] = 1; //Arbitration Disable
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len = 30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (SELECT_PACKAGE | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    Found = 0;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+    Found = 1;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+
+    return Found;
+}
+
+
+void DeSelect_Active_Package (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = DESELECT_PACKAGE;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + 0x1F; //Internal Channel ID = 0x1F, 0x1F means all channel
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = 0;
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (DESELECT_PACKAGE | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+
+int Select_Active_Package (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID, Found = 0;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = SELECT_PACKAGE;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + 0x1F; //Internal Channel ID = 0x1F
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = (4 << 8);
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  lp->NCSI_Request.Payload_Length = 4;
+  memset ((void *)lp->Payload_Data, 0, 4);
+  lp->Payload_Data[3] = 1; //Arbitration Disable
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len = 30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (SELECT_PACKAGE | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+    Found = 0;
+  }
+  else {
+    lp->Retry = 0;
+    Found = 1;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+
+    return Found;
+}
+
+int Clear_Initial_State (struct net_device * dev, int Channel_ID)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID, Found = 0;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = CLEAR_INITIAL_STATE;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + Channel_ID; //Internal Channel ID = 0
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = 0;
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (CLEAR_INITIAL_STATE | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+    Found = 0;
+  }
+  else {
+    lp->Retry = 0;
+    Found = 1;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+
+    return Found;
+}
+
+void Get_Version_ID (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = GET_VERSION_ID;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = 0;
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (GET_VERSION_ID | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+void Get_Capabilities (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = GET_CAPABILITIES;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = 0;
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (GET_CAPABILITIES | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+    lp->NCSI_Cap.Capabilities_Flags = lp->NCSI_Respond.Payload_Data[0];
+    lp->NCSI_Cap.Broadcast_Packet_Filter_Capabilities = lp->NCSI_Respond.Payload_Data[1];
+    lp->NCSI_Cap.Multicast_Packet_Filter_Capabilities = lp->NCSI_Respond.Payload_Data[2];
+    lp->NCSI_Cap.Buffering_Capabilities = lp->NCSI_Respond.Payload_Data[3];
+    lp->NCSI_Cap.AEN_Control_Support = lp->NCSI_Respond.Payload_Data[4];
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+void Enable_AEN (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = AEN_ENABLE;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = (8 << 8);
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  lp->NCSI_Request.Payload_Length = 8;
+  lp->Payload_Data[3] = 0; //MC ID
+  lp->Payload_Data[7] = 1; //Link Status Change AEN
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (AEN_ENABLE | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+void Get_MAC_Address (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID, i;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = 0x50;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = (8 << 8);
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  lp->NCSI_Request.Payload_Length = 8;
+  lp->Payload_Data[0] = 0x00;
+  lp->Payload_Data[1] = 0x00;
+  lp->Payload_Data[2] = 0x81;
+  lp->Payload_Data[3] = 0x19;
+
+  lp->Payload_Data[4] = 0x00;
+  lp->Payload_Data[5] = 0x00;
+  lp->Payload_Data[6] = 0x1B;
+  lp->Payload_Data[7] = 0x00;
+
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (0x50 | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+
+  // Update MAC Address
+printk("NCSI: MAC  ");
+for (i = 0; i < 6; i++)
+  printk("%02X:", lp->NCSI_Respond.Payload_Data[12+i]);
+printk("\n");
+  memcpy(lp->NCSI_Request.SA, &lp->NCSI_Respond.Payload_Data[12], 6);
+  memcpy(dev->dev_addr, &lp->NCSI_Respond.Payload_Data[12], 6);
+
+	/* Update the MAC address */
+	ast_gmac_set_mac(lp, dev->dev_addr);
+}
+
+void Set_MAC_Affinity (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID, i;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = 0x50;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = (60 << 8);
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+
+  lp->NCSI_Request.Payload_Length = 60;
+  memset(lp->Payload_Data, 0x00, 60);
+  lp->Payload_Data[0] = 0x00;
+  lp->Payload_Data[1] = 0x00;
+  lp->Payload_Data[2] = 0x81;
+  lp->Payload_Data[3] = 0x19;
+
+  lp->Payload_Data[4] = 0x00;
+  lp->Payload_Data[5] = 0x01;
+  lp->Payload_Data[6] = 0x07;
+  lp->Payload_Data[7] = 0x00;
+
+  for (i = 0; i < 6; i++) {
+    lp->Payload_Data[8+i] = lp->NCSI_Request.SA[i];
+  }
+
+  lp->Payload_Data[14] = 0x09;
+
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (0x50 | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+void Enable_Set_MAC_Address (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID, i;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = SET_MAC_ADDRESS;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = (8 << 8);
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  lp->NCSI_Request.Payload_Length = 8;
+  for (i = 0; i < 6; i++) {
+    lp->Payload_Data[i] = lp->NCSI_Request.SA[i];
+  }
+  lp->Payload_Data[6] = 1; //MAC Address Num = 1 --> address filter 1, fixed in sample code
+  lp->Payload_Data[7] = UNICAST + 0 + ENABLE_MAC_ADDRESS_FILTER; //AT + Reserved + E
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (SET_MAC_ADDRESS | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+void Enable_Broadcast_Filter (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = ENABLE_BROADCAST_FILTERING;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = (4 << 8);
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  lp->NCSI_Request.Payload_Length = 4;
+  memset ((void *)lp->Payload_Data, 0, 4);
+        lp->Payload_Data[3] = 0x1; //ARP, DHCP, NetBIOS
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (ENABLE_BROADCAST_FILTERING | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+void Disable_VLAN (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = DISABLE_VLAN;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = 0;
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (DISABLE_VLAN | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+void Get_Parameters (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = GET_PARAMETERS;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = 0;
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (GET_PARAMETERS | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+//    printk ("Retry: Command = %x, Response_Code = %x, Resonpd.Command = %x, IID = %x, lp->InstanceID = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code, lp->NCSI_Respond.Command, lp->NCSI_Respond.IID, lp->InstanceID);
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+    lp->NCSI_Cap.Capabilities_Flags = lp->NCSI_Respond.Payload_Data[0];
+    lp->NCSI_Cap.Broadcast_Packet_Filter_Capabilities = lp->NCSI_Respond.Payload_Data[1];
+    lp->NCSI_Cap.Multicast_Packet_Filter_Capabilities = lp->NCSI_Respond.Payload_Data[2];
+    lp->NCSI_Cap.Buffering_Capabilities = lp->NCSI_Respond.Payload_Data[3];
+    lp->NCSI_Cap.AEN_Control_Support = lp->NCSI_Respond.Payload_Data[4];
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+void Enable_Network_TX (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = ENABLE_CHANNEL_NETWORK_TX;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = 0;
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (ENABLE_CHANNEL_NETWORK_TX | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+void Disable_Network_TX (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = DISABLE_CHANNEL_NETWORK_TX;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = 0;
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + (lp->NCSI_Request.Payload_Length % 4) + 8;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (DISABLE_CHANNEL_NETWORK_TX | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+void Enable_Channel (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = ENABLE_CHANNEL;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = 0;
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (ENABLE_CHANNEL | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+void Disable_Channel (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = DISABLE_CHANNEL;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = (4 << 8);
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  lp->NCSI_Request.Payload_Length = 4;
+  memset ((void *)lp->Payload_Data, 0, 4);
+        lp->Payload_Data[3] = 0x1; //ALD
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (DISABLE_CHANNEL | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
+
+int Get_Link_Status (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = GET_LINK_STATUS;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = 0;
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (GET_LINK_STATUS | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+    if (lp->NCSI_Respond.Payload_Data[3] & 0x40) {
+      return (lp->NCSI_Respond.Payload_Data[3] & 0x01); //Link Up or Not
+    }
+    else {
+      return 0; //Auto Negotiate did not finish
+    }
+}
+
+void Set_Link (struct net_device * dev)
+{
+  struct ftgmac100_priv *lp = (struct ftgmac100_priv *)dev->priv;
+  unsigned long Combined_Channel_ID;
+  struct sk_buff * skb;
+
+    do {
+  skb = dev_alloc_skb (TX_BUF_SIZE + 16);
+  memset(skb->data, 0, TX_BUF_SIZE + 16);
+//TX
+  lp->InstanceID++;
+  lp->NCSI_Request.IID = lp->InstanceID;
+  lp->NCSI_Request.Command = SET_LINK;
+  Combined_Channel_ID = (lp->NCSI_Cap.Package_ID << 5) + lp->NCSI_Cap.Channel_ID;
+  lp->NCSI_Request.Channel_ID = Combined_Channel_ID;
+  lp->NCSI_Request.Payload_Length = (8 << 8);
+  memcpy ((unsigned char *)skb->data, &lp->NCSI_Request, 30);
+  lp->NCSI_Request.Payload_Length = 8;
+  memset ((void *)lp->Payload_Data, 0, 8);
+  lp->Payload_Data[2] = 0x02; //full duplex
+  lp->Payload_Data[3] = 0x04; //100M, auto-disable
+  copy_data (dev, skb, lp->NCSI_Request.Payload_Length);
+  skb->len =  30 + lp->NCSI_Request.Payload_Length + 4;
+  ftgmac100_wait_to_send_packet (skb, dev);
+//RX
+  NCSI_Rx(dev);
+  if (((lp->NCSI_Respond.IID != lp->InstanceID) || (lp->NCSI_Respond.Command != (SET_LINK | 0x80)) || (lp->NCSI_Respond.Response_Code != COMMAND_COMPLETED)) && (lp->Retry != RETRY_COUNT)) {
+    printk ("Retry: Command = %x, Response_Code = %x\n", lp->NCSI_Request.Command, lp->NCSI_Respond.Response_Code);
+    printk ("IID: %x:%x, Command: %x:%x\n", lp->InstanceID, lp->NCSI_Respond.IID, lp->NCSI_Request.Command, lp->NCSI_Respond.Command);
+    lp->Retry++;
+    lp->InstanceID--;
+  }
+  else {
+    lp->Retry = 0;
+  }
+    } while ((lp->Retry != 0) && (lp->Retry <= RETRY_COUNT));
+    lp->Retry = 0;
+}
 
 static void ftgmac100_reset( struct net_device* dev )
 {
@@ -308,64 +1209,71 @@ static void ftgmac100_reset( struct net_device* dev )
 	PRINTK("%s:ftgmac100_reset, phyAddr=0x%x, miiPhyId=0x%04x_%04x\n",
 	       dev->name, ids->phyAddr, (ids->miiPhyId >> 16), (ids->miiPhyId & 0xffff));
 
-	if (ids->miiPhyId < 1)
-	    return;	// Cannot access MAC registers
-
-	// Check the link speed and duplex.
-	// They are not valid until auto-neg is resolved, which is reg.1 bit[5],
-	// or the link is up, which is reg.1 bit[2].
-
-	if (ids->phyAddr < 0xff)
-	    tmp = ftgmac100_read_phy_register(dev->base_addr, ids->phyAddr, 0x1);
-	else tmp = 0;
-
-	if (0==(tmp & (1u<<5 | 1u<<2)) || ids->phyAddr >= 0xff) {
-	    // No PHY chip, or link has not negotiated.
-	    speed  = PHY_SPEED_100M;
-	    duplex = 1;
-	    netif_carrier_off(dev);
-	}
-	else if (((ids->miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8201EL)) {
-	    tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x00);
-	    duplex = (tmp & 0x0100) ? 1 : 0;
-	    speed  = (tmp & 0x2000) ? PHY_SPEED_100M : PHY_SPEED_10M;
-	}
-	else if (((ids->miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_MARVELL) || 
-		 ((ids->miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8211)) {
-	    // Use reg.17_0.bit[15:13] for {speed[1:0], duplex}.
-	    tmp    = ftgmac100_read_phy_register(dev->base_addr, ids->phyAddr, 0x11);
-	    duplex = (tmp & PHY_DUPLEX_mask)>>13;
-	    speed  = (tmp & PHY_SPEED_mask)>>14;
-	    netif_carrier_on(dev);
-	}
-	else if (priv->ids.miiPhyId == PHYID_BCM54612E
-		 || priv->ids.miiPhyId == PHYID_BCM54616S) { 
-       // Get link status
-        // First Switch shadow register selector
-        ftgmac100_write_phy_register(dev->base_addr, priv->ids.phyAddr, 0x1C, 0x2000);
-        tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x1C);
-        if ( (tmp & 0x0080) == 0x0080 )
-            duplex = 0;
-        else
-            duplex = 1;
-        
-        switch(tmp & 0x0018) {
-            case 0x0000:
-                speed = PHY_SPEED_1G; break;
-            case 0x0008:    
-                speed = PHY_SPEED_100M; break;
-            case 0x0010:    
-                speed = PHY_SPEED_10M; break;
-            default:
-                speed = PHY_SPEED_100M;
-        } 
+  if ((priv->NCSI_support == 1) || (priv->INTEL_NCSI_EVA_support == 1)) {
+    ids->miiPhyId = 0xFFFF;
+    // NCSI mode always is 100M and full duplex
+    duplex = 1;
+    speed  = PHY_SPEED_100M;
+  } else {
+    if (ids->miiPhyId < 1)
+        return;	// Cannot access MAC registers
+
+    // Check the link speed and duplex.
+    // They are not valid until auto-neg is resolved, which is reg.1 bit[5],
+    // or the link is up, which is reg.1 bit[2].
+
+    if (ids->phyAddr < 0xff)
+        tmp = ftgmac100_read_phy_register(dev->base_addr, ids->phyAddr, 0x1);
+    else tmp = 0;
+
+    if (0==(tmp & (1u<<5 | 1u<<2)) || ids->phyAddr >= 0xff) {
+        // No PHY chip, or link has not negotiated.
+        speed  = PHY_SPEED_100M;
+        duplex = 1;
+        netif_carrier_off(dev);
     }
-	else {
-	    // Assume Broadcom BCM5221.  Use reg.18 bits [1:0] for {100Mb/s, fdx}.
-	    tmp    = ftgmac100_read_phy_register(dev->base_addr, ids->phyAddr, 0x18);
-	    duplex = (tmp & 0x0001);
-	    speed  = (tmp & 0x0002) ? PHY_SPEED_100M : PHY_SPEED_10M;
-	}
+    else if (((ids->miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8201EL)) {
+        tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x00);
+        duplex = (tmp & 0x0100) ? 1 : 0;
+        speed  = (tmp & 0x2000) ? PHY_SPEED_100M : PHY_SPEED_10M;
+    }
+    else if (((ids->miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_MARVELL) ||
+       ((ids->miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8211)) {
+        // Use reg.17_0.bit[15:13] for {speed[1:0], duplex}.
+        tmp    = ftgmac100_read_phy_register(dev->base_addr, ids->phyAddr, 0x11);
+        duplex = (tmp & PHY_DUPLEX_mask)>>13;
+        speed  = (tmp & PHY_SPEED_mask)>>14;
+        netif_carrier_on(dev);
+    }
+    else if (priv->ids.miiPhyId == PHYID_BCM54612E
+       || priv->ids.miiPhyId == PHYID_BCM54616S) {
+         // Get link status
+          // First Switch shadow register selector
+          ftgmac100_write_phy_register(dev->base_addr, priv->ids.phyAddr, 0x1C, 0x2000);
+          tmp    = ftgmac100_read_phy_register(dev->base_addr, priv->ids.phyAddr, 0x1C);
+          if ( (tmp & 0x0080) == 0x0080 )
+              duplex = 0;
+          else
+              duplex = 1;
+
+          switch(tmp & 0x0018) {
+              case 0x0000:
+                  speed = PHY_SPEED_1G; break;
+              case 0x0008:
+                  speed = PHY_SPEED_100M; break;
+              case 0x0010:
+                  speed = PHY_SPEED_10M; break;
+              default:
+                  speed = PHY_SPEED_100M;
+          }
+      }
+    else {
+        // Assume Broadcom BCM5221.  Use reg.18 bits [1:0] for {100Mb/s, fdx}.
+        tmp    = ftgmac100_read_phy_register(dev->base_addr, ids->phyAddr, 0x18);
+        duplex = (tmp & 0x0001);
+        speed  = (tmp & 0x0002) ? PHY_SPEED_100M : PHY_SPEED_10M;
+    }
+  }// NCSI_Check
 
 	if (speed == PHY_SPEED_1G) {
 	    // Set SPEED_100_bit too, for consistency.
@@ -385,9 +1293,9 @@ static void ftgmac100_reset( struct net_device* dev )
 	}
 	if (duplex)
 	    priv->maccr_val |= FULLDUP_bit;
-    else 
+    else
 		priv->maccr_val &= ~FULLDUP_bit;
-		
+
 	outl( SW_RST_bit, dev->base_addr + MACCR_REG );
 
 #ifdef not_complete_yet
@@ -419,6 +1327,7 @@ static void ftgmac100_enable( struct net_device *dev )
 	unsigned int rfifo_rsize;	//Richard
 	unsigned int tfifo_rsize;	//Richard
 	unsigned int rxbuf_size;
+  unsigned long Package_Found = 0, Channel_Found = 0, Re_Send = 0, Link_Status;
 
 	rxbuf_size = RX_BUF_SIZE & 0x3fff;
 	outl( rxbuf_size , dev->base_addr + RBSR_REG); //for NC Body
@@ -475,7 +1384,7 @@ static void ftgmac100_enable( struct net_device *dev )
 
 	/// enable trans/recv,...
 	outl(priv->maccr_val, dev->base_addr + MACCR_REG );
-#if 0	
+
 //NCSI Start
 //DeSelect Package/ Select Package
 	if ((priv->NCSI_support == 1) || (priv->INTEL_NCSI_EVA_support == 1)) {
@@ -491,16 +1400,18 @@ static void ftgmac100_enable( struct net_device *dev )
 		}
 		if (Package_Found != 0) {
 //Initiali State
-			for (i = 0; i < 2; i++) { //Suppose 2 channels in current version, You could modify it to 0x1F to support 31 channels
-				Channel_Found = Clear_Initial_State(dev, i);
+			for (i = 0; i < 1; i++) { //Suppose 2 channels in current version, You could modify it to 0x1F to support 31 channels
+				//Channel_Found = Clear_Initial_State(dev, i);
+        Channel_Found = 1;
 				if (Channel_Found == 1) {
 					priv->NCSI_Cap.Channel_ID = i;
 					printk ("Found NCSI Network Controller at (%d, %d)\n", priv->NCSI_Cap.Package_ID, priv->NCSI_Cap.Channel_ID);
+          Get_MAC_Address(dev);
+          Set_MAC_Affinity(dev);
+				  Clear_Initial_State(dev, i);
 //Get Version and Capabilities
 					Get_Version_ID(dev);
 					Get_Capabilities(dev);
-//Configuration
-					Select_Active_Package(dev);
 //Set MAC Address
 					Enable_Set_MAC_Address(dev);
 //Enable Broadcast Filter
@@ -508,16 +1419,18 @@ static void ftgmac100_enable( struct net_device *dev )
 //Disable VLAN
 					Disable_VLAN(dev);
 //Enable AEN
-					Enable_AEN(dev);
+					//Enable_AEN(dev);
 //Get Parameters
 					Get_Parameters(dev);
-//Enable TX	
+//Enable TX
 					Enable_Network_TX(dev);
 //Enable Channel
 					Enable_Channel(dev);
 //Get Link Status
 Re_Get_Link_Status:
-					Link_Status = Get_Link_Status(dev);
+          //TODO: Workaround for CX4 Link status issue
+					//Link_Status = Get_Link_Status(dev);
+          Link_Status = LINK_UP;
 					if (Link_Status == LINK_UP) {
 						printk ("Using NCSI Network Controller (%d, %d)\n", priv->NCSI_Cap.Package_ID, priv->NCSI_Cap.Channel_ID);
 						netif_carrier_on(dev);
@@ -528,7 +1441,7 @@ Re_Get_Link_Status:
 						netif_carrier_off(dev);
 						goto Re_Get_Link_Status;
 					}
-//Disable TX	
+//Disable TX
 					Disable_Network_TX(dev);
 //Disable Channel
 //					Disable_Channel(dev);
@@ -537,9 +1450,19 @@ Re_Get_Link_Status:
 				}
 			}
 		}
+    // Enable Interrupts
+		outl(
+			AHB_ERR_bit			|
+			TPKT_LOST_bit			|
+			TPKT2E_bit			|
+			RXBUF_UNAVA_bit		|
+			RPKT2B_bit
+        	,dev->base_addr + IER_REG
+       	 	);
+
+    return;
 	}
 	/* now, enable interrupts */
-#endif
 	if (((priv->ids.miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_MARVELL) ||
 	    ((priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8211)) {
 		outl(
@@ -564,7 +1487,7 @@ Re_Get_Link_Status:
        	 	);
 	}
 	else if (priv->ids.miiPhyId == PHYID_BCM54612E
-		 || priv->ids.miiPhyId == PHYID_BCM54616S) { 
+		 || priv->ids.miiPhyId == PHYID_BCM54616S) {
         outl(
 // no link PHY link status pin            PHYSTS_CHG_bit      |
             AHB_ERR_bit         |
@@ -583,7 +1506,7 @@ Re_Get_Link_Status:
 			RXBUF_UNAVA_bit 	|
 			RPKT2B_bit
 			,dev->base_addr + IER_REG
-			);    
+			);
     }
 }
 
@@ -619,7 +1542,7 @@ static void aspeed_mac_timer(unsigned long data)
 	    speed  = (tmp & PHY_SPEED_mask)>>14;
 	}
 	else if (priv->ids.miiPhyId == PHYID_BCM54612E
-		 || priv->ids.miiPhyId == PHYID_BCM54616S) { 
+		 || priv->ids.miiPhyId == PHYID_BCM54616S) {
 	    // Get link status
 	    // First Switch shadow register selector
 	    ftgmac100_write_phy_register(dev->base_addr, priv->ids.phyAddr, 0x1C, 0x2000);
@@ -628,23 +1551,23 @@ static void aspeed_mac_timer(unsigned long data)
 	        duplex = 0;
 	    else
 	        duplex = 1;
-	                               
+
 	    switch(tmp & 0x0018) {
 	        case 0x0000:
-	            speed = PHY_SPEED_1G; 
-	    
+	            speed = PHY_SPEED_1G;
+
 	            break;
-	        case 0x0008:    
-	            speed = PHY_SPEED_100M; 
-	                   
+	        case 0x0008:
+	            speed = PHY_SPEED_100M;
+
 	            break;
-	        case 0x0010:    
-	            speed = PHY_SPEED_10M; 
-	                                       
+	        case 0x0010:
+	            speed = PHY_SPEED_10M;
+
 	            break;
 	        default:
 	            speed = PHY_SPEED_100M;
-	    } 
+	    }
 	}
 	else {
 	    duplex = 1;  speed = PHY_SPEED_100M;
@@ -730,27 +1653,26 @@ static int ftgmac100_wait_to_send_packet( struct sk_buff * skb, struct net_devic
 	PRINTK3("%s:ftgmac100_wait_to_send_packet, skb=%x\n", dev->name, skb);
 	cur_desc = &priv->tx_descs[priv->tx_idx];
 
-#ifdef not_complete_yet	
-	if (cur_desc->TXDMA_OWN != TX_OWNBY_SOFTWARE)		/// no empty transmit descriptor 
+#ifdef not_complete_yet
+	if (cur_desc->TXDMA_OWN != TX_OWNBY_SOFTWARE)		/// no empty transmit descriptor
 	{
 		DO_PRINT("no empty transmit descriptor\n");
 		DO_PRINT("jiffies = %d\n", jiffies);
 		priv->stats.tx_dropped++;
-		netif_stop_queue(dev);		/// waiting to do: 
+		netif_stop_queue(dev);		/// waiting to do:
 		spin_unlock_irqrestore(&priv->tx_lock, flags);
 
 		return 1;
    	}
 #endif /* end_of_not */
 
-	if (cur_desc->TXDMA_OWN != TX_OWNBY_SOFTWARE)		/// no empty transmit descriptor 
+	if (cur_desc->TXDMA_OWN != TX_OWNBY_SOFTWARE)		/// no empty transmit descriptor
 	{
 		DO_PRINT("no empty TX descriptor:0x%x:0x%x\n",
 				(unsigned int)cur_desc,((unsigned int *)cur_desc)[0]);
 		priv->stats.tx_dropped++;
-		netif_stop_queue(dev);		/// waiting to do: 
+		netif_stop_queue(dev);		/// waiting to do:
 		spin_unlock_irqrestore(&priv->tx_lock, flags);
-
 		return 1;
    	}
 	priv->tx_skbuff[priv->tx_idx] = skb;
@@ -803,18 +1725,18 @@ static int ftgmac100_ringbuf_alloc(struct ftgmac100_priv *priv)
 	int i;
 	struct sk_buff *skb;
 
-    priv->rx_descs = dma_alloc_coherent(priv->dev, 
-								sizeof(RX_DESC)*RXDES_NUM, 
+    priv->rx_descs = dma_alloc_coherent(priv->dev,
+								sizeof(RX_DESC)*RXDES_NUM,
 								&priv->rx_descs_dma, GFP_KERNEL);
 
 	if(!priv->rx_descs)
 		return -ENOMEM;
-	
+
 	memset(priv->rx_descs, 0, sizeof(RX_DESC)*RXDES_NUM);
 	priv->rx_descs[RXDES_NUM-1].EDORR = 1;
 
 	for (i=0; i<RXDES_NUM; i++) {
-		dma_addr_t mapping;	
+		dma_addr_t mapping;
 		skb = dev_alloc_skb(RX_BUF_SIZE + NET_IP_ALIGN);
 		skb_reserve(skb, NET_IP_ALIGN);
 
@@ -829,8 +1751,8 @@ static int ftgmac100_ringbuf_alloc(struct ftgmac100_priv *priv)
 		priv->rx_descs[i].VIR_RXBUF_BADR = skb->data;
 	}
 
-	priv->tx_descs = dma_alloc_coherent(priv->dev, 
-						sizeof(TX_DESC)*TXDES_NUM, 
+	priv->tx_descs = dma_alloc_coherent(priv->dev,
+						sizeof(TX_DESC)*TXDES_NUM,
 						&priv->tx_descs_dma ,GFP_KERNEL);
 
 	if(!priv->tx_descs)
@@ -838,7 +1760,7 @@ static int ftgmac100_ringbuf_alloc(struct ftgmac100_priv *priv)
 
 	memset((void*)priv->tx_descs, 0, sizeof(TX_DESC)*TXDES_NUM);
 	priv->tx_descs[TXDES_NUM-1].EDOTR = 1;			// is last descriptor
-	
+
 }
 
 #if FTMAC100_DEBUG > 2
@@ -918,20 +1840,14 @@ static void ftgmac100_phy_configure(struct net_device* dev)
 			}
 			break;
 		case PHYID_VENDOR_BROADCOM:
-			switch (priv->ids.miiPhyId) {
-				case PHYID_BCM54612E:
-				case PHYID_BCM54616S:
-					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x1C, 0x8C00); // Disable GTXCLK Clock Delay Enable
-					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x18, 0xF0E7); // Disable RGMII RXD to RXC Skew
-					break;			
-				case PHYID_BCM5221A4:
-				default:
-					tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x1b);
-					tmp |= 0x0004;
-					ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x1b, (u16) tmp);
-					break;
-				}
-			break;			
+			tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x1b);
+			tmp |= 0x0004;
+			ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x1b, (u16) tmp);
+			break;
+		case PHYID_VENDOR_BCM5461X:
+			ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x1C, 0x8C00); // Disable GTXCLK Clock Delay Enable
+			ftgmac100_write_phy_register(ioaddr, priv->ids.phyAddr, 0x18, 0xF0E7); // Disable RGMII RXD to RXC Skew
+			break;
 		}
 }
 
@@ -960,26 +1876,26 @@ static void ftgmac100_timeout (struct net_device *dev)
 }
 
 
-static void ftgmac100_free_tx (struct net_device *dev) 
+static void ftgmac100_free_tx (struct net_device *dev)
 {
  struct ftgmac100_priv *priv = (struct ftgmac100_priv *)dev->priv;
- int entry = priv->old_tx % TXDES_NUM; 
+ int entry = priv->old_tx % TXDES_NUM;
  unsigned long flags = 0;
- 
+
  spin_lock_irqsave(&priv->tx_lock,flags);
- 
+
  /* Free used tx skbuffs */
 
   while ((priv->tx_descs[entry].TXDMA_OWN == TX_OWNBY_SOFTWARE) && (priv->tx_skbuff[entry] != NULL)) {
   struct sk_buff *skb;
-  
+
   skb = priv->tx_skbuff[entry];
          dev_kfree_skb_any (skb);
   priv->tx_skbuff[entry] = 0;
   entry = (entry + 1) % TXDES_NUM;
   priv->tx_free++;
  }
- 
+
  spin_unlock_irqrestore(&priv->tx_lock, flags);
  priv->old_tx = entry;
  if ((netif_queue_stopped(dev)) && (priv->tx_free > 0)) {
@@ -1295,7 +2211,7 @@ static irqreturn_t ftgmac100_interrupt(int irq, void * dev_id,  struct pt_regs *
 		    DO_PRINT("PHYSTS_CHG \n");
 		    // Is this interrupt for changes of the PHYLINK pin?
 		    // Note: PHYLINK is optional; not all boards connect it.
-		    if (((priv->ids.miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_MARVELL) || 
+		    if (((priv->ids.miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_MARVELL) ||
 		    	((priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8211))
 		    {
 			tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x13);
@@ -1312,7 +2228,7 @@ static irqreturn_t ftgmac100_interrupt(int irq, void * dev_id,  struct pt_regs *
 			tmp &= 0x000e;
 		    }
 		    else if (priv->ids.miiPhyId == PHYID_BCM54612E
-			     || priv->ids.miiPhyId == PHYID_BCM54616S) { 
+			     || priv->ids.miiPhyId == PHYID_BCM54616S) {
                 tmp = ftgmac100_read_phy_register(ioaddr, priv->ids.phyAddr, 0x1A);
                 PRINTK("%s: PHY interrupt status, read_phy_reg(0x1A) = 0x%04x\n",
                     dev->name, tmp);
@@ -1403,10 +2319,10 @@ static irqreturn_t ftgmac100_interrupt(int irq, void * dev_id,  struct pt_regs *
  . Get the current statistics.
  . This may be called with the card open or closed.
  .-------------------------------------------------------------*/
-static struct net_device_stats* ftgmac100_query_statistics(struct net_device *dev) 
+static struct net_device_stats* ftgmac100_query_statistics(struct net_device *dev)
 {
 	struct ftgmac100_priv *priv = (struct ftgmac100_priv *)dev->priv;
-	
+
 	return &priv->stats;
 }
 
@@ -1416,7 +2332,7 @@ static struct net_device_stats* ftgmac100_query_statistics(struct net_device *de
 // 	Finds the CRC32 of a set of bytes.
 //	Again, from Peter Cammaert's code.
 // --------------------------------------------------------------------
-static int crc32( char * s, int length ) 
+static int crc32( char * s, int length )
 {
 	/* indices */
 	int perByte;
@@ -1446,7 +2362,7 @@ static int crc32( char * s, int length )
  .    packets before they take up memory.
 */
 
-static void ftgmac100_setmulticast( struct net_device *dev, int count, struct dev_mc_list * addrs ) 
+static void ftgmac100_setmulticast( struct net_device *dev, int count, struct dev_mc_list * addrs )
 {
 	struct dev_mc_list	* cur_addr;
 	int crc_val;
@@ -1455,12 +2371,12 @@ static void ftgmac100_setmulticast( struct net_device *dev, int count, struct de
 	struct AstMacHwConfig* ids = &priv->ids;
 	unsigned long Combined_Channel_ID, i;
 	struct sk_buff * skb;
-	cur_addr = addrs;	
+	cur_addr = addrs;
 
 //TX
-#if 0
+#if 1
 	if (priv->NCSI_support == 1) {
-		skb = dev_alloc_skb (TX_BUF_SIZE + 16);		
+		skb = dev_alloc_skb (TX_BUF_SIZE + 16);
 		priv->InstanceID++;
 		priv->NCSI_Request.IID = priv->InstanceID;
 		priv->NCSI_Request.Command = SET_MAC_ADDRESS;
@@ -1597,7 +2513,7 @@ static int ast_gmac_stop(struct net_device *dev)
 	priv->rx_descs = NULL; priv->rx_descs_dma = 0;
 	priv->tx_descs = NULL; priv->tx_descs_dma = 0;
 	priv->tx_buf   = NULL; priv->tx_buf_dma   = 0;
-	
+
 
 	return 0;
 }
@@ -1651,10 +2567,10 @@ static int ftgmac100_open(struct net_device *netdev)
 	ftgmac100_reset(netdev);
 	ftgmac100_enable(netdev);
 
-	if (((priv->ids.miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_BROADCOM) || 
+	if (((priv->ids.miiPhyId & PHYID_VENDOR_MASK) == PHYID_VENDOR_BROADCOM) ||
 	    ((priv->ids.miiPhyId & PHYID_VENDOR_MODEL_MASK) == PHYID_RTL8201EL) ||
         (priv->ids.miiPhyId == PHYID_BCM54612E) ||
-	(priv->ids.miiPhyId == PHYID_BCM54616S)) { 
+	(priv->ids.miiPhyId == PHYID_BCM54616S)) {
 
         init_timer(&priv->timer);
 	    priv->timer.data = (unsigned long)netdev;
@@ -1702,7 +2618,7 @@ static int __init ast_gmac_probe(struct platform_device *pdev)
 
 
 //	SET_ETHTOOL_OPS(netdev, &ftgmac100_ethtool_ops);
-	
+
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30))
 	netdev->netdev_ops 			= &ftgmac100_netdev_ops;
 #else
@@ -1715,13 +2631,12 @@ static int __init ast_gmac_probe(struct platform_device *pdev)
 	netdev->hard_start_xmit 	= ftgmac100_wait_to_send_packet;
 	netdev->tx_timeout 			= ftgmac100_timeout;
 	netdev->get_stats 			= ftgmac100_query_statistics;
-//#ifdef	HAVE_MULTICAST
-#if 0
+#ifdef	HAVE_MULTICAST
 	netdev->set_multicast_list 	= &ftgmac100_set_multicast_list;
 #endif
 
 #endif
-	
+
 
 #ifdef CONFIG_AST_NPAI
 //	netdev->features = NETIF_F_GRO;
@@ -1734,12 +2649,12 @@ static int __init ast_gmac_probe(struct platform_device *pdev)
 	priv = netdev_priv(netdev);
 	priv->netdev = netdev;
 	priv->dev = &pdev->dev;
-	
+
 
 	priv->ids.macId = pdev->id;
-	
+
 	priv->NCSI_support = ast_eth_data->NCSI_support;
-	priv->INTEL_NCSI_EVA_support= ast_eth_data->INTEL_NCSI_EVA_support;	
+	priv->INTEL_NCSI_EVA_support= ast_eth_data->INTEL_NCSI_EVA_support;
 	spin_lock_init(&priv->tx_lock);
 
 #if 0
@@ -1833,7 +2748,7 @@ err_ioremap:
 err_req_mem:
 //	netif_napi_del(&priv->napi);
 	platform_set_drvdata(pdev, NULL);
-err_netdev:	
+err_netdev:
 	free_netdev(netdev);
 err_alloc_etherdev:
 	return err;
diff --git a/drivers/net/ftgmac100_26.h b/drivers/net/ftgmac100_26.h
index 0d47024..2493111 100644
--- a/drivers/net/ftgmac100_26.h
+++ b/drivers/net/ftgmac100_26.h
@@ -1,16 +1,16 @@
 /********************************************************************************
 * File Name     : ftgmac100_26.h
-* 
+*
 * Copyright (C) 2012-2020  ASPEED Technology Inc.
-* This program is free software; you can redistribute it and/or modify 
-* it under the terms of the GNU General Public License as published by the Free Software Foundation; 
-* either version 2 of the License, or (at your option) any later version. 
-* This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY; 
-* without even the implied warranty of MERCHANTABILITY or 
-* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. 
-* You should have received a copy of the GNU General Public License 
-* along with this program; if not, write to the Free Software 
-* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by the Free Software Foundation;
+* either version 2 of the License, or (at your option) any later version.
+* This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY;
+* without even the implied warranty of MERCHANTABILITY or
+* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 ********************************************************************************/
 // --------------------------------------------------------------------
 
@@ -78,7 +78,7 @@
 
 
 // --------------------------------------------------------------------
-//	APTC_REG 
+//	APTC_REG
 // --------------------------------------------------------------------
 
 
@@ -99,18 +99,18 @@ typedef struct
 #define PHY_READ_bit			(1UL<<26)
 #define PHY_WRITE_bit			(1UL<<27)
 // --------------------------------------------------------------------
-//		PHYCR_REG 
+//		PHYCR_REG
 // --------------------------------------------------------------------
 #define PHY_AUTO_OK_bit			(1UL<<5)
 // --------------------------------------------------------------------
-//		PHY INT_STAT_REG 
+//		PHY INT_STAT_REG
 // --------------------------------------------------------------------
 #define PHY_SPEED_CHG_bit		(1UL<<14)
 #define PHY_DUPLEX_CHG_bit		(1UL<<13)
 #define PHY_LINK_CHG_bit		(1UL<<10)
 #define PHY_AUTO_COMP_bit		(1UL<<11)
 // --------------------------------------------------------------------
-//		PHY SPE_STAT_REG 
+//		PHY SPE_STAT_REG
 // --------------------------------------------------------------------
 #define PHY_RESOLVED_bit		(1UL<<11)
 #define PHY_SPEED_mask			0xC000
@@ -269,7 +269,7 @@ typedef struct {
     unsigned short  Reserved_5;
     unsigned short  Response_Code;
     unsigned short  Reason_Code;
-    unsigned char   Payload_Data[64];
+    unsigned char   Payload_Data[128];
 }  NCSI_Response_Packet;
 
 //Standard Response Code
@@ -365,30 +365,30 @@ typedef struct
 	u32 FRS:1;
 	u32 EDORR:1;
 	u32 RXPKT_RDY:1;		// 1 ==> owned by FTMAC100, 0 ==> owned by software
-	
+
 	// RXDES1
 	u32 VLAN_TAGC:16;
 	u32 Reserved4:4;
 	u32 PROTL_TYPE:2;
 	u32 LLC_PKT:1;
 	u32 DF:1;
-	u32 VLAN_AVA:1;	
+	u32 VLAN_AVA:1;
 	u32 TCPCS_FAIL:1;
 	u32 UDPCS_FAIL:1;
 	u32 IPCS_FAIL:1;
 	u32 Reserved5:4;
-	
+
 	// RXDES2
 	u32 Reserved6:32;
-	
+
 	// RXDES3
 	u32 RXBUF_BADR;
-				
+
 	u32 VIR_RXBUF_BADR;			// not defined, the virtual address of receive buffer is placed here
-	
-	u32 RESERVED; 
-	u32 RESERVED1; 
-	u32 RESERVED2;	
+
+	u32 RESERVED;
+	u32 RESERVED1;
+	u32 RESERVED2;
 }RX_DESC;
 
 
@@ -405,7 +405,7 @@ typedef struct
 	u32 FTS:1;
 	u32 EDOTR:1;
 	u32 TXDMA_OWN:1;
-	
+
 	// TXDES1
 	u32 VLAN_TAGC:16;
 	u32 INS_VLAN:1;
@@ -416,8 +416,8 @@ typedef struct
 	u32 LLC_PKT:1;
 	u32 Reserved6:7;
 	u32 TX2FIC:1;
-	u32 TXIC:1;	
-	
+	u32 TXIC:1;
+
 	// TXDES2
 	u32 Reserved7:32;
 
@@ -427,8 +427,8 @@ typedef struct
 	u32 VIR_TXBUF_BADR;			// Reserve, the virtual address of transmit buffer is placed here
 
 	u32 RESERVED;
-	u32 RESERVED1; 
-	u32 RESERVED2; 
+	u32 RESERVED1;
+	u32 RESERVED2;
 
 }TX_DESC;
 
@@ -450,7 +450,7 @@ typedef struct
 // --------------------------------------------------------------------
 
 
-//#define RXDES_NUM			64//64 // we defined 32 descriptor for OTG issue 
+//#define RXDES_NUM			64//64 // we defined 32 descriptor for OTG issue
 #define RXDES_NUM			32
 
 #define RX_BUF_SIZE			1536
@@ -464,6 +464,7 @@ typedef struct
 #define PHYID_REVISION_MASK             0x0000000f
 #define PHYID_VENDOR_MARVELL            0x01410c00
 #define PHYID_VENDOR_BROADCOM           0x00406000
+#define PHYID_VENDOR_BCM5461X           0x03625c00
 #define PHYID_VENDOR_REALTEK            0x001cc800
 
 #define PHYID_BCM5221A4                 0x004061e4
@@ -521,7 +522,7 @@ struct ftgmac100_priv {
 	int		tx_idx;
 	int		old_tx;
 	struct sk_buff *tx_skbuff[TXDES_NUM];
-	
+
 	int     maccr_val;
         struct timer_list    timer;
 	u32		GigaBit_MAHT0;
@@ -533,7 +534,7 @@ struct ftgmac100_priv {
 	NCSI_Capability NCSI_Cap;
 	unsigned int 	InstanceID;
 	unsigned int 	Retry;
-	unsigned char	Payload_Data[16];
+	unsigned char	Payload_Data[64];
 	unsigned char	Payload_Pad[4];
 	unsigned long	Payload_Checksum;
 	int		tx_free;
@@ -575,7 +576,7 @@ struct ftgmac100_priv {
 #define    STOP_DONE    (1 << 4)
 
 
- 
+
 #endif  /* _SMC_91111_H_ */
 
 
diff --git a/drivers/rtc/rtc-aspeed.c b/drivers/rtc/rtc-aspeed.c
index 477032e..de9e995 100644
--- a/drivers/rtc/rtc-aspeed.c
+++ b/drivers/rtc/rtc-aspeed.c
@@ -7,11 +7,11 @@
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by the Free Software Foundation;
 * either version 2 of the License, or (at your option) any later version.
-* 
+*
 * This program is distributed in the hope that it will be useful,  but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
-* 
+*
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
@@ -67,8 +67,16 @@ ast_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
 {
 	struct ast_rtc *ast_rtc = dev_get_drvdata(dev);
 	pr_debug("cmd = 0x%08x, arg = 0x%08lx\n", cmd, arg);
-	
+
 	switch (cmd) {
+    case RTC_SET_TIME:
+    case RTC_RD_TIME:
+    case RTC_ALM_READ:
+    case RTC_ALM_SET:
+      {
+        // use rtc-dev.c fallback
+        return -ENOIOCTLCMD;
+      }
 		case RTC_AIE_ON:	/* alarm on */
 			{
 				rtc_write(ast_rtc->base, rtc_read(ast_rtc->base, RTC_CONTROL) | ENABLE_ALL_ALARM, RTC_CONTROL);
@@ -105,7 +113,7 @@ ast_rtc_ioctl(struct device *dev, unsigned int cmd, unsigned long arg)
 		default:
 				return -ENOTTY;
 	}
-		
+
 	return 0;
 }
 
@@ -122,7 +130,7 @@ ast_rtc_get_time(struct device *dev, struct rtc_time *rtc_tm)
 
 		reg_time = rtc_read(ast_rtc->base, RTC_CNTR_STS_1);
 		reg_date = rtc_read(ast_rtc->base, RTC_CNTR_STS_2);
-		
+
 		spin_unlock_irqrestore(&ast_rtc->lock, flags);
 
 		rtc_tm->tm_year = GET_CENT_VAL(reg_date)*1000 | GET_YEAR_VAL(reg_date);
@@ -132,7 +140,7 @@ ast_rtc_get_time(struct device *dev, struct rtc_time *rtc_tm)
 		rtc_tm->tm_hour = GET_HOUR_VAL(reg_time);
 		rtc_tm->tm_min = GET_MIN_VAL(reg_time);
 		rtc_tm->tm_sec = GET_SEC_VAL(reg_time);
-		
+
         pr_debug("read time %02x.%02x.%02x %02x/%02x/%02x\n",
                  rtc_tm->tm_year, rtc_tm->tm_mon, rtc_tm->tm_mday,
                  rtc_tm->tm_hour, rtc_tm->tm_min, rtc_tm->tm_sec);
@@ -155,7 +163,7 @@ ast_rtc_set_time(struct device *dev, struct rtc_time *tm)
 
 	/* set hours */
 	reg_time = SET_DAY_VAL(tm->tm_mday) | SET_HOUR_VAL(tm->tm_hour) | SET_MIN_VAL(tm->tm_min) | SET_SEC_VAL(tm->tm_sec);
-	
+
 	/* set century */
 	/* set mon */
 	reg_date = SET_CENT_VAL(tm->tm_year / 1000) |  SET_YEAR_VAL(tm->tm_year % 1000) | SET_MON_VAL(tm->tm_mon);
@@ -166,10 +174,10 @@ ast_rtc_set_time(struct device *dev, struct rtc_time *tm)
 	rtc_write(ast_rtc->base, reg_date, RTC_CNTR_STS_2);
 
 	rtc_write(ast_rtc->base, rtc_read(ast_rtc->base, RTC_CONTROL) &~RTC_LOCK , RTC_CONTROL);
-	
+
 	spin_unlock_irqrestore(&ast_rtc->lock, flags);
 
-	return 0;	
+	return 0;
 }
 static int
 ast_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
@@ -183,7 +191,7 @@ ast_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 	alarm_reg = rtc_read(ast_rtc->base, RTC_ALARM);
 	spin_unlock_irqrestore(&ast_rtc->lock, flags);
 
-//DAY	
+//DAY
 	alm_tm->tm_mday = GET_DAY_VAL(alarm_reg);
 
 //HR
@@ -221,7 +229,7 @@ ast_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
     if (tm->tm_mday <= 31 && tm->tm_mday >= 1) {
 			reg_alarm |= SET_DAY_VAL(tm->tm_mday);
     }
-    
+
 //HR
     /* set ten hours */
     if (tm->tm_hour <= 23 && tm->tm_hour >= 0) {
@@ -245,8 +253,8 @@ ast_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 	spin_lock_irqsave(&ast_rtc->lock, flags);
 
 	rtc_write(ast_rtc->base, reg_alarm, RTC_ALARM);
-	
-	if(alarm->enabled)	
+
+	if(alarm->enabled)
 		rtc_write(ast_rtc->base, reg_alarm, RTC_CONTROL);
 	else
 		rtc_write(ast_rtc->base, reg_alarm, RTC_CONTROL);
@@ -366,14 +374,14 @@ static int __init ast_rtc_probe(struct platform_device *pdev)
 			ret = -EBUSY;
 			goto free_rtc;
 	}
-	
+
 	ast_rtc->base = ioremap(res->start, resource_size(res));
 	if (!ast_rtc->base) {
 			dev_err(&pdev->dev, "cannot map SocleDev registers\n");
 			ret = -ENOMEM;
 			goto release_mem;
 	}
-	
+
 	pr_debug("base = 0x%p, irq = %d\n", ast_rtc->base, ast_rtc->irq);
 
 	rtc_dev = rtc_device_register(pdev->name, &pdev->dev, &ast_rtcops, THIS_MODULE);
@@ -381,7 +389,7 @@ static int __init ast_rtc_probe(struct platform_device *pdev)
 			ret = PTR_ERR(rtc_dev);
 			goto unmap;
 	}
-	
+
 	ast_rtc->res = res;
 	ast_rtc->rtc_dev = rtc_dev;
 	spin_lock_init(&ast_rtc->lock);
@@ -406,7 +414,7 @@ static int __init ast_rtc_probe(struct platform_device *pdev)
 		printk("no need to enable RTC \n");
 
 	spin_unlock_irq(&ast_rtc->lock);
-	
+
 	/* register ISR */
 	ret = request_irq(ast_rtc->irq, ast_rtc_interrupt, IRQF_DISABLED, dev_name(&rtc_dev->dev), ast_rtc);
 	if (ret) {
diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index a181ccf..f16da59 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -38,6 +38,7 @@
 #include <linux/serial_8250.h>
 #include <linux/nmi.h>
 #include <linux/mutex.h>
+#include <linux/gpio.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -59,6 +60,8 @@ static unsigned int nr_uarts = CONFIG_SERIAL_8250_RUNTIME_UARTS;
 
 static struct uart_driver serial8250_reg;
 
+DECLARE_WAIT_QUEUE_HEAD(thre_wait);
+
 static int serial_index(struct uart_port *port)
 {
 	return (serial8250_reg.minor - 64) + port->line;
@@ -1225,7 +1228,10 @@ static void autoconfig_irq(struct uart_8250_port *up)
 
 static inline void __stop_tx(struct uart_8250_port *p)
 {
-	if (p->ier & UART_IER_THRI) {
+  int status = serial_in(p, UART_LSR);
+  // only turn off THRE interrupt if THRE is *currently* asserted
+  // (we still want to catch it a final time after the FIFO empties)
+	if ((p->ier & UART_IER_THRI) && (status & UART_LSR_THRE)) {
 		p->ier &= ~UART_IER_THRI;
 		serial_out(p, UART_IER, p->ier);
 	}
@@ -1527,6 +1533,7 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 
 	DEBUG_INTR("end.\n");
 
+  wake_up(&thre_wait);
 	return IRQ_RETVAL(handled);
 }
 
@@ -2526,6 +2533,35 @@ serial8250_type(struct uart_port *port)
 	return uart_config[type].name;
 }
 
+static int serial8250_ioctl(struct uart_port *port, unsigned int cmd, unsigned long arg) {
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+  unsigned long flags;
+  int ret = -ENOIOCTLCMD;
+  // kernel-space RS485 drain-and-switch hack
+  if (cmd == TIOCSERWAITTEMT) {
+    // wait for kernel buffers and UART FIFO to both empty
+	  struct circ_buf *xmit = &up->port.info->xmit;
+    wait_event_interruptible(
+       thre_wait,
+       uart_circ_empty(xmit) &&
+       (serial_in(up, UART_LSR) & UART_LSR_THRE));
+    // spin until TEMT (transmit shift register empty)
+	  spin_lock_irqsave(&up->port.lock, flags);
+	  wait_for_xmitr(up, BOTH_EMPTY);
+    if (arg != 0) {
+      // turn off RS485 DE pin
+      gpio_set_value(arg, 0);
+    }
+    // grab any phantom char seen on RX when transceiver switches
+		(void) serial_inp(up, UART_RX);
+    // enable read
+		up->port.ignore_status_mask &= ~UART_LSR_DR;
+	  spin_unlock_irqrestore(&up->port.lock, flags);
+    return 0;
+  }
+  return ret;
+}
+
 static struct uart_ops serial8250_pops = {
 	.tx_empty	= serial8250_tx_empty,
 	.set_mctrl	= serial8250_set_mctrl,
@@ -2544,6 +2580,7 @@ static struct uart_ops serial8250_pops = {
 	.request_port	= serial8250_request_port,
 	.config_port	= serial8250_config_port,
 	.verify_port	= serial8250_verify_port,
+  .ioctl = serial8250_ioctl,
 #ifdef CONFIG_CONSOLE_POLL
 	.poll_get_char = serial8250_get_poll_char,
 	.poll_put_char = serial8250_put_poll_char,
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 5702145..0b01ba8 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -235,10 +235,17 @@ config ORION5X_WATCHDOG
 
 config AST_WATCHDOG
 	tristate "ASPEED GUC watchdog"
-	depends on WATCHDOG 
+	depends on WATCHDOG
 	help
 	  Watchdog timer for ASPEED chips.
 
+config AST_WATCHDOG_REARM_DUAL_BOOT
+  bool "Rearm dual boot watchdog"
+  default n
+	depends on AST_WATCHDOG
+	help
+	  Rearm dual boot watchdog or not during boot
+
 # ARM26 Architecture
 
 # AVR32 Architecture
diff --git a/drivers/watchdog/ast_wdt.c b/drivers/watchdog/ast_wdt.c
index 9e7e84f..e599a55 100644
--- a/drivers/watchdog/ast_wdt.c
+++ b/drivers/watchdog/ast_wdt.c
@@ -68,6 +68,7 @@ typedef unsigned char bool_T;
 
 #else
 #define WDT_BASE_VA		(IO_ADDRESS(AST_WDT_BASE))
+#define WDT2_BASE_VA		(IO_ADDRESS(AST_WDT_BASE + 20))
 #endif
 
 #define WDT_CntSts              (WDT_BASE_VA+0x00)
@@ -78,6 +79,14 @@ typedef unsigned char bool_T;
 #define WDT_Clr                 (WDT_BASE_VA+0x14)
 #define WDT_RstWd               (WDT_BASE_VA+0x18)
 
+#define WDT2_CntSts             (WDT2_BASE_VA+0x00)
+#define WDT2_Reload             (WDT2_BASE_VA+0x04)
+#define WDT2_Restart            (WDT2_BASE_VA+0x08)
+#define WDT2_Ctrl               (WDT2_BASE_VA+0x0C)
+#define WDT2_TimeOut            (WDT2_BASE_VA+0x10)
+#define WDT2_Clr                (WDT2_BASE_VA+0x14)
+#define WDT2_RstWd              (WDT2_BASE_VA+0x18)
+
 #define WDT_CTRL_B_SECOND_BOOT  (0x1 << 7)
 #define WDT_CTRL_B_RESET_SOC (0x00 << 5) /* yes, 0x00 */
 #define WDT_CTRL_B_RESET_FULL (0x01 << 5)
@@ -101,6 +110,11 @@ typedef unsigned char bool_T;
 #define WDT_TIMO 30			/* Default heartbeat = 30 seconds */
 
 #define WDT_INITIAL_TIMO (8*60) /* Initial timeout, 8m */
+/*
+ * Dual boot watchdog is 5s shorter so that dual boot watchdog
+ * will kick in first.
+ */
+#define WDT_DUAL_BOOT_TIMO (WDT_INITIAL_TIMO - 5)
 #define WDT_TIMO2TICKS(t) (TICKS_PER_uSEC * 1000000 * (t))
 
 static int heartbeat = WDT_TIMO;
@@ -233,6 +247,14 @@ bool_T wdt_is_enabled(void)
 	return reg & WDT_CTRL_B_ENABLE;
 }
 
+#ifdef CONFIG_AST_WATCHDOG_REARM_DUAL_BOOT
+void wdt_dual_boot_restart(unsigned int timeo)
+{
+	AST_WRITE_REG(WDT2_Reload, WDT_TIMO2TICKS(timeo));
+	AST_WRITE_REG(WDT2_Restart, 0x4755);	/* reload! */
+	printk(KERN_INFO "Re-arm the dual boot watchdog for %u seconds\n", timeo);
+}
+#endif
 
 void wdt_restart_new(unsigned int nPeriod, int sourceClk, bool_T bResetOut,
 		     bool_T bIntrSys, bool_T bClrAfter, bool_T bResetARMOnly)
@@ -542,6 +564,11 @@ static int ast_wdt_probe(struct platform_device *pdev)
       return ret;
    }
 
+#ifdef CONFIG_AST_WATCHDOG_REARM_DUAL_BOOT
+   /* re-arm dual boot watchdog */
+   wdt_dual_boot_restart(WDT_DUAL_BOOT_TIMO);
+#endif
+
    /* interrupt the system while WDT timeout */
    wdt_restart_new(WDT_TIMO2TICKS(WDT_INITIAL_TIMO), WDT_CLK_SRC_EXT,
 		   /* No Ext, No intr, Self clear, Full chip reset */
diff --git a/fs/compat_ioctl.c b/fs/compat_ioctl.c
index 61cb48f..5dc69ab 100644
--- a/fs/compat_ioctl.c
+++ b/fs/compat_ioctl.c
@@ -3,7 +3,7 @@
  *
  * Copyright (C) 1997-2000  Jakub Jelinek  (jakub@redhat.com)
  * Copyright (C) 1998  Eddie C. Dost  (ecd@skynet.be)
- * Copyright (C) 2001,2002  Andi Kleen, SuSE Labs 
+ * Copyright (C) 2001,2002  Andi Kleen, SuSE Labs
  * Copyright (C) 2003       Pavel Machek (pavel@suse.cz)
  *
  * These routines maintain argument size conversion between 32bit and 64bit
@@ -125,7 +125,7 @@ static int w_long(unsigned int fd, unsigned int cmd, unsigned long arg)
 	mm_segment_t old_fs = get_fs();
 	int err;
 	unsigned long val;
-	
+
 	set_fs (KERNEL_DS);
 	err = sys_ioctl(fd, cmd, (unsigned long)&val);
 	set_fs (old_fs);
@@ -133,14 +133,14 @@ static int w_long(unsigned int fd, unsigned int cmd, unsigned long arg)
 		return -EFAULT;
 	return err;
 }
- 
+
 static int rw_long(unsigned int fd, unsigned int cmd, unsigned long arg)
 {
 	mm_segment_t old_fs = get_fs();
 	u32 __user *argptr = compat_ptr(arg);
 	int err;
 	unsigned long val;
-	
+
 	if(get_user(val, argptr))
 		return -EFAULT;
 	set_fs (KERNEL_DS);
@@ -365,17 +365,17 @@ static int dev_ifconf(unsigned int fd, unsigned int cmd, unsigned long arg)
 			if (copy_in_user(ifr, ifr32, sizeof(struct ifreq32)))
 				return -EFAULT;
 			ifr++;
-			ifr32++; 
+			ifr32++;
 		}
 	}
 	if (copy_to_user(uifc, &ifc, sizeof(struct ifconf)))
 		return -EFAULT;
 
-	err = sys_ioctl (fd, SIOCGIFCONF, (unsigned long)uifc);	
+	err = sys_ioctl (fd, SIOCGIFCONF, (unsigned long)uifc);
 	if (err)
 		return err;
 
-	if (copy_from_user(&ifc, uifc, sizeof(struct ifconf))) 
+	if (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))
 		return -EFAULT;
 
 	ifr = ifc.ifc_req;
@@ -411,7 +411,7 @@ static int ethtool_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
 	struct ifreq32 __user *ifr32;
 	u32 data;
 	void __user *datap;
-	
+
 	ifr = compat_alloc_user_space(sizeof(*ifr));
 	ifr32 = compat_ptr(arg);
 
@@ -507,7 +507,7 @@ static int dev_ifsioc(unsigned int fd, unsigned int cmd, unsigned long arg)
 	struct ifmap32 __user *uifmap32;
 	mm_segment_t old_fs;
 	int err;
-	
+
 	uifr32 = compat_ptr(arg);
 	uifmap32 = &uifr32->ifr_ifru.ifru_map;
 	switch (cmd) {
@@ -610,7 +610,7 @@ static int routing_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
 	char devname[16];
 	u32 rtdev;
 	mm_segment_t old_fs = get_fs();
-	
+
 	struct socket *mysock = sockfd_lookup(fd, &ret);
 
 	if (mysock && mysock->sk && mysock->sk->sk_family == AF_INET6) { /* ipv6 */
@@ -624,7 +624,7 @@ static int routing_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg)
 		ret |= __get_user (r6.rtmsg_info, &(ur6->rtmsg_info));
 		ret |= __get_user (r6.rtmsg_flags, &(ur6->rtmsg_flags));
 		ret |= __get_user (r6.rtmsg_ifindex, &(ur6->rtmsg_ifindex));
-		
+
 		r = (void *) &r6;
 	} else { /* ipv4 */
 		struct rtentry32 __user *ur4 = compat_ptr(arg);
@@ -1046,14 +1046,14 @@ static int vt_check(struct file *file)
 	struct tty_struct *tty;
 	struct inode *inode = file->f_path.dentry->d_inode;
 	struct vc_data *vc;
-	
+
 	if (file->f_op->unlocked_ioctl != tty_ioctl)
 		return -EINVAL;
-	                
+
 	tty = (struct tty_struct *)file->private_data;
 	if (tty_paranoia_check(tty, inode, "tty_ioctl"))
 		return -EINVAL;
-	                                                
+
 	if (tty->ops->ioctl != vt_ioctl)
 		return -EINVAL;
 
@@ -1067,7 +1067,7 @@ static int vt_check(struct file *file)
 	 */
 	if (current->signal->tty == tty || capable(CAP_SYS_TTY_CONFIG))
 		return 1;
-	return 0;                                                    
+	return 0;
 }
 
 struct consolefontdesc32 {
@@ -1085,7 +1085,7 @@ static int do_fontx_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg,
 
 	perm = vt_check(file);
 	if (perm < 0) return perm;
-	
+
 	switch (cmd) {
 	case PIO_FONTX:
 		if (!perm)
@@ -1130,16 +1130,16 @@ struct console_font_op32 {
 	compat_uint_t charcount;
 	compat_caddr_t data;    /* font data with height fixed to 32 */
 };
-                                        
+
 static int do_kdfontop_ioctl(unsigned int fd, unsigned int cmd, unsigned long arg, struct file *file)
 {
 	struct console_font_op op;
 	struct console_font_op32 __user *fontop = compat_ptr(arg);
 	int perm = vt_check(file), i;
 	struct vc_data *vc;
-	
+
 	if (perm < 0) return perm;
-	
+
 	if (copy_from_user(&op, fontop, sizeof(struct console_font_op32)))
 		return -EFAULT;
 	if (!perm && op.op != KD_FONT_OP_GET)
@@ -1303,7 +1303,7 @@ static int do_atmif_sioc(unsigned int fd, unsigned int cmd, unsigned long arg)
 	u32 data;
 	void __user *datap;
 	int err;
-        
+
 	sioc = compat_alloc_user_space(sizeof(*sioc));
 	sioc32 = compat_ptr(arg);
 
@@ -1328,7 +1328,7 @@ static int do_atm_ioctl(unsigned int fd, unsigned int cmd32, unsigned long arg)
 {
         int i;
         unsigned int cmd = 0;
-        
+
 	switch (cmd32) {
 	case SONET_GETSTAT:
 	case SONET_GETSTATZ:
@@ -1349,11 +1349,11 @@ static int do_atm_ioctl(unsigned int fd, unsigned int cmd32, unsigned long arg)
 	}
 	if (i == NR_ATM_IOCTL)
 	        return -EINVAL;
-        
+
         switch (cmd) {
 	case ATM_GETNAMES:
 		return do_atm_iobuf(fd, cmd, arg);
-	    
+
 	case ATM_GETLINKRATE:
         case ATM_GETTYPE:
         case ATM_GETESI:
@@ -1444,7 +1444,7 @@ static int mtd_rw_oob(unsigned int fd, unsigned int cmd, unsigned long arg)
 	}
 
 	return err;
-}	
+}
 
 #ifdef CONFIG_BLOCK
 struct raw32_config_request
@@ -1798,7 +1798,7 @@ static int rtc_ioctl(unsigned fd, unsigned cmd, unsigned long arg)
 		val32 = kval;
 		return put_user(val32, (unsigned int __user *)arg);
 	case RTC_IRQP_SET32:
-		return sys_ioctl(fd, RTC_IRQP_SET, arg); 
+		return sys_ioctl(fd, RTC_IRQP_SET, arg);
 	case RTC_EPOCH_SET32:
 		return sys_ioctl(fd, RTC_EPOCH_SET, arg);
 	default:
@@ -2678,6 +2678,7 @@ COMPATIBLE_IOCTL(USBDEVFS_IOCTL32)
 /* i2c */
 HANDLE_IOCTL(I2C_FUNCS, w_long)
 HANDLE_IOCTL(I2C_RDWR, do_i2c_rdwr_ioctl)
+HANDLE_IOCTL(I2C_SLAVE_RDWR, do_i2c_rdwr_ioctl)
 HANDLE_IOCTL(I2C_SMBUS, do_i2c_smbus_ioctl)
 /* bridge */
 HANDLE_IOCTL(SIOCSIFBR, old_bridge_ioctl)
diff --git a/include/linux/i2c-dev.h b/include/linux/i2c-dev.h
index 311315b..ed9b48d 100644
--- a/include/linux/i2c-dev.h
+++ b/include/linux/i2c-dev.h
@@ -46,6 +46,7 @@
 #define I2C_FUNCS	0x0705	/* Get the adapter functionality mask */
 
 #define I2C_RDWR	0x0707	/* Combined R/W transfer (one STOP only) */
+#define I2C_SLAVE_RDWR	0x0709	/* Slave Read Write */
 
 #define I2C_PEC		0x0708	/* != 0 to use PEC with SMBus */
 #define I2C_SMBUS	0x0720	/* SMBus transfer */
diff --git a/include/linux/i2c.h b/include/linux/i2c.h
index 59167e2..f037cde 100644
--- a/include/linux/i2c.h
+++ b/include/linux/i2c.h
@@ -62,6 +62,9 @@ extern int i2c_master_recv(struct i2c_client *client, char *buf, int count);
 extern int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
 			int num);
 
+extern int i2c_slave_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs,
+      int num);
+
 /* This is the very generalized SMBus access routine. You probably do not
    want to use this, though; one of the functions below may be much easier,
    and probably just as fast.
@@ -333,6 +336,7 @@ struct i2c_algorithm {
 	   processed, or a negative value on error */
 	int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,
 			   int num);
+	int (*slave_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs);
 	int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,
 			   unsigned short flags, char read_write,
 			   u8 command, int size, union i2c_smbus_data *data);
@@ -516,6 +520,8 @@ struct i2c_msg {
 	__u16 flags;
 #define I2C_M_TEN		0x0010	/* this is a ten bit chip address */
 #define I2C_M_RD		0x0001	/* read data, from slave to master */
+#define I2C_S_EN    0x0002  /* Slave Enable */
+#define I2C_S_ALT    0x0004  /* Slave Alert */
 #define I2C_M_NOSTART		0x4000	/* if I2C_FUNC_PROTOCOL_MANGLING */
 #define I2C_M_REV_DIR_ADDR	0x2000	/* if I2C_FUNC_PROTOCOL_MANGLING */
 #define I2C_M_IGNORE_NAK	0x1000	/* if I2C_FUNC_PROTOCOL_MANGLING */
diff --git a/meta-aspeed/recipes-kernel/linux/files/patch-2.6.28.9/0029-mtd-m25p80-Add-support-for-the-Winbond-W25Q64.patch b/meta-aspeed/recipes-kernel/linux/files/patch-2.6.28.9/0029-mtd-m25p80-Add-support-for-the-Winbond-W25Q64.patch
new file mode 100644
index 0000000..52aef04
--- /dev/null
+++ b/meta-aspeed/recipes-kernel/linux/files/patch-2.6.28.9/0029-mtd-m25p80-Add-support-for-the-Winbond-W25Q64.patch
@@ -0,0 +1,29 @@
+From d2ac467a108400ff1ae682a423c7d41265e62d47 Mon Sep 17 00:00:00 2001
+From: Thierry Reding <thierry.reding@avionic-design.de>
+Date: Mon, 30 Aug 2010 13:00:48 +0200
+Subject: [PATCH] mtd: m25p80: Add support for the Winbond W25Q64
+
+This patch adds support for the Winbond W25Q64 serial flash.
+
+Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
+Signed-off-by: Artem Bityutskiy <Artem.Bityutskiy@nokia.com>
+Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
+---
+ drivers/mtd/devices/m25p80.c | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
+index 1f0f703..b6fd7c2 100644
+--- a/drivers/mtd/devices/m25p80.c
++++ b/drivers/mtd/devices/m25p80.c
+@@ -716,6 +716,7 @@ static const struct spi_device_id m25p_ids[] = {
+ 	{ "w25x32", INFO(0xef3016, 0, 64 * 1024,  64, SECT_4K) },
+ 	{ "w25q32", INFO(0xef4016, 0, 64 * 1024,  64, SECT_4K) },
+ 	{ "w25x64", INFO(0xef3017, 0, 64 * 1024, 128, SECT_4K) },
++	{ "w25q64", INFO(0xef4017, 0, 64 * 1024, 128, SECT_4K) },
+ 
+ 	/* Catalyst / On Semiconductor -- non-JEDEC */
+ 	{ "cat25c11", CAT25_INFO(  16, 8, 16, 1) },
+-- 
+1.8.5.6
+
diff --git a/meta-aspeed/recipes-kernel/linux/files/patch-2.6.28.9/0030-net-Don-t-leak-packets-when-a-netns-is-going-down.patch b/meta-aspeed/recipes-kernel/linux/files/patch-2.6.28.9/0030-net-Don-t-leak-packets-when-a-netns-is-going-down.patch
new file mode 100644
index 0000000..ad04217
--- /dev/null
+++ b/meta-aspeed/recipes-kernel/linux/files/patch-2.6.28.9/0030-net-Don-t-leak-packets-when-a-netns-is-going-down.patch
@@ -0,0 +1,56 @@
+From 0a36b345ab99d6b3c96999e7e3b79bd243cf9bf7 Mon Sep 17 00:00:00 2001
+From: "Eric W. Biederman" <ebiederm@xmission.com>
+Date: Wed, 5 Nov 2008 16:00:24 -0800
+Subject: [PATCH] net: Don't leak packets when a netns is going down
+
+I have been tracking for a while a case where when the
+network namespace exits the cleanup gets stck in an
+endless precessess of:
+
+unregister_netdevice: waiting for lo to become free. Usage count = 3
+unregister_netdevice: waiting for lo to become free. Usage count = 3
+unregister_netdevice: waiting for lo to become free. Usage count = 3
+unregister_netdevice: waiting for lo to become free. Usage count = 3
+unregister_netdevice: waiting for lo to become free. Usage count = 3
+unregister_netdevice: waiting for lo to become free. Usage count = 3
+unregister_netdevice: waiting for lo to become free. Usage count = 3
+
+It turns out that if you listen on a multicast address an unsubscribe
+packet is sent when the network device goes down.   If you shutdown
+the network namespace without carefully cleaning up this can trigger
+the unsubscribe packet to be sent over the loopback interface while
+the network namespace is going down.
+
+All of which is fine except when we drop the packet and forget to
+free it leaking the skb and the dst entry attached to.  As it
+turns out the dst entry hold a reference to the idev which holds
+the dev and keeps everything from being cleaned up.  Yuck!
+
+By fixing my earlier thinko and add the needed kfree_skb and everything
+cleans up beautifully.
+
+Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ net/core/dev.c | 4 +++-
+ 1 file changed, 3 insertions(+), 1 deletion(-)
+
+diff --git a/net/core/dev.c b/net/core/dev.c
+index 811507c..a0c60607 100644
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -2253,8 +2253,10 @@ int netif_receive_skb(struct sk_buff *skb)
+ 	rcu_read_lock();
+ 
+ 	/* Don't receive packets in an exiting network namespace */
+-	if (!net_alive(dev_net(skb->dev)))
++	if (!net_alive(dev_net(skb->dev))) {
++		kfree_skb(skb);
+ 		goto out;
++	}
+ 
+ #ifdef CONFIG_NET_CLS_ACT
+ 	if (skb->tc_verd & TC_NCLS) {
+-- 
+1.8.1
+
diff --git a/meta-aspeed/recipes-kernel/linux/files/patch-2.6.28.9/0031-IPv6-Print-error-value-when-skb-allocation-fails.patch b/meta-aspeed/recipes-kernel/linux/files/patch-2.6.28.9/0031-IPv6-Print-error-value-when-skb-allocation-fails.patch
new file mode 100644
index 0000000..b638996
--- /dev/null
+++ b/meta-aspeed/recipes-kernel/linux/files/patch-2.6.28.9/0031-IPv6-Print-error-value-when-skb-allocation-fails.patch
@@ -0,0 +1,43 @@
+From 5777cee30776da63ecbe2b6d4929e01d82c7d72e Mon Sep 17 00:00:00 2001
+From: Brian Haley <brian.haley@hp.com>
+Date: Tue, 2 Jun 2009 00:20:26 -0700
+Subject: [PATCH] IPv6: Print error value when skb allocation fails
+
+Print-out the error value when sock_alloc_send_skb() fails in
+the IPv6 neighbor discovery code - can be useful for debugging.
+
+Signed-off-by: Brian Haley <brian.haley@hp.com>
+Signed-off-by: David S. Miller <davem@davemloft.net>
+---
+ net/ipv6/ndisc.c | 8 ++++----
+ 1 file changed, 4 insertions(+), 4 deletions(-)
+
+diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c
+index d0f54d1..45529b1 100644
+--- a/net/ipv6/ndisc.c
++++ b/net/ipv6/ndisc.c
+@@ -483,8 +483,8 @@ static void __ndisc_send(struct net_device *dev,
+ 				  1, &err);
+ 	if (!skb) {
+ 		ND_PRINTK0(KERN_ERR
+-			   "ICMPv6 ND: %s() failed to allocate an skb.\n",
+-			   __func__);
++			   "ICMPv6 ND: %s() failed to allocate an skb, err=%d.\n",
++			   __func__, err);
+ 		dst_release(dst);
+ 		return;
+ 	}
+@@ -1533,8 +1533,8 @@ void ndisc_send_redirect(struct sk_buff *skb, struct neighbour *neigh,
+ 				   1, &err);
+ 	if (buff == NULL) {
+ 		ND_PRINTK0(KERN_ERR
+-			   "ICMPv6 Redirect: %s() failed to allocate an skb.\n",
+-			   __func__);
++			   "ICMPv6 Redirect: %s() failed to allocate an skb, err=%d.\n",
++			   __func__, err);
+ 		dst_release(dst);
+ 		return;
+ 	}
+-- 
+1.8.1
+
