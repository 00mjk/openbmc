From 6561a4856f8f76fbd7c18efe507776274091aa94 Mon Sep 17 00:00:00 2001
From: CH-Chien <cl4fu6@gmail.com>
Date: Fri, 3 Mar 2017 18:45:40 +0800
Subject: [PATCH] Lightning-modify NVMe-MI lib for reading vendor id and
 decoding data

Summary:
1. Add nvme_read_word() and nvme_vendor_read() to read vendor id
2. Add three structs and six functions to decode NVMe-MI data
   Struct: t_key_value_pair
           t_status_flags
           t_smart_warning
   Function: nvme_sflgs_read_decode()
             nvme_smart_warning_read_decode()
             nvme_temp_read_decode()
             nvme_pdlu_read_decode()
             nvme_vendor_read_decode()
             nvme_serial_num_read_decode()

Test Plan:
Check the lib is workable on Lightning: pass
---
 common/recipes-lib/nvme-mi/files/src/nvme-mi.c | 322 +++++++++++++++++++++++--
 common/recipes-lib/nvme-mi/files/src/nvme-mi.h |  52 +++-
 2 files changed, 349 insertions(+), 25 deletions(-)
 mode change 100644 => 100755 common/recipes-lib/nvme-mi/files/src/nvme-mi.c
 mode change 100644 => 100755 common/recipes-lib/nvme-mi/files/src/nvme-mi.h

diff --git a/common/recipes-lib/nvme-mi/files/src/nvme-mi.c b/common/recipes-lib/nvme-mi/files/src/nvme-mi.c
old mode 100644
new mode 100755
index 41bab52..de0b7b2
--- a/common/recipes-lib/nvme-mi/files/src/nvme-mi.c
+++ b/common/recipes-lib/nvme-mi/files/src/nvme-mi.c
@@ -26,22 +26,35 @@
 #include "nvme-mi.h"
 
 #define I2C_NVME_INTF_ADDR 0x6A
+
 #define NVME_SFLGS_REG 0x01
-#define NVME_WARN_REG 0x02
+#define NVME_WARNING_REG 0x02
 #define NVME_TEMP_REG 0x03
 #define NVME_PDLU_REG 0x04
+#define NVME_VENDOR_REG 0x09
 #define NVME_SERIAL_NUM_REG 0x0B
 #define SERIAL_NUM_SIZE 20
 
+/* NVMe-MI Temperature Definition Code */
+#define TEMP_HIGHER_THAN_127 0x7F
+#define TEPM_LOWER_THAN_n60 0xC4
+#define TEMP_NO_UPDATE 0x80
+#define TEMP_SENSOR_FAIL 0x81
+
+/* NVMe-MI Vendor ID Code */
+#define VENDOR_ID_INTEL 0x8086
+#define VENDOR_ID_SEAGATE 0x1BB1
+#define VENDOR_ID_SAMSUNG 0x144D
+
 /* Read a byte from NVMe-MI 0x6A. Need to give a bus and a byte address for reading. */
 int
-nvme_read_byte(const char *device, uint8_t item, uint8_t *value) {
+nvme_read_byte(const char *i2c_bus_device, uint8_t item, uint8_t *value) {
   int dev;
   int ret;
   int32_t res;
   int retry = 0;
 
-  dev = open(device, O_RDWR);
+  dev = open(i2c_bus_device, O_RDWR);
   if (dev < 0) {
     syslog(LOG_DEBUG, "%s(): open() failed", __func__);
     return -1;
@@ -54,15 +67,60 @@ nvme_read_byte(const char *device, uint8_t item, uint8_t *value) {
     return -1;
   }
 
+  res = i2c_smbus_read_byte_data(dev, item);
   retry = 0;
-  while (retry < 5) {
+  while ((retry < 5) && (res < 0)) {
+    msleep(100);
     res = i2c_smbus_read_byte_data(dev, item);
     if (res < 0)
       retry++;
     else
       break;
+  }
+
+  if (res < 0) {
+    syslog(LOG_DEBUG, "%s(): i2c_smbus_read_byte_data failed", __func__);
+    close(dev);
+    return -1;
+  }
+
+  *value = (uint8_t) res;
+
+  close(dev);
+
+  return 0;
+}
+
+/* Read a word from NVMe-MI 0x6A. Need to give a bus and a byte address for reading. */
+int
+nvme_read_word(const char *i2c_bus_device, uint8_t item, uint16_t *value) {
+  int dev;
+  int ret;
+  int32_t res;
+  int retry = 0;
+
+  dev = open(i2c_bus_device, O_RDWR);
+  if (dev < 0) {
+    syslog(LOG_DEBUG, "%s(): open() failed", __func__);
+    return -1;
+  }
 
+  ret = ioctl(dev, I2C_SLAVE, I2C_NVME_INTF_ADDR);
+  if (ret < 0) {
+    syslog(LOG_DEBUG, "%s(): ioctl() assigning i2c addr failed", __func__);
+    close(dev);
+    return -1;
+  }
+
+  res = i2c_smbus_read_word_data(dev, item);
+  retry = 0;
+  while ((retry < 5) && (res < 0)) {
     msleep(100);
+    res = i2c_smbus_read_word_data(dev, item);
+    if (res < 0)
+      retry++;
+    else
+      break;
   }
 
   if (res < 0) {
@@ -71,19 +129,19 @@ nvme_read_byte(const char *device, uint8_t item, uint8_t *value) {
     return -1;
   }
 
-  *value = (uint8_t) res;
+  *value = (uint16_t) res;
 
   close(dev);
 
   return 0;
 }
 
-/* Read NVMe-MI SFLGS. Need to give a bus for reading. */
+/* Read NVMe-MI Status Flags. Need to give a bus for reading. */
 int
-nvme_sflgs_read(const char *device, uint8_t *value) {
+nvme_sflgs_read(const char *i2c_bus_device, uint8_t *value) {
   int ret;
 
-  ret = nvme_read_byte(device, NVME_SFLGS_REG, value);
+  ret = nvme_read_byte(i2c_bus_device, NVME_SFLGS_REG, value);
 
   if(ret < 0) {
     syslog(LOG_DEBUG, "%s(): nvme_read_byte failed", __func__);
@@ -95,10 +153,10 @@ nvme_sflgs_read(const char *device, uint8_t *value) {
 
 /* Read NVMe-MI SMART Warnings. Need to give a bus for reading. */
 int
-nvme_smart_warning_read(const char *device, uint8_t *value) {
+nvme_smart_warning_read(const char *i2c_bus_device, uint8_t *value) {
   int ret;
 
-  ret = nvme_read_byte(device, NVME_WARN_REG, value);
+  ret = nvme_read_byte(i2c_bus_device, NVME_WARNING_REG, value);
 
   if(ret < 0) {
     syslog(LOG_DEBUG, "%s(): nvme_read_byte failed", __func__);
@@ -110,10 +168,10 @@ nvme_smart_warning_read(const char *device, uint8_t *value) {
 
 /* Read NVMe-MI Composite Temperature. Need to give a bus for reading. */
 int
-nvme_temp_read(const char *device, uint8_t *value) {
+nvme_temp_read(const char *i2c_bus_device, uint8_t *value) {
   int ret;
 
-  ret = nvme_read_byte(device, NVME_TEMP_REG, value);
+  ret = nvme_read_byte(i2c_bus_device, NVME_TEMP_REG, value);
 
   if(ret < 0) {
     syslog(LOG_DEBUG, "%s(): nvme_read_byte failed", __func__);
@@ -123,12 +181,12 @@ nvme_temp_read(const char *device, uint8_t *value) {
   return 0;
 }
 
-/* Read NVMe-MI PDLU. Need to give a bus for reading. */
+/* Read NVMe-MI Percentage Drive Life Used. Need to give a bus for reading. */
 int
-nvme_pdlu_read(const char *device, uint8_t *value) {
+nvme_pdlu_read(const char *i2c_bus_device, uint8_t *value) {
   int ret;
 
-  ret = nvme_read_byte(device, NVME_PDLU_REG, value);
+  ret = nvme_read_byte(i2c_bus_device, NVME_PDLU_REG, value);
 
   if(ret < 0) {
     syslog(LOG_DEBUG, "%s(): nvme_read_byte failed", __func__);
@@ -138,9 +196,26 @@ nvme_pdlu_read(const char *device, uint8_t *value) {
   return 0;
 }
 
+/* Read NVMe-MI Vendor ID. Need to give a bus for reading. */
+int
+nvme_vendor_read(const char *i2c_bus_device, uint16_t *value) {
+  int ret;
+
+  ret = nvme_read_word(i2c_bus_device, NVME_VENDOR_REG, value);
+
+  if(ret < 0) {
+    syslog(LOG_DEBUG, "%s(): nvme_read_byte failed", __func__);
+    return -1;
+  }
+
+  *value = (*value & 0xFF00) >> 8 | (*value & 0xFF) << 8;
+
+  return 0;
+}
+
 /* Read NVMe-MI Serial Number. Need to give a bus for reading. */
 int
-nvme_serial_num_read(const char *device, uint8_t *value, int size) {
+nvme_serial_num_read(const char *i2c_bus_device, uint8_t *value, int size) {
   int ret;
   uint8_t reg = NVME_SERIAL_NUM_REG;
   int count;
@@ -151,7 +226,7 @@ nvme_serial_num_read(const char *device, uint8_t *value, int size) {
   }
 
   for(count = 0; count < SERIAL_NUM_SIZE; count++) {
-    ret = nvme_read_byte(device, reg + count, value + count);
+    ret = nvme_read_byte(i2c_bus_device, reg + count, value + count);
     if(ret < 0) {
       syslog(LOG_DEBUG, "%s(): nvme_read_byte failed", __func__);
       return -1;
@@ -159,3 +234,216 @@ nvme_serial_num_read(const char *device, uint8_t *value, int size) {
   }
   return 0;
 }
+
+/* Read NVMe-MI Status Flags and decode it. */
+int
+nvme_sflgs_read_decode(const char *i2c_bus_device, uint8_t *value, t_status_flags *status_flag_decoding) {
+  
+  if ((i2c_bus_device == NULL) | (value == NULL) | (status_flag_decoding == NULL)) {
+    syslog(LOG_ERR, "%s(): invalid parameter (null)", __func__);
+    return -1;
+  }
+
+  sprintf(status_flag_decoding->self.key, "Status Flags");
+  if (nvme_sflgs_read(i2c_bus_device, value)) {
+    syslog(LOG_DEBUG, "%s(): nvme_sflgs_read failed", __func__);
+    sprintf(status_flag_decoding->self.value, "Fail on reading");
+    return -1;
+  }
+  else {
+    sprintf(status_flag_decoding->self.value, "0x%02X", *value);
+
+    sprintf(status_flag_decoding->read_complete.key, "SMBUS block read complete");
+    if ((*value & 0x80) == 0)
+      sprintf(status_flag_decoding->read_complete.value, "FAIL");
+    else
+      sprintf(status_flag_decoding->read_complete.value, "OK");
+
+    sprintf(status_flag_decoding->ready.key, "Drive Ready");
+    if ((*value & 0x40) == 0)
+      sprintf(status_flag_decoding->ready.value, "Ready");
+    else
+      sprintf(status_flag_decoding->ready.value, "Not ready");
+
+    sprintf(status_flag_decoding->functional.key, "Drive Functional");
+    if ((*value & 0x20) == 0)
+      sprintf(status_flag_decoding->functional.value, "Unrecoverable Failure");
+    else
+      sprintf(status_flag_decoding->functional.value, "Functional");
+
+    sprintf(status_flag_decoding->reset_required.key, "Reset Required");
+    if ((*value & 0x10) == 0)
+      sprintf(status_flag_decoding->reset_required.value, "Required");
+    else
+      sprintf(status_flag_decoding->reset_required.value, "No");
+
+    sprintf(status_flag_decoding->port0_link.key, "Port 0 PCIe Link Active");
+    if ((*value & 0x08) == 0)
+      sprintf(status_flag_decoding->port0_link.value, "Down");
+    else
+      sprintf(status_flag_decoding->port0_link.value, "Up");
+
+    sprintf(status_flag_decoding->port1_link.key, "Port 1 PCIe Link Active");
+    if ((*value & 0x04) == 0)
+      sprintf(status_flag_decoding->port1_link.value, "Down");
+    else
+      sprintf(status_flag_decoding->port1_link.value, "Up");
+  }
+
+  return 0;
+}
+
+/* Read NVMe-MI SMART Warnings and decode it. */
+int
+nvme_smart_warning_read_decode(const char *i2c_bus_device, uint8_t *value, t_smart_warning *smart_warning_decoding) { 
+
+  if ((i2c_bus_device == NULL) | (value == NULL) | (smart_warning_decoding == NULL)) {
+    syslog(LOG_ERR, "%s(): invalid parameter (null)", __func__);
+    return -1;
+  }
+
+  sprintf(smart_warning_decoding->self.key, "SMART Critical Warning");
+  if (nvme_smart_warning_read(i2c_bus_device, value)) {
+    syslog(LOG_DEBUG, "%s(): nvme_smart_warning_read failed", __func__);
+    sprintf(smart_warning_decoding->self.value, "Fail on reading");
+    return -1;
+  }
+  else {
+    sprintf(smart_warning_decoding->self.value, "0x%02X", *value);
+
+    sprintf(smart_warning_decoding->spare_space.key, "Spare Space");
+    if ((*value & 0x01) == 0)
+      sprintf(smart_warning_decoding->spare_space.value, "Low");
+    else
+      sprintf(smart_warning_decoding->spare_space.value, "Normal");
+
+    sprintf(smart_warning_decoding->temp_warning.key, "Temperature Warning");
+    if ((*value & 0x02) == 0)
+      sprintf(smart_warning_decoding->temp_warning.value, "Abnormal");
+    else
+      sprintf(smart_warning_decoding->temp_warning.value, "Normal");
+
+    sprintf(smart_warning_decoding->reliability.key, "NVM Subsystem Reliability");
+    if ((*value & 0x04) == 0)
+      sprintf(smart_warning_decoding->reliability.value, "Degraded");
+    else
+      sprintf(smart_warning_decoding->reliability.value, "Normal");
+
+    sprintf(smart_warning_decoding->media_status.key, "Media Status");
+    if ((*value & 0x08) == 0)
+      sprintf(smart_warning_decoding->media_status.value, "Read Only mode");
+    else
+      sprintf(smart_warning_decoding->media_status.value, "Normal");
+
+    sprintf(smart_warning_decoding->backup_device.key, "Volatile Memory Backup Device");
+    if ((*value & 0x10) == 0)
+      sprintf(smart_warning_decoding->backup_device.value, "Failed");
+    else
+      sprintf(smart_warning_decoding->backup_device.value, "Normal");
+  }
+
+  return 0;
+}
+
+/* Read NVMe-MI Composite Temperature and decode it. */
+int
+nvme_temp_read_decode(const char *i2c_bus_device, uint8_t *value, t_key_value_pair *temp_decoding) {
+
+  if ((i2c_bus_device == NULL) | (value == NULL) | (temp_decoding == NULL)) {
+    syslog(LOG_ERR, "%s(): invalid parameter (null)", __func__);
+    return -1;
+  }
+
+  sprintf(temp_decoding->key, "Composite Temperature");
+  if (nvme_temp_read(i2c_bus_device, value)) {
+    syslog(LOG_DEBUG, "%s(): nvme_temp_read failed", __func__);
+    sprintf(temp_decoding->value, "Fail on reading");
+    return -1;
+  }
+  else {
+    if (*value <= TEMP_HIGHER_THAN_127)
+      sprintf(temp_decoding->value, "%d C", *value);
+    else if (*value >= TEPM_LOWER_THAN_n60)
+      sprintf(temp_decoding->value, "%d C", (*value - 0x100));
+    else if (*value == TEMP_NO_UPDATE)
+      sprintf(temp_decoding->value, "No data or data is too old");
+    else if (*value == TEMP_SENSOR_FAIL)
+      sprintf(temp_decoding->value, "Sensor failure");
+  }
+
+  return 0;
+}
+
+/* Read NVMe-MI Percentage Drive Life Used and decode it. */
+int
+nvme_pdlu_read_decode(const char *i2c_bus_device, uint8_t *value, t_key_value_pair *pdlu_decoding) {
+
+  if ((i2c_bus_device == NULL) | (value == NULL) | (pdlu_decoding == NULL)) {
+    syslog(LOG_ERR, "%s(): invalid parameter (null)", __func__);
+    return -1;
+  }
+
+  sprintf(pdlu_decoding->key, "Percentage Drive Life Used");
+  if (nvme_pdlu_read(i2c_bus_device, value)) {
+    syslog(LOG_DEBUG, "%s(): nvme_pdlu_read failed", __func__);
+    sprintf(pdlu_decoding->value, "Fail on reading");
+    return -1;
+  }
+  else
+    sprintf(pdlu_decoding->value, "%d", *value);
+
+  return 0;
+}
+
+/* Read NVMe-MI Vendor ID and decode it. */
+int
+nvme_vendor_read_decode(const char *i2c_bus_device, uint16_t *value, t_key_value_pair *vendor_decoding) {
+
+  if ((i2c_bus_device == NULL) | (value == NULL) | (vendor_decoding == NULL)) {
+    syslog(LOG_ERR, "%s(): invalid parameter (null)", __func__);
+    return -1;
+  }
+
+  sprintf(vendor_decoding->key, "Vendor");
+  if (nvme_vendor_read(i2c_bus_device, value)) {
+    syslog(LOG_DEBUG, "%s(): nvme_vendor_read failed", __func__);
+    sprintf(vendor_decoding->value, "Fail on reading");
+    return -1;
+  }
+  else{
+    if (*value == VENDOR_ID_INTEL)
+      sprintf(vendor_decoding->value, "Intel(0x%04X)", *value);
+    else if (*value == VENDOR_ID_SEAGATE)
+      sprintf(vendor_decoding->value, "Seagate(0x%04X)", *value);
+    else if (*value == VENDOR_ID_SAMSUNG)
+      sprintf(vendor_decoding->value, "Samsung(0x%04X)", *value);
+    else
+      sprintf(vendor_decoding->value, "Unknown(0x%04X)", *value);
+  }
+
+  return 0;
+}
+
+/* Read NVMe-MI Serial Number and decode it. */
+int
+nvme_serial_num_read_decode(const char *i2c_bus_device, uint8_t *value, int size, t_key_value_pair *sn_decoding) {
+
+  if ((i2c_bus_device == NULL) | (value == NULL) | (sn_decoding == NULL)) {
+    syslog(LOG_ERR, "%s(): invalid parameter (null)", __func__);
+    return -1;
+  }
+
+  sprintf(sn_decoding->key, "Serial Number");
+  if (nvme_serial_num_read(i2c_bus_device, value, SERIAL_NUM_SIZE)) {
+    syslog(LOG_DEBUG, "%s(): nvme_serial_num_read failed", __func__);
+    sprintf(sn_decoding->value, "Fail on reading");
+    return -1;
+  }
+  else{
+    memcpy(sn_decoding->value, value, SERIAL_NUM_SIZE);
+    sn_decoding->value[SERIAL_NUM_SIZE] = '\0';
+  }
+
+  return 0;
+}
+
diff --git a/common/recipes-lib/nvme-mi/files/src/nvme-mi.h b/common/recipes-lib/nvme-mi/files/src/nvme-mi.h
old mode 100644
new mode 100755
index 586df1a..bf07df5
--- a/common/recipes-lib/nvme-mi/files/src/nvme-mi.h
+++ b/common/recipes-lib/nvme-mi/files/src/nvme-mi.h
@@ -22,15 +22,51 @@ typedef struct {
   uint8_t sflgs;            //Status Flags
   uint8_t warning;          //SMART Warnings
   uint8_t temp;             //Composite Temperature
-  uint8_t pdlu;		    //Percentage Drive Life Used
-  uint8_t serial_num[20]    //Serial Number
+  uint8_t pdlu;		        //Percentage Drive Life Used
+  uint16_t vendor;        //Vendor ID
+  uint8_t serial_num[20];   //Serial Number
 } ssd_data;
 
-int nvme_read_byte(const char *device, uint8_t item, uint8_t *value);
-int nvme_sflgs_read(const char *device, uint8_t *value);
-int nvme_smart_warning_read(const char *device, uint8_t *value);
-int nvme_temp_read(const char *device, uint8_t *value);
-int nvme_pdlu_read(const char *device, uint8_t *value);
-int nvme_serial_num_read(const char *device, uint8_t *value, int size);
+typedef struct {
+  char key[32];
+  char value[28];
+} t_key_value_pair;
+
+// For Byte 1 - Status Flag. 
+typedef struct {
+  t_key_value_pair self; //"Status Flag" and it's raw data
+  t_key_value_pair read_complete;
+  t_key_value_pair ready;
+  t_key_value_pair functional;
+  t_key_value_pair reset_required;
+  t_key_value_pair port0_link;
+  t_key_value_pair port1_link;
+} t_status_flags;
+
+// For Byte 2 - SMART critical warning 
+typedef struct{
+t_key_value_pair self; // SMART Critical Warning and it's raw data
+t_key_value_pair spare_space;
+t_key_value_pair temp_warning;
+t_key_value_pair reliability;
+t_key_value_pair media_status;
+t_key_value_pair backup_device;
+} t_smart_warning; 
+
+int nvme_read_byte(const char *i2c_bus, uint8_t item, uint8_t *value);
+int nvme_read_word(const char *i2c_bus, uint8_t item, uint16_t *value);
+int nvme_sflgs_read(const char *i2c_bus, uint8_t *value);
+int nvme_smart_warning_read(const char *i2c_bus, uint8_t *value);
+int nvme_temp_read(const char *i2c_bus, uint8_t *value);
+int nvme_pdlu_read(const char *i2c_bus, uint8_t *value);
+int nvme_vendor_read(const char *i2c_bus, uint16_t *value);
+int nvme_serial_num_read(const char *i2c_bus, uint8_t *value, int size);
+
+int nvme_sflgs_read_decode(const char *i2c_bus, uint8_t *value, t_status_flags *status_flag_decoding);
+int nvme_smart_warning_read_decode(const char *i2c_bus, uint8_t *value, t_smart_warning *smart_warning_decoding);
+int nvme_temp_read_decode(const char *i2c_bus, uint8_t *value, t_key_value_pair *temp_decoding);
+int nvme_pdlu_read_decode(const char *i2c_bus, uint8_t *value, t_key_value_pair *pdlu_decoding);
+int nvme_vendor_read_decode(const char *i2c_bus, uint16_t *value, t_key_value_pair *vendor_decoding);
+int nvme_serial_num_read_decode(const char *i2c_bus, uint8_t *value, int size, t_key_value_pair *sn_decoding);
 
 #endif
