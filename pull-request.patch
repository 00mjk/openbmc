From b326a26aabaf210ec3601ba2c5bb612a334e480a Mon Sep 17 00:00:00 2001
From: Jack Hsin <Jack_Hsin@wiwynn.com>
Date: Wed, 22 Feb 2017 15:13:54 +0800
Subject: [PATCH 01/11] [FBTTN]Check IPMI request length Summary: This is a
 prototype for check ipmi request length. Set all command layer fuction to
 cmd_function (unsigned char *request, unsigned char req_len, unsigned char
 *response, unsigned char *res_len). Add a length_check to check the length.
 If the length is invalid, cmd_function will send the res = 0xC7.

Test Plan:
[root@localhost ~]# ipmitool raw 0x6 1
 20 81 00 04 02 bf 15 a0 00 46 31 00 00 00 00
[root@localhost ~]# ipmitool raw 0x6 1 1
Unable to send RAW command (channel=0x0 netfn=0x6 lun=0x0 cmd=0x1 rsp=0xc7): Request data length invalid
---
 common/recipes-core/ipmid/files/ipmid.c | 65 ++++++++++++++++++++++-----------
 common/recipes-lib/ipmi/files/ipmi.h    |  1 +
 2 files changed, 44 insertions(+), 22 deletions(-)

diff --git a/common/recipes-core/ipmid/files/ipmid.c b/common/recipes-core/ipmid/files/ipmid.c
index a33ef6f..88ced5a 100644
--- a/common/recipes-core/ipmid/files/ipmid.c
+++ b/common/recipes-core/ipmid/files/ipmid.c
@@ -76,6 +76,18 @@ static pthread_mutex_t m_oem_q;
 static void ipmi_handle(unsigned char *request, unsigned char req_len,
        unsigned char *response, unsigned char *res_len);
 
+static int length_check(unsigned char cmd_len, unsigned char req_len, unsigned char *response, unsigned char *res_len)
+{  
+  ipmi_res_t *res = (ipmi_res_t *) response;
+  // req_len = cmd_len + 3 (payload_id, cmd and netfn)
+  if( req_len != (cmd_len + 3) ){
+    res->cc = CC_INVALID_LENGTH;
+    *res_len = 1;   
+    return 1;
+  }
+  return 0;
+}
+
 /*
  **Function to handle with clearing BIOS flag
  */
@@ -339,7 +351,8 @@ ipmi_handle_sensor(unsigned char *request, unsigned char req_len,
  */
 // Get Device ID (IPMI/Section 20.1)
 static void
-app_get_device_id (unsigned char *response, unsigned char *res_len)
+app_get_device_id (unsigned char *request, unsigned char req_len,
+                   unsigned char *response, unsigned char *res_len)
 {
 
   ipmi_res_t *res = (ipmi_res_t *) response;
@@ -348,6 +361,11 @@ app_get_device_id (unsigned char *response, unsigned char *res_len)
   int fv_major = 0x01, fv_minor = 0x03;
   char buffer[32];
 
+  if(length_check(0, req_len, response, res_len))
+  {
+    return;
+  }
+
   fp = fopen("/etc/issue","r");
   if (fp != NULL)
   {
@@ -380,7 +398,8 @@ app_get_device_id (unsigned char *response, unsigned char *res_len)
 
 // Cold Reset (IPMI/Section 20.2)
 static void
-app_cold_reset(void)
+app_cold_reset(unsigned char *request, unsigned char req_len,
+              unsigned char *response, unsigned char *res_len)
 {
   reboot(RB_AUTOBOOT);
 }
@@ -388,7 +407,8 @@ app_cold_reset(void)
 
 // Get Self Test Results (IPMI/Section 20.4)
 static void
-app_get_selftest_results (unsigned char *response, unsigned char *res_len)
+app_get_selftest_results (unsigned char *request, unsigned char req_len,
+              unsigned char *response, unsigned char *res_len)
 {
 
   ipmi_res_t *res = (ipmi_res_t *) response;
@@ -427,8 +447,8 @@ app_manufacturing_test_on (unsigned char *request, unsigned char req_len,
 
 // Get Device GUID (IPMI/Section 20.8)
 static void
-app_get_device_guid (unsigned char *request, unsigned char *response,
-                     unsigned char *res_len)
+app_get_device_guid (unsigned char *request, unsigned char req_len,
+                    unsigned char *response, unsigned char *res_len)
 {
   int ret;
 
@@ -447,8 +467,8 @@ app_get_device_guid (unsigned char *request, unsigned char *response,
 }
 
 static void
-app_get_device_sys_guid (unsigned char *request, unsigned char *response,
-                         unsigned char *res_len)
+app_get_device_sys_guid (unsigned char *request, unsigned char req_len,
+                        unsigned char *response, unsigned char *res_len)
 {
   int ret;
 
@@ -484,7 +504,8 @@ app_set_global_enables (unsigned char *request, unsigned char req_len,
 
 // Get BMC Global Enables (IPMI/Section 22.2)
 static void
-app_get_global_enables (unsigned char *response, unsigned char *res_len)
+app_get_global_enables (unsigned char *request, unsigned char req_len,
+                        unsigned char *response, unsigned char *res_len)
 {
 
   ipmi_res_t *res = (ipmi_res_t *) response;
@@ -515,8 +536,8 @@ app_clear_message_flags (unsigned char *request, unsigned char req_len,
 
 // Set System Info Params (IPMI/Section 22.14a)
 static void
-app_set_sys_info_params (unsigned char *request, unsigned char *response,
-       unsigned char *res_len)
+app_set_sys_info_params (unsigned char *request, unsigned char req_len,
+                         unsigned char *response, unsigned char *res_len)
 {
 
   ipmi_mn_req_t *req = (ipmi_mn_req_t *) request;
@@ -562,8 +583,8 @@ app_set_sys_info_params (unsigned char *request, unsigned char *response,
 
 // Get System Info Params (IPMI/Section 22.14b)
 static void
-app_get_sys_info_params (unsigned char *request, unsigned char *response,
-       unsigned char *res_len)
+app_get_sys_info_params (unsigned char *request, unsigned char req_len,
+                         unsigned char *response, unsigned char *res_len)
 {
 
   ipmi_mn_req_t *req = (ipmi_mn_req_t *) request;
@@ -624,7 +645,7 @@ app_get_sys_info_params (unsigned char *request, unsigned char *response,
 // Handle Appliction Commands (IPMI/Section 20)
 static void
 ipmi_handle_app (unsigned char *request, unsigned char req_len,
-     unsigned char *response, unsigned char *res_len)
+                unsigned char *response, unsigned char *res_len)
 {
   ipmi_mn_req_t *req = (ipmi_mn_req_t *) request;
   ipmi_res_t *res = (ipmi_res_t *) response;
@@ -634,37 +655,37 @@ ipmi_handle_app (unsigned char *request, unsigned char req_len,
   switch (cmd)
   {
     case CMD_APP_GET_DEVICE_ID:
-      app_get_device_id (response, res_len);
+      app_get_device_id (request, req_len, response, res_len);
       break;
     case CMD_APP_COLD_RESET:
-      app_cold_reset ();
+      app_cold_reset (request, req_len, response, res_len);
       break;
     case CMD_APP_GET_SELFTEST_RESULTS:
-      app_get_selftest_results (response, res_len);
+      app_get_selftest_results (request, req_len, response, res_len);
       break;
     case CMD_APP_MANUFACTURING_TEST_ON:
       app_manufacturing_test_on (request, req_len, response, res_len);
       break;
     case CMD_APP_GET_DEVICE_GUID:
-      app_get_device_guid (request, response, res_len);
+      app_get_device_guid (request, req_len, response, res_len);
       break;
     case CMD_APP_GET_SYSTEM_GUID:
-      app_get_device_sys_guid (request, response, res_len);
+      app_get_device_sys_guid (request, req_len, response, res_len);
       break;
     case CMD_APP_SET_GLOBAL_ENABLES:
       app_set_global_enables (request, req_len, response, res_len);
       break;
     case CMD_APP_GET_GLOBAL_ENABLES:
-      app_get_global_enables (response, res_len);
+      app_get_global_enables (request, req_len, response, res_len);
       break;
     case CMD_APP_SET_SYS_INFO_PARAMS:
-      app_set_sys_info_params (request, response, res_len);
+      app_set_sys_info_params (request, req_len, response, res_len);
       break;
     case CMD_APP_CLEAR_MESSAGE_FLAGS:
       app_clear_message_flags (request, req_len, response, res_len);
       break;
     case CMD_APP_GET_SYS_INFO_PARAMS:
-      app_get_sys_info_params (request, response, res_len);
+      app_get_sys_info_params (request,  req_len, response, res_len);
       break;
     default:
       res->cc = CC_INVALID_CMD;
@@ -2223,12 +2244,12 @@ ipmi_handle (unsigned char *request, unsigned char req_len,
   ipmi_mn_req_t *req = (ipmi_mn_req_t *) request;
   ipmi_res_t *res = (ipmi_res_t *) response;
   unsigned char netfn;
-
   netfn = req->netfn_lun >> 2;
 
   // Provide default values in the response message
   res->cmd = req->cmd;
   res->cc = 0xFF;   // Unspecified completion code
+  printf("ipmi_handle netfn %x cmd %x len %d\n", netfn, req->cmd, req_len);
   *(unsigned short*)res_len = 0;
 
   switch (netfn)
diff --git a/common/recipes-lib/ipmi/files/ipmi.h b/common/recipes-lib/ipmi/files/ipmi.h
index 9825f36..7e6d1c3 100644
--- a/common/recipes-lib/ipmi/files/ipmi.h
+++ b/common/recipes-lib/ipmi/files/ipmi.h
@@ -451,6 +451,7 @@ enum
   CC_SEL_ERASE_PROG = 0x81,
   CC_NODE_BUSY = 0xC0,
   CC_INVALID_CMD = 0xC1,
+  CC_INVALID_LENGTH = 0xC7,
   CC_PARAM_OUT_OF_RANGE = 0xC9,
   CC_UNSPECIFIED_ERROR = 0xFF,
 };

From 0d1cc13536240f0989d256732814abab1d84e8d7 Mon Sep 17 00:00:00 2001
From: Jack Hsin <Jack_Hsin@wiwynn.com>
Date: Wed, 22 Feb 2017 16:10:08 +0800
Subject: [PATCH 02/11] [FBTTN] IPMI OEM Command for BIOS current boot list
 Summary: Add the pal function for set/get bios current boot list. Save a
 setting file in BMC /tmp folder. Test Plan: Build and Test with System.

---
 .../recipes-fbttn/fblibs/files/pal/pal.c           | 45 ++++++++++++++++++++++
 .../recipes-fbttn/fblibs/files/pal/pal.h           |  2 +
 2 files changed, 47 insertions(+)

diff --git a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
index d362b33..29456eb 100644
--- a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
+++ b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
@@ -137,6 +137,7 @@
 
 #define PLATFORM_FILE "/tmp/system.bin"
 #define ERR_CODE_FILE "/tmp/error_code.bin"
+#define BOOT_LIST_FILE "/tmp/boot_list.bin"
 // SHIFT to 16
 #define UART1_TXD 0
 
@@ -3205,4 +3206,48 @@ void pal_add_cri_sel(char *str)
 
 }
 
+pal_set_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t list_length) {
+  FILE *fp;
+  int i;
+
+  fp = fopen(BOOT_LIST_FILE, "w");
+  if (!fp) {
+    int err = errno;
+#ifdef DEBUG
+    syslog(LOG_INFO, "failed to open device %s", BOOT_LIST_FILE);
+#endif
+    return err;
+  }
+  lockf(fileno(fp),F_LOCK,0L);
+
+  for(i = 0; i < list_length; i++) {
+    fprintf(fp, "%02X ", *(boot_list+i));
+  }
+  fprintf(fp, "\n");
+  lockf(fileno(fp),F_ULOCK,0L);
+  fclose(fp);
+}
 
+int
+pal_get_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t *list_length) {
+  FILE *fp;
+  uint8_t count=0;
+
+  fp = fopen(BOOT_LIST_FILE, "r");
+  if (!fp) {
+    int err = errno;
+#ifdef DEBUG
+    syslog(LOG_INFO, "failed to open device %s", BOOT_LIST_FILE);
+#endif
+    return err;
+  }
+  lockf(fileno(fp),F_LOCK,0L);
+
+  while (fscanf(fp, "%X", boot_list+count) != EOF) {
+      count++;
+  }
+  *list_length = count;
+  lockf(fileno(fp),F_ULOCK,0L);
+  fclose(fp);
+}
+>>>>>>> [FBTTN] IPMI OEM Command for BIOS current boot list
diff --git a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
index d9b3fb3..fafdd14 100644
--- a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
+++ b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
@@ -248,6 +248,8 @@ int pal_get_error_code(uint8_t* data, uint8_t* error_count);
 int pal_post_get_buffer(uint8_t *buffer, uint8_t *buf_len);
 int pal_is_crashdump_ongoing(uint8_t slot);
 void pal_add_cri_sel(char *str);
+int pal_set_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t list_length);
+int pal_get_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t *list_length);
 
 #ifdef __cplusplus
 } // extern "C"

From 1c67fc0f473e4e6c84c936085bd2079913206ee0 Mon Sep 17 00:00:00 2001
From: Jack Hsin <Jack_Hsin@wiwynn.com>
Date: Wed, 11 Jan 2017 15:13:39 +0800
Subject: [PATCH 03/11] [FBTTN][Common] IPMI OEM Command for BIOS current boot
 list Summary: in ipmid.c add the function in set/get system info parameter
 command. Code is defined only for FBTTN. Test Plan: Build and Test with
 System. [root@localhost ~]# ipmitool raw 0x6 0x58 0xc1 0x1 0x2 0x3 0x4 0x5

[root@localhost ~]# ipmitool raw 0x6 0x59 0x0 0xc1 0x0 0x0
01 01 02 03 04 05
---
 common/recipes-core/ipmid/files/ipmid.c | 97 ++++++++++++++++++++-------------
 common/recipes-lib/ipmi/files/ipmi.h    | 10 ++++
 2 files changed, 69 insertions(+), 38 deletions(-)

diff --git a/common/recipes-core/ipmid/files/ipmid.c b/common/recipes-core/ipmid/files/ipmid.c
index 88ced5a..264e866 100644
--- a/common/recipes-core/ipmid/files/ipmid.c
+++ b/common/recipes-core/ipmid/files/ipmid.c
@@ -573,6 +573,12 @@ app_set_sys_info_params (unsigned char *request, unsigned char req_len,
     case SYS_INFO_PARAM_OS_HV_URL:
       memcpy(g_sys_info_params.os_hv_url, &req->data[1], SIZE_OS_HV_URL);
       break;
+    #ifdef CONFIG_FBTTN
+      case SYS_INFO_PARAM_BIOS_CURRENT_BOOT_LIST:
+        memcpy(g_sys_info_params.bios_current_boot_list, &req->data[1], req_len-4); // boot list length = req_len-4 (payload_id, cmd, netfn, param)
+        pal_set_bios_current_boot_list(req->payload_id, g_sys_info_params.bios_current_boot_list, req_len-4);
+        break;
+    #endif
     default:
       res->cc = CC_INVALID_PARAM;
       break;
@@ -594,45 +600,60 @@ app_get_sys_info_params (unsigned char *request, unsigned char req_len,
 
   // Fill default return values
   res->cc = CC_SUCCESS;
-  *data++ = 1;    // Parameter revision
-
-  switch (param)
+  *data++ = 1;		// Parameter revision
+  if(!length_check(4, req_len, response, res_len))
   {
-    case SYS_INFO_PARAM_SET_IN_PROG:
-      *data++ = g_sys_info_params.set_in_prog;
-      break;
-    case SYS_INFO_PARAM_SYSFW_VER:
-      pal_get_sysfw_ver(req->payload_id, g_sys_info_params.sysfw_ver);
-      memcpy(data, g_sys_info_params.sysfw_ver, SIZE_SYSFW_VER);
-      data += SIZE_SYSFW_VER;
-      break;
-    case SYS_INFO_PARAM_SYS_NAME:
-      memcpy(data, g_sys_info_params.sys_name, SIZE_SYS_NAME);
-      data += SIZE_SYS_NAME;
-      break;
-    case SYS_INFO_PARAM_PRI_OS_NAME:
-      memcpy(data, g_sys_info_params.pri_os_name, SIZE_OS_NAME);
-      data += SIZE_OS_NAME;
-      break;
-    case SYS_INFO_PARAM_PRESENT_OS_NAME:
-      memcpy(data, g_sys_info_params.present_os_name, SIZE_OS_NAME);
-      data += SIZE_OS_NAME;
-      break;
-    case SYS_INFO_PARAM_PRESENT_OS_VER:
-      memcpy(data, g_sys_info_params.present_os_ver, SIZE_OS_VER);
-      data += SIZE_OS_VER;
-      break;
-    case SYS_INFO_PARAM_BMC_URL:
-      memcpy(data, g_sys_info_params.bmc_url, SIZE_BMC_URL);
-      data += SIZE_BMC_URL;
-      break;
-    case SYS_INFO_PARAM_OS_HV_URL:
-      memcpy(data, g_sys_info_params.os_hv_url, SIZE_OS_HV_URL);
-      data += SIZE_OS_HV_URL;
-      break;
-    default:
-      res->cc = CC_INVALID_PARAM;
-      break;
+    switch (param)
+    {
+      case SYS_INFO_PARAM_SET_IN_PROG:
+        *data++ = g_sys_info_params.set_in_prog;
+        break;
+      case SYS_INFO_PARAM_SYSFW_VER:
+        pal_get_sysfw_ver(req->payload_id, g_sys_info_params.sysfw_ver);
+        memcpy(data, g_sys_info_params.sysfw_ver, SIZE_SYSFW_VER);
+        data += SIZE_SYSFW_VER;
+        break;
+      case SYS_INFO_PARAM_SYS_NAME:
+        memcpy(data, g_sys_info_params.sys_name, SIZE_SYS_NAME);
+        data += SIZE_SYS_NAME;
+        break;
+      case SYS_INFO_PARAM_PRI_OS_NAME:
+        memcpy(data, g_sys_info_params.pri_os_name, SIZE_OS_NAME);
+        data += SIZE_OS_NAME;
+        break;
+      case SYS_INFO_PARAM_PRESENT_OS_NAME:
+        memcpy(data, g_sys_info_params.present_os_name, SIZE_OS_NAME);
+        data += SIZE_OS_NAME;
+        break;
+      case SYS_INFO_PARAM_PRESENT_OS_VER:
+        memcpy(data, g_sys_info_params.present_os_ver, SIZE_OS_VER);
+        data += SIZE_OS_VER;
+        break;
+      case SYS_INFO_PARAM_BMC_URL:
+        memcpy(data, g_sys_info_params.bmc_url, SIZE_BMC_URL);
+        data += SIZE_BMC_URL;
+        break;
+      case SYS_INFO_PARAM_OS_HV_URL:
+        memcpy(data, g_sys_info_params.os_hv_url, SIZE_OS_HV_URL);
+        data += SIZE_OS_HV_URL;
+        break;
+
+      #ifdef CONFIG_FBTTN
+        case SYS_INFO_PARAM_BIOS_CURRENT_BOOT_LIST:
+          if(pal_get_bios_current_boot_list(req->payload_id, g_sys_info_params.bios_current_boot_list, res_len))
+          {
+            res->cc = CC_UNSPECIFIED_ERROR;
+            break;
+          }
+          memcpy(data, g_sys_info_params.bios_current_boot_list, *res_len);
+          data += *res_len;
+          break;
+      #endif
+
+      default:
+        res->cc = CC_INVALID_PARAM;
+        break;
+    }
   }
 
   if (res->cc == CC_SUCCESS) {
diff --git a/common/recipes-lib/ipmi/files/ipmi.h b/common/recipes-lib/ipmi/files/ipmi.h
index 7e6d1c3..897bb15 100644
--- a/common/recipes-lib/ipmi/files/ipmi.h
+++ b/common/recipes-lib/ipmi/files/ipmi.h
@@ -56,6 +56,10 @@ extern "C" {
 #define SIZE_OS_VER 17
 #define SIZE_BMC_URL  17
 #define SIZE_OS_HV_URL  17
+#ifdef CONFIG_FBTTN
+  #define SIZE_BIOS_CURRENT_BOOT_LIST  250
+#endif
+
 
 #define SIZE_SEL_REC 16
 
@@ -268,6 +272,9 @@ typedef struct
   unsigned char present_os_ver[SIZE_OS_VER];
   unsigned char bmc_url[SIZE_BMC_URL];
   unsigned char os_hv_url[SIZE_OS_HV_URL];
+  #ifdef CONFIG_FBTTN
+    unsigned char bios_current_boot_list[SIZE_BIOS_CURRENT_BOOT_LIST];
+  #endif
 } sys_info_param_t;
 
 // Structure for Sensor Reading (IPMI/Section 35.14)
@@ -519,6 +526,9 @@ enum
   SYS_INFO_PARAM_PRESENT_OS_VER,
   SYS_INFO_PARAM_BMC_URL,
   SYS_INFO_PARAM_OS_HV_URL,
+  #ifdef CONFIG_FBTTN
+  SYS_INFO_PARAM_BIOS_CURRENT_BOOT_LIST = 0xC1,
+  #endif
 };
 
 // Bridge-IC interface on which this command initiated

From 15db6022a390a351d0013090a1c65ba5f1ba7283 Mon Sep 17 00:00:00 2001
From: Jack Hsin <Jack_Hsin@wiwynn.com>
Date: Wed, 11 Jan 2017 15:22:49 +0800
Subject: [PATCH 04/11] [FBTTN] IPMI OEM Command for BIOS fixed boot device
 Summary: Add the pal function for set/get bios fixed boot device. Save a
 setting file in BMC /tmp folder. Test Plan: Build and Test with System.

---
 .../recipes-fbttn/fblibs/files/pal/pal.c           | 44 +++++++++++++++++++++-
 .../recipes-fbttn/fblibs/files/pal/pal.h           |  2 +
 2 files changed, 45 insertions(+), 1 deletion(-)

diff --git a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
index 29456eb..410f6ba 100644
--- a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
+++ b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
@@ -138,6 +138,7 @@
 #define PLATFORM_FILE "/tmp/system.bin"
 #define ERR_CODE_FILE "/tmp/error_code.bin"
 #define BOOT_LIST_FILE "/tmp/boot_list.bin"
+#define FIXED_BOOT_DEVICE_FILE "/tmp/fixed_boot_device.bin"
 // SHIFT to 16
 #define UART1_TXD 0
 
@@ -3250,4 +3251,45 @@ pal_get_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t *list_l
   lockf(fileno(fp),F_ULOCK,0L);
   fclose(fp);
 }
->>>>>>> [FBTTN] IPMI OEM Command for BIOS current boot list
+
+int
+pal_set_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device) {
+  FILE *fp;
+
+  fp = fopen(FIXED_BOOT_DEVICE_FILE, "w");
+  if (!fp) {
+    int err = errno;
+#ifdef DEBUG
+    syslog(LOG_INFO, "failed to open device %s", FIXED_BOOT_DEVICE_FILE);
+#endif
+    return err;
+  }
+  lockf(fileno(fp),F_LOCK,0L);
+
+  fprintf(fp, "%02X ", *fixed_boot_device);
+  fprintf(fp, "\n");
+
+  lockf(fileno(fp),F_ULOCK,0L);
+  fclose(fp);
+}
+
+int
+pal_get_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device) {
+  FILE *fp;
+
+  fp = fopen(FIXED_BOOT_DEVICE_FILE, "r");
+  if (!fp) {
+    int err = errno;
+#ifdef DEBUG
+    syslog(LOG_INFO, "failed to open device %s", FIXED_BOOT_DEVICE_FILE);
+#endif
+    return err;
+  }
+  lockf(fileno(fp),F_LOCK,0L);
+
+  fscanf(fp, "%X", fixed_boot_device);
+
+  lockf(fileno(fp),F_ULOCK,0L);
+  fclose(fp);
+}
+>>>>>>> [FBTTN] IPMI OEM Command for BIOS fixed boot device
diff --git a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
index fafdd14..977220f 100644
--- a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
+++ b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
@@ -250,6 +250,8 @@ int pal_is_crashdump_ongoing(uint8_t slot);
 void pal_add_cri_sel(char *str);
 int pal_set_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t list_length);
 int pal_get_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t *list_length);
+int pal_set_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device);
+int pal_get_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device);
 
 #ifdef __cplusplus
 } // extern "C"

From d32a52aa95469e5ffc271292de624230875919d8 Mon Sep 17 00:00:00 2001
From: Jack Hsin <Jack_Hsin@wiwynn.com>
Date: Wed, 11 Jan 2017 15:23:52 +0800
Subject: [PATCH 05/11] [FBTTN][Common] IPMI OEM Command for BIOS fixed boot
 device Summary: In ipmid.c add the function in set/get system info parameter
 command. Code is defined only for FBTTN. Test Plan: Build and Test with
 System.

[root@localhost Jack]# ipmitool raw 0x6 0x58 0xc2 0x1

[root@localhost Jack]# ipmitool raw 0x6 0x59 0x0 0xc2 0x0 0x0
 01 01
---
 common/recipes-core/ipmid/files/ipmid.c | 15 +++++++++++++++
 common/recipes-lib/ipmi/files/ipmi.h    |  3 +++
 2 files changed, 18 insertions(+)

diff --git a/common/recipes-core/ipmid/files/ipmid.c b/common/recipes-core/ipmid/files/ipmid.c
index 264e866..67a2f8f 100644
--- a/common/recipes-core/ipmid/files/ipmid.c
+++ b/common/recipes-core/ipmid/files/ipmid.c
@@ -578,6 +578,12 @@ app_set_sys_info_params (unsigned char *request, unsigned char req_len,
         memcpy(g_sys_info_params.bios_current_boot_list, &req->data[1], req_len-4); // boot list length = req_len-4 (payload_id, cmd, netfn, param)
         pal_set_bios_current_boot_list(req->payload_id, g_sys_info_params.bios_current_boot_list, req_len-4);
         break;
+      case SYS_INFO_PARAM_BIOS_FIXED_BOOT_DEVICE:
+        if(length_check(SIZE_BIOS_FIXED_BOOT_DEVICE+1, req_len, response, res_len))
+          break;
+        memcpy(g_sys_info_params.bios_fixed_boot_device, &req->data[1], SIZE_BIOS_FIXED_BOOT_DEVICE);
+        pal_set_bios_fixed_boot_device(req->payload_id, g_sys_info_params.bios_fixed_boot_device);
+        break;
     #endif
     default:
       res->cc = CC_INVALID_PARAM;
@@ -648,6 +654,15 @@ app_get_sys_info_params (unsigned char *request, unsigned char req_len,
           memcpy(data, g_sys_info_params.bios_current_boot_list, *res_len);
           data += *res_len;
           break;
+        case SYS_INFO_PARAM_BIOS_FIXED_BOOT_DEVICE:
+          if(pal_get_bios_fixed_boot_device(req->payload_id, g_sys_info_params.bios_fixed_boot_device))
+          {
+            res->cc = CC_UNSPECIFIED_ERROR;
+            break;
+          }
+          memcpy(data, g_sys_info_params.bios_fixed_boot_device, SIZE_BIOS_FIXED_BOOT_DEVICE);
+          data += SIZE_BIOS_FIXED_BOOT_DEVICE;
+          break;
       #endif
 
       default:
diff --git a/common/recipes-lib/ipmi/files/ipmi.h b/common/recipes-lib/ipmi/files/ipmi.h
index 897bb15..b922e95 100644
--- a/common/recipes-lib/ipmi/files/ipmi.h
+++ b/common/recipes-lib/ipmi/files/ipmi.h
@@ -58,6 +58,7 @@ extern "C" {
 #define SIZE_OS_HV_URL  17
 #ifdef CONFIG_FBTTN
   #define SIZE_BIOS_CURRENT_BOOT_LIST  250
+  #define SIZE_BIOS_FIXED_BOOT_DEVICE 1
 #endif
 
 
@@ -274,6 +275,7 @@ typedef struct
   unsigned char os_hv_url[SIZE_OS_HV_URL];
   #ifdef CONFIG_FBTTN
     unsigned char bios_current_boot_list[SIZE_BIOS_CURRENT_BOOT_LIST];
+    unsigned char bios_fixed_boot_device[SIZE_BIOS_FIXED_BOOT_DEVICE];
   #endif
 } sys_info_param_t;
 
@@ -528,6 +530,7 @@ enum
   SYS_INFO_PARAM_OS_HV_URL,
   #ifdef CONFIG_FBTTN
   SYS_INFO_PARAM_BIOS_CURRENT_BOOT_LIST = 0xC1,
+  SYS_INFO_PARAM_BIOS_FIXED_BOOT_DEVICE = 0xC2,
   #endif
 };
 

From 020f934dd528e3ba0e1ee3f000d44fb4743d9bac Mon Sep 17 00:00:00 2001
From: Jack Hsin <Jack_Hsin@wiwynn.com>
Date: Wed, 11 Jan 2017 17:16:57 +0800
Subject: [PATCH 06/11] [FBTTN] IPMI OEM Command for BIOS restores to default
 setting Summary: Add the pal function for set/get bios restore default
 setting. Save a setting file in BMC /tmp folder. Add a thread for handler
 countdown timer for remove setting. Test Plan: Build and Test with System.

---
 .../recipes-fbttn/fblibs/files/pal/pal.c           | 67 ++++++++++++++++++++++
 .../recipes-fbttn/fblibs/files/pal/pal.h           |  2 +
 2 files changed, 69 insertions(+)

diff --git a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
index 410f6ba..058b696 100644
--- a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
+++ b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
@@ -139,6 +139,7 @@
 #define ERR_CODE_FILE "/tmp/error_code.bin"
 #define BOOT_LIST_FILE "/tmp/boot_list.bin"
 #define FIXED_BOOT_DEVICE_FILE "/tmp/fixed_boot_device.bin"
+#define BIOS_DEFAULT_SETTING_FILE "/tmp/bios_default_setting.bin"
 // SHIFT to 16
 #define UART1_TXD 0
 
@@ -170,6 +171,8 @@ const char pal_pwm_list[] = "0, 1";
 const char pal_tach_list[] = "0...7";
 uint8_t fanid2pwmid_mapping[] = {0, 0, 0, 0, 1, 1, 1, 1};
 
+static uint8_t bios_default_setting_timer_flag = 0;
+
 char * key_list[] = {
 "pwr_server1_last_state",
 "sysfw_ver_slot1",
@@ -3273,6 +3276,70 @@ pal_set_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device) {
   fclose(fp);
 }
 
+int pal_clear_bios_default_setting_timer_handler(){
+  uint8_t default_setting;
+
+  sleep(200);
+
+  pal_get_bios_restores_default_setting(1, &default_setting);
+  if(default_setting != 0) {
+    default_setting = 0;
+    pal_set_bios_restores_default_setting(1, &default_setting);
+  }
+  bios_default_setting_timer_flag = 0;
+}
+
+int
+pal_set_bios_restores_default_setting(uint8_t slot, uint8_t *default_setting) {
+  FILE *fp;
+  pthread_t tid_clear_bios_default_setting_timer;
+
+  fp = fopen(BIOS_DEFAULT_SETTING_FILE, "w");
+  if (!fp) {
+    int err = errno;
+#ifdef DEBUG
+    syslog(LOG_INFO, "failed to open device %s", BIOS_DEFAULT_SETTING_FILE);
+#endif
+    return err;
+  }
+  lockf(fileno(fp),F_LOCK,0L);
+ 
+  fprintf(fp, "%02X ", *default_setting);
+  fprintf(fp, "\n");
+
+  lockf(fileno(fp),F_ULOCK,0L);
+  fclose(fp);
+
+  //Hack a thread wait a certain time then clear the setting, if user didn't reboot the System.
+  if(!bios_default_setting_timer_flag) {
+    if (pthread_create(&tid_clear_bios_default_setting_timer, NULL, pal_clear_bios_default_setting_timer_handler, NULL) < 0) {
+      syslog(LOG_WARNING, "pthread_create for clear default setting timer error\n");
+      exit(1);
+    }
+    else
+      bios_default_setting_timer_flag = 1;
+  }
+}
+
+int
+pal_get_bios_restores_default_setting(uint8_t slot, uint8_t *default_setting) {
+  FILE *fp;
+
+  fp = fopen(BIOS_DEFAULT_SETTING_FILE, "r");
+  if (!fp) {
+    int err = errno;
+#ifdef DEBUG
+    syslog(LOG_INFO, "failed to open device %s", BIOS_DEFAULT_SETTING_FILE);
+#endif
+    return err;
+  }
+  lockf(fileno(fp),F_LOCK,0L);
+
+  fscanf(fp, "%X", default_setting);
+
+  lockf(fileno(fp),F_ULOCK,0L);
+  fclose(fp);
+}
 int
 pal_get_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device) {
   FILE *fp;
diff --git a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
index 977220f..edb62dc 100644
--- a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
+++ b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
@@ -252,6 +252,8 @@ int pal_set_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t lis
 int pal_get_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t *list_length);
 int pal_set_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device);
 int pal_get_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device);
+int pal_set_bios_restores_default_setting(uint8_t slot, uint8_t *default_setting);
+int pal_get_bios_restores_default_setting(uint8_t slot, uint8_t *default_setting);
 
 #ifdef __cplusplus
 } // extern "C"

From f275c69902fefc4c4fe6091c40e5295342b0e49f Mon Sep 17 00:00:00 2001
From: Jack Hsin <Jack_Hsin@wiwynn.com>
Date: Wed, 22 Feb 2017 16:56:50 +0800
Subject: [PATCH 07/11] [FBTTN][Common] IPMI OEM Command for BIOS restores to
 default setting Summary: in ipmid.c add the function in set/get system info
 parameter command. Code is defined only for FBTTN. Test Plan: Build and Test
 with System.

[root@localhost ~]# ipmitool raw 0x6 0x58 0xc3 0x1

[root@localhost ~]# ipmitool raw 0x6 0x59 0x0 0xc3 0x0 0x0
 01 01
---
 common/recipes-core/ipmid/files/ipmid.c                 | 17 +++++++++++++++++
 common/recipes-lib/ipmi/files/ipmi.h                    |  7 +++++--
 .../meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c     |  5 +++--
 3 files changed, 25 insertions(+), 4 deletions(-)

diff --git a/common/recipes-core/ipmid/files/ipmid.c b/common/recipes-core/ipmid/files/ipmid.c
index 67a2f8f..966b36e 100644
--- a/common/recipes-core/ipmid/files/ipmid.c
+++ b/common/recipes-core/ipmid/files/ipmid.c
@@ -573,6 +573,7 @@ app_set_sys_info_params (unsigned char *request, unsigned char req_len,
     case SYS_INFO_PARAM_OS_HV_URL:
       memcpy(g_sys_info_params.os_hv_url, &req->data[1], SIZE_OS_HV_URL);
       break;
+
     #ifdef CONFIG_FBTTN
       case SYS_INFO_PARAM_BIOS_CURRENT_BOOT_LIST:
         memcpy(g_sys_info_params.bios_current_boot_list, &req->data[1], req_len-4); // boot list length = req_len-4 (payload_id, cmd, netfn, param)
@@ -584,7 +585,14 @@ app_set_sys_info_params (unsigned char *request, unsigned char req_len,
         memcpy(g_sys_info_params.bios_fixed_boot_device, &req->data[1], SIZE_BIOS_FIXED_BOOT_DEVICE);
         pal_set_bios_fixed_boot_device(req->payload_id, g_sys_info_params.bios_fixed_boot_device);
         break;
+      case SYS_INFO_PARAM_BIOS_RESTORES_DEFAULT_SETTING:
+        if(length_check(SIZE_BIOS_RESTORES_DEFAULT_SETTING+1, req_len, response, res_len))
+          break;
+        memcpy(g_sys_info_params.bios_restores_default_setting, &req->data[1], SIZE_BIOS_RESTORES_DEFAULT_SETTING); 
+        pal_set_bios_restores_default_setting(req->payload_id, g_sys_info_params.bios_restores_default_setting);
+        break;
     #endif
+
     default:
       res->cc = CC_INVALID_PARAM;
       break;
@@ -663,6 +671,15 @@ app_get_sys_info_params (unsigned char *request, unsigned char req_len,
           memcpy(data, g_sys_info_params.bios_fixed_boot_device, SIZE_BIOS_FIXED_BOOT_DEVICE);
           data += SIZE_BIOS_FIXED_BOOT_DEVICE;
           break;
+        case SYS_INFO_PARAM_BIOS_RESTORES_DEFAULT_SETTING:
+          if(pal_get_bios_restores_default_setting(req->payload_id, g_sys_info_params.bios_restores_default_setting))
+          {
+            res->cc = CC_UNSPECIFIED_ERROR;
+            break;
+          }
+          memcpy(data, g_sys_info_params.bios_restores_default_setting, SIZE_BIOS_RESTORES_DEFAULT_SETTING);
+          data += SIZE_BIOS_RESTORES_DEFAULT_SETTING;
+          break;
       #endif
 
       default:
diff --git a/common/recipes-lib/ipmi/files/ipmi.h b/common/recipes-lib/ipmi/files/ipmi.h
index b922e95..f174ba9 100644
--- a/common/recipes-lib/ipmi/files/ipmi.h
+++ b/common/recipes-lib/ipmi/files/ipmi.h
@@ -59,6 +59,7 @@ extern "C" {
 #ifdef CONFIG_FBTTN
   #define SIZE_BIOS_CURRENT_BOOT_LIST  250
   #define SIZE_BIOS_FIXED_BOOT_DEVICE 1
+  #define SIZE_BIOS_RESTORES_DEFAULT_SETTING 1
 #endif
 
 
@@ -276,6 +277,7 @@ typedef struct
   #ifdef CONFIG_FBTTN
     unsigned char bios_current_boot_list[SIZE_BIOS_CURRENT_BOOT_LIST];
     unsigned char bios_fixed_boot_device[SIZE_BIOS_FIXED_BOOT_DEVICE];
+    unsigned char bios_restores_default_setting[SIZE_BIOS_RESTORES_DEFAULT_SETTING];
   #endif
 } sys_info_param_t;
 
@@ -529,8 +531,9 @@ enum
   SYS_INFO_PARAM_BMC_URL,
   SYS_INFO_PARAM_OS_HV_URL,
   #ifdef CONFIG_FBTTN
-  SYS_INFO_PARAM_BIOS_CURRENT_BOOT_LIST = 0xC1,
-  SYS_INFO_PARAM_BIOS_FIXED_BOOT_DEVICE = 0xC2,
+    SYS_INFO_PARAM_BIOS_CURRENT_BOOT_LIST = 0xC1,
+    SYS_INFO_PARAM_BIOS_FIXED_BOOT_DEVICE = 0xC2,
+    SYS_INFO_PARAM_BIOS_RESTORES_DEFAULT_SETTING = 0xC3,
   #endif
 };
 
diff --git a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
index 058b696..2b108f6 100644
--- a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
+++ b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
@@ -3279,6 +3279,8 @@ pal_set_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device) {
 int pal_clear_bios_default_setting_timer_handler(){
   uint8_t default_setting;
 
+  bios_default_setting_timer_flag = 0;
+
   sleep(200);
 
   pal_get_bios_restores_default_setting(1, &default_setting);
@@ -3286,7 +3288,6 @@ int pal_clear_bios_default_setting_timer_handler(){
     default_setting = 0;
     pal_set_bios_restores_default_setting(1, &default_setting);
   }
-  bios_default_setting_timer_flag = 0;
 }
 
 int
@@ -3310,7 +3311,7 @@ pal_set_bios_restores_default_setting(uint8_t slot, uint8_t *default_setting) {
   lockf(fileno(fp),F_ULOCK,0L);
   fclose(fp);
 
-  //Hack a thread wait a certain time then clear the setting, if user didn't reboot the System.
+  //Hack a thread wait a certain time then clear the setting, when userA didn't reboot the System, and userB doesn't know about the setting.
   if(!bios_default_setting_timer_flag) {
     if (pthread_create(&tid_clear_bios_default_setting_timer, NULL, pal_clear_bios_default_setting_timer_handler, NULL) < 0) {
       syslog(LOG_WARNING, "pthread_create for clear default setting timer error\n");

From cfff7d5309309fb89839f5ce8620a8d3efddd0c8 Mon Sep 17 00:00:00 2001
From: Jack Hsin <Jack_Hsin@wiwynn.com>
Date: Wed, 11 Jan 2017 17:52:02 +0800
Subject: [PATCH 08/11] [FBTTN] IPMI OEM Command for BIOS last boot time
 Summary: Add the pal function for set/get bios last boot time. Save a setting
 file in BMC /tmp folder. Add a OS status off to clear last boot time to 0 0 0
 0 in pal_set_last_pwr_state Test Plan: Build and Test with System.

---
 .../recipes-fbttn/fblibs/files/pal/pal.c           | 52 ++++++++++++++++++++++
 .../recipes-fbttn/fblibs/files/pal/pal.h           |  2 +
 2 files changed, 54 insertions(+)

diff --git a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
index 2b108f6..8c115ec 100644
--- a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
+++ b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
@@ -140,6 +140,7 @@
 #define BOOT_LIST_FILE "/tmp/boot_list.bin"
 #define FIXED_BOOT_DEVICE_FILE "/tmp/fixed_boot_device.bin"
 #define BIOS_DEFAULT_SETTING_FILE "/tmp/bios_default_setting.bin"
+#define LAST_BOOT_TIME "/tmp/last_boot_time.bin"
 // SHIFT to 16
 #define UART1_TXD 0
 
@@ -1574,9 +1575,14 @@ pal_set_last_pwr_state(uint8_t fru, char *state) {
 
   int ret;
   char key[MAX_KEY_LEN] = {0};
+  uint8_t last_boot_time[4] = {0};
 
   sprintf(key, "pwr_server%d_last_state", (int) fru);
 
+  //If the OS state is "off", clear the last boot time to 0 0 0 0
+  if(!strcmp(state, "off"))
+    pal_set_last_boot_time(1, last_boot_time);
+
   ret = pal_set_key_value(key, state);
   if (ret < 0) {
 #ifdef DEBUG
@@ -3341,7 +3347,53 @@ pal_get_bios_restores_default_setting(uint8_t slot, uint8_t *default_setting) {
   lockf(fileno(fp),F_ULOCK,0L);
   fclose(fp);
 }
+
+int
+pal_set_last_boot_time(uint8_t slot, uint8_t *last_boot_time) {
+  FILE *fp;
+  int i;
+
+  fp = fopen(LAST_BOOT_TIME, "w");
+  if (!fp) {
+    int err = errno;
+#ifdef DEBUG
+    syslog(LOG_INFO, "failed to open device %s", LAST_BOOT_TIME);
+#endif
+    return err;
+  }
+  lockf(fileno(fp),F_LOCK,0L);
+ 
+  for(i = 0; i < 4; i++) {
+    fprintf(fp, "%02X ", *(last_boot_time+i));  
+  }
+  fprintf(fp, "\n");
+
+  lockf(fileno(fp),F_ULOCK,0L);
+  fclose(fp);
+}
+
 int
+pal_get_last_boot_time(uint8_t slot, uint8_t *last_boot_time) {
+  FILE *fp;
+  int i;
+
+  fp = fopen(LAST_BOOT_TIME, "r");
+  if (!fp) {
+    int err = errno;
+#ifdef DEBUG
+    syslog(LOG_INFO, "failed to open device %s", LAST_BOOT_TIME);
+#endif
+    return err;
+  }
+  lockf(fileno(fp),F_LOCK,0L);
+
+  for(i = 0; i < 4; i++) {    
+    fscanf(fp, "%X", last_boot_time+i);  
+  }
+
+  lockf(fileno(fp),F_ULOCK,0L);
+  fclose(fp);
+}int
 pal_get_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device) {
   FILE *fp;
 
diff --git a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
index edb62dc..f41f650 100644
--- a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
+++ b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
@@ -254,6 +254,8 @@ int pal_set_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device);
 int pal_get_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device);
 int pal_set_bios_restores_default_setting(uint8_t slot, uint8_t *default_setting);
 int pal_get_bios_restores_default_setting(uint8_t slot, uint8_t *default_setting);
+int pal_set_last_boot_time(uint8_t slot, uint8_t *last_boot_time);
+int pal_get_last_boot_time(uint8_t slot, uint8_t *last_boot_time);
 
 #ifdef __cplusplus
 } // extern "C"

From 50ce897648750106456295147ab42c672200bd6a Mon Sep 17 00:00:00 2001
From: Jack Hsin <Jack_Hsin@wiwynn.com>
Date: Wed, 11 Jan 2017 17:53:20 +0800
Subject: [PATCH 09/11] [FBTTN][Common] IPMI OEM Command for BIOS last boot
 time Summary: in ipmid.c add the function in set/get system info parameter
 command. Code is defined only for FBTTN. Test Plan: Build and Test with
 System.

[root@localhost ~]# ipmitool raw 0x6 0x58 0xc4 0x1 0x3 0x5 0x7

[root@localhost ~]# ipmitool raw 0x6 0x59 0x0 0xc4 0x0 0x0
 01 01 03 05 07
[root@localhost ~]#

-----------------------
Exit from SOL session.
root@bmc:/tmp#
root@bmc:/tmp# cat last_boot_time.bin
01 03 05 07
root@bmc:/tmp# power-util slot1 off
Powering fru 1 to OFF state...
root@bmc:/tmp# cat last_boot_time.bin
00 00 00 00
---
 common/recipes-core/ipmid/files/ipmid.c | 15 +++++++++++++++
 common/recipes-lib/ipmi/files/ipmi.h    |  3 +++
 2 files changed, 18 insertions(+)

diff --git a/common/recipes-core/ipmid/files/ipmid.c b/common/recipes-core/ipmid/files/ipmid.c
index 966b36e..0d68264 100644
--- a/common/recipes-core/ipmid/files/ipmid.c
+++ b/common/recipes-core/ipmid/files/ipmid.c
@@ -591,6 +591,12 @@ app_set_sys_info_params (unsigned char *request, unsigned char req_len,
         memcpy(g_sys_info_params.bios_restores_default_setting, &req->data[1], SIZE_BIOS_RESTORES_DEFAULT_SETTING); 
         pal_set_bios_restores_default_setting(req->payload_id, g_sys_info_params.bios_restores_default_setting);
         break;
+      case SYS_INFO_PARAM_LAST_BOOT_TIME:
+        if(length_check(SIZE_LAST_BOOT_TIME+1, req_len, response, res_len))
+          break;
+        memcpy(g_sys_info_params.last_boot_time, &req->data[1], SIZE_LAST_BOOT_TIME); 
+        pal_set_last_boot_time(req->payload_id, g_sys_info_params.last_boot_time);
+        break;
     #endif
 
     default:
@@ -680,6 +686,15 @@ app_get_sys_info_params (unsigned char *request, unsigned char req_len,
           memcpy(data, g_sys_info_params.bios_restores_default_setting, SIZE_BIOS_RESTORES_DEFAULT_SETTING);
           data += SIZE_BIOS_RESTORES_DEFAULT_SETTING;
           break;
+        case SYS_INFO_PARAM_LAST_BOOT_TIME:
+          if(pal_get_last_boot_time(req->payload_id, g_sys_info_params.last_boot_time))
+          {
+            res->cc = CC_UNSPECIFIED_ERROR;
+            break;
+          }
+          memcpy(data, g_sys_info_params.last_boot_time, SIZE_LAST_BOOT_TIME);
+          data += SIZE_LAST_BOOT_TIME;
+          break;
       #endif
 
       default:
diff --git a/common/recipes-lib/ipmi/files/ipmi.h b/common/recipes-lib/ipmi/files/ipmi.h
index f174ba9..3b6d2f1 100644
--- a/common/recipes-lib/ipmi/files/ipmi.h
+++ b/common/recipes-lib/ipmi/files/ipmi.h
@@ -60,6 +60,7 @@ extern "C" {
   #define SIZE_BIOS_CURRENT_BOOT_LIST  250
   #define SIZE_BIOS_FIXED_BOOT_DEVICE 1
   #define SIZE_BIOS_RESTORES_DEFAULT_SETTING 1
+  #define SIZE_LAST_BOOT_TIME 4
 #endif
 
 
@@ -278,6 +279,7 @@ typedef struct
     unsigned char bios_current_boot_list[SIZE_BIOS_CURRENT_BOOT_LIST];
     unsigned char bios_fixed_boot_device[SIZE_BIOS_FIXED_BOOT_DEVICE];
     unsigned char bios_restores_default_setting[SIZE_BIOS_RESTORES_DEFAULT_SETTING];
+    unsigned char last_boot_time[SIZE_LAST_BOOT_TIME];
   #endif
 } sys_info_param_t;
 
@@ -534,6 +536,7 @@ enum
     SYS_INFO_PARAM_BIOS_CURRENT_BOOT_LIST = 0xC1,
     SYS_INFO_PARAM_BIOS_FIXED_BOOT_DEVICE = 0xC2,
     SYS_INFO_PARAM_BIOS_RESTORES_DEFAULT_SETTING = 0xC3,
+    SYS_INFO_PARAM_LAST_BOOT_TIME = 0xC4,
   #endif
 };
 

From 2b4d857038d6a55a8c2b5bd54c1cc94420013512 Mon Sep 17 00:00:00 2001
From: Jack Hsin <Jack_Hsin@wiwynn.com>
Date: Fri, 13 Jan 2017 14:15:37 +0800
Subject: [PATCH 10/11] [FBTTN][Common] Check IPMI OEM Command BIOS Boot
 Current List First Byte Summary: IPMI OEM Command BIOS Boot Current List
 First Byte have to be 1(data 1- Boot Mode(always 0x01: UEFI mode) If not 1
 return 0x80 CC_INVALID_PARAM CC Code. Test Plan: Build and Test with system.

Pass:
[root@localhost FIO]# ipmitool raw 0x6 0x58 0xc1 0x1 0x3 0x4 0x5

[root@localhost FIO]# ipmitool raw 0x6 0x59 0x0 0xc1 0x0 0x0
 01 01 03 04 05
Fail:
[root@localhost FIO]# ipmitool raw 0x6 0x58 0xc1 0x2 0x3 0x4 0x5
Unable to send RAW command (channel=0x0 netfn=0x6 lun=0x0 cmd=0x58 rsp=0x80): Unknown (0x80)
---
 common/recipes-core/ipmid/files/ipmid.c                |  2 +-
 .../meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c    | 18 ++++++++++++------
 .../meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h    |  2 +-
 3 files changed, 14 insertions(+), 8 deletions(-)

diff --git a/common/recipes-core/ipmid/files/ipmid.c b/common/recipes-core/ipmid/files/ipmid.c
index 0d68264..2526980 100644
--- a/common/recipes-core/ipmid/files/ipmid.c
+++ b/common/recipes-core/ipmid/files/ipmid.c
@@ -577,7 +577,7 @@ app_set_sys_info_params (unsigned char *request, unsigned char req_len,
     #ifdef CONFIG_FBTTN
       case SYS_INFO_PARAM_BIOS_CURRENT_BOOT_LIST:
         memcpy(g_sys_info_params.bios_current_boot_list, &req->data[1], req_len-4); // boot list length = req_len-4 (payload_id, cmd, netfn, param)
-        pal_set_bios_current_boot_list(req->payload_id, g_sys_info_params.bios_current_boot_list, req_len-4);
+        pal_set_bios_current_boot_list(req->payload_id, g_sys_info_params.bios_current_boot_list, req_len-4, &res->cc);
         break;
       case SYS_INFO_PARAM_BIOS_FIXED_BOOT_DEVICE:
         if(length_check(SIZE_BIOS_FIXED_BOOT_DEVICE+1, req_len, response, res_len))
diff --git a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
index 8c115ec..ff31f0a 100644
--- a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
+++ b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
@@ -3216,10 +3216,16 @@ void pal_add_cri_sel(char *str)
 
 }
 
-pal_set_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t list_length) {
+int
+pal_set_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t list_length, uint8_t *cc) {
   FILE *fp;
   int i;
 
+  if(*boot_list != 1) {
+    *cc = CC_INVALID_PARAM;
+    return -1;
+  }
+
   fp = fopen(BOOT_LIST_FILE, "w");
   if (!fp) {
     int err = errno;
@@ -3310,7 +3316,7 @@ pal_set_bios_restores_default_setting(uint8_t slot, uint8_t *default_setting) {
     return err;
   }
   lockf(fileno(fp),F_LOCK,0L);
- 
+
   fprintf(fp, "%02X ", *default_setting);
   fprintf(fp, "\n");
 
@@ -3362,9 +3368,9 @@ pal_set_last_boot_time(uint8_t slot, uint8_t *last_boot_time) {
     return err;
   }
   lockf(fileno(fp),F_LOCK,0L);
- 
+
   for(i = 0; i < 4; i++) {
-    fprintf(fp, "%02X ", *(last_boot_time+i));  
+    fprintf(fp, "%02X ", *(last_boot_time+i));
   }
   fprintf(fp, "\n");
 
@@ -3387,8 +3393,8 @@ pal_get_last_boot_time(uint8_t slot, uint8_t *last_boot_time) {
   }
   lockf(fileno(fp),F_LOCK,0L);
 
-  for(i = 0; i < 4; i++) {    
-    fscanf(fp, "%X", last_boot_time+i);  
+  for(i = 0; i < 4; i++) {
+    fscanf(fp, "%X", last_boot_time+i);
   }
 
   lockf(fileno(fp),F_ULOCK,0L);
diff --git a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
index f41f650..33c97fc 100644
--- a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
+++ b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.h
@@ -248,7 +248,7 @@ int pal_get_error_code(uint8_t* data, uint8_t* error_count);
 int pal_post_get_buffer(uint8_t *buffer, uint8_t *buf_len);
 int pal_is_crashdump_ongoing(uint8_t slot);
 void pal_add_cri_sel(char *str);
-int pal_set_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t list_length);
+int pal_set_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t list_length, uint8_t *cc);
 int pal_get_bios_current_boot_list(uint8_t slot, uint8_t *boot_list, uint8_t *list_length);
 int pal_set_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device);
 int pal_get_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device);

From 0b1c2fdfd36e226d2ce021fec2cc39e5c1f85e8f Mon Sep 17 00:00:00 2001
From: Delko <delko_wang@wiwynn.com>
Date: Fri, 17 Feb 2017 04:40:08 -0500
Subject: [PATCH 11/11] [BryceCanyon] Support IPMI command set/get boot option
 Summary: It is for set/get boot option function. Add 4 function in pal lib.
 pal_set_boot_option: set boot option function pal_get_boot_option: get boot
 option function pal_save_boot_option: cache the boot option
 pal_load_boot_option: read the boot option from cache

Test Plan: It is verified on BryceCanyon system with ipmi inband interface.
In OS:
1. ipmitool chassis bootdev bios
2. reboot
3. Check the host stauts

Conflicts:

	meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
---
 .../recipes-fbttn/fblibs/files/pal/pal.c           | 54 +++++++++++++++++++++-
 1 file changed, 53 insertions(+), 1 deletion(-)

diff --git a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
index ff31f0a..b60d1e8 100644
--- a/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
+++ b/meta-facebook/meta-fbttn/recipes-fbttn/fblibs/files/pal/pal.c
@@ -3418,4 +3418,56 @@ pal_get_bios_fixed_boot_device(uint8_t slot, uint8_t *fixed_boot_device) {
   lockf(fileno(fp),F_ULOCK,0L);
   fclose(fp);
 }
->>>>>>> [FBTTN] IPMI OEM Command for BIOS fixed boot device
+
+unsigned char option_offset[] = {0,1,2,3,4,6,11,20,37,164};
+unsigned char option_size[]   = {1,1,1,1,2,5,9 ,17,127};
+void pal_save_boot_option(unsigned char* buff)
+{
+  int fp = 0;
+  fp = open("/tmp/boot.in", O_WRONLY|O_CREAT);
+  if(fp > 0 )
+  {
+	write(fp,buff,256);
+    close(fp);
+  }
+}
+int pal_load_boot_option(unsigned char* buff)
+{
+  int fp = 0;
+  fp = open("/tmp/boot.in", O_RDONLY);
+  if(fp > 0 )
+  {
+    read(fp,buff,256);
+    close(fp);
+    return 0;
+  }
+  else
+    return -1;
+}
+void pal_set_boot_option(unsigned char para,unsigned char* pbuff)
+{
+  unsigned char buff[256] = { 0 };
+  unsigned char offset = option_offset[para];
+  unsigned char size   = option_size[para];
+  pal_load_boot_option(buff);
+  memcpy(buff + offset, pbuff, size);
+  pal_save_boot_option(buff);
+}
+
+
+int pal_get_boot_option(unsigned char para,unsigned char* pbuff)
+{
+  if(para > 10)
+  return 0;
+  int ii = 0;
+  unsigned char buff[256] = { 0 };
+  int ret = 0;
+  unsigned char offset = option_offset[para];
+  unsigned char size   = option_size[para];
+  ret = pal_load_boot_option(buff);
+  if (!ret){
+    memcpy(pbuff,(buff + offset), size);
+  }else
+    memcpy(pbuff,buff,size);
+  return size;
+}
